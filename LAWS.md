# Algebraic Laws and Witnesses

This document catalogs the algebraic laws that our functional programming constructs must satisfy. Each law should have:
1. **Law** - The mathematical equation
2. **Shape** - The IR pattern it matches
3. **Witness** - A property test that verifies the law

> **Doc tags:** `Registry Path`, `Witness Builder`, and `Check` highlight how LAWS.md entries map into `markov-oracles.ts` and adapter code. The stub generator reads those fields to verify that documented oracles have concrete scaffolds.

## Registry linkage at a glance

`LAWS.md` serves as the contributor-facing index for every registered law, while the runtime looks to the TypeScript catalogues for executable descriptors. Each Markdown entry mirrors a `registryPath` defined in files such as `relative/relative-laws.ts`. Oracle enumerators (for example `RelativeMonadOracles`, `RelativeAlgebraOracles`, and `RelativeCompositionOracles`) load those descriptors when producing diagnostics so the emitted results reuse the same paths that appear in this document. In short, the Markdown keeps humans oriented, and the registry modules provide the programmatic entry points that law-checking tooling evaluates.

> **Notation:** We use “source/target” (aka domain/codomain) and write composition as \(g \circ f = \texttt{compose(g, f)}\); identity morphisms appear as \(\mathrm{id}_A\) in prose and `id(A)` in code.

## Category-theoretic scaffolding

### Subcategories and fullness

- A **subcategory** of \(C\) chooses objects and arrows of \(C\) that are closed under identities and composition.
- Helpers: `makeSubcategory(C, objs, arrows)` saturates the closure generated by a seed set of objects/arrows.
- A subcategory is **full** when it contains every arrow of \(C\) whose endpoints lie in the chosen objects. Check with `isFullSubcategory(S, C)` and build via `makeFullSubcategory(C, objs)`.
- Registry path: structural only (no oracle).

### Product categories

- Objects of \(C \times D\) are pairs \(\langle C, D \rangle\); arrows are pairs \(\langle f, g \rangle\) with componentwise composition.
- Code: `ProductCat(C, D)` returns the product category; projections `Pi1`, `Pi2` pick out components, and `Pairing(F, G, C, D)` builds the functor induced by two components.
- Universal property: `checkProductUP(C, D, F, G, H, objects, arrows)` confirms that a candidate mediator \(H\) satisfies \(\pi_1 \circ H = F\), \(\pi_2 \circ H = G\), and \(H = \langle F, G \rangle\) on supplied samples.

### Duals and contravariant functors

- The **opposite category** \(C^{\mathrm{op}}\) reverses all arrows while preserving identities. Construct via `Dual(C)`; `isInvolutive(C, arrows, objs)` sanity-checks that \((C^{\mathrm{op}})^{\mathrm{op}} = C` on samples.
- A contravariant functor \(F: C \to D\) is a covariant functor \(C \to D^{\mathrm{op}}\). Build one with `Contra(C, D, F0, F1op)` and verify the identity/reversed-composition laws using `isContravariant(C, D, F, objects, arrows)`.
- Duality principle: any first-order statement about categories remains valid when arrows are reversed. In code, wrap property testers with `dualizeProperty(P)` to automatically obtain the dual assertion.

### Virtual equipment coherence (scaffolding)

- `virtual-equipment/equipment-laws.ts` enumerates the coherence laws we plan to
  check for companions, conjoints, loose monads, and the emerging right
  extension/right lift calculus once the equipment layer is live.  Each law
  is tagged with a registry path such as `virtualEquipment.companion.unit`.
- **Registry Path:** `virtualEquipment` (with nested entries `companion.unit`,
  `companion.counit`, `conjoint.unit`, `conjoint.counit`,
  `looseMonad.unit`, `looseMonad.multiplication`, `skew.composition`, `maps.representableRight`,
  `extensions.rightExtension`, `extensions.rightLift`,
  `extensions.compatibility`, `weighted.cone`, `weighted.cocone`,
  `weighted.colimitRestriction`, `weighted.limitRestriction`,
  `weighted.leftExtension`, `density.identity`,
  `faithfulness.restrictions`, `faithfulness.pointwise`,
  `faithfulness.leftExtension`, `absolute.colimit`,
  `absolute.leftExtension`, `absolute.pointwiseLeftLift`).
- **Witness Builder:** `enumeratePendingEquipmentOracles()` currently records
  the outstanding checks so the oracle registry can surface TODO status.
- **Check:** `EquipmentOracles` functions (`companion.unit`, etc.) return
  structured `{ pending: true }` results until concrete implementations are
  wired up.
- **Implementation Notes:** the oracle stubs live alongside the law catalogue in
  `virtual-equipment/equipment-oracles.ts`, making it straightforward to swap in
  executable witnesses in later steps without changing documentation links.
- **Remark 4.5 / Theorem 4.7 hook:** `virtualEquipment.skew.composition`
  documents the associative-normal left-skew multicategory substitution law.
  The new `virtual-equipment/skew-multicategory.ts` analyzer checks that each
  substitution slot in a loose composite receives a multimorphism with the same
  loose arrow framing and identity vertical boundaries, setting the stage for the
  paper’s Proposition 4.12 equivalence between relative monads and loose
  monoids.
- **Remark 2.20 hook:** `virtualEquipment.maps.representableRight` will certify
  that a loose adjunction whose right leg is representable classifies its left
  leg as a map; until implemented the oracle remains pending but the law is
  catalogued for future automation.
- **Definition 3.2 / Lemma 3.4 hooks:** the pending laws
  `virtualEquipment.extensions.rightExtension`,
  `virtualEquipment.extensions.rightLift`, and
  `virtualEquipment.extensions.compatibility` mirror the paper’s right
  extension/right lift framing requirements and their interplay.  The new
  analyzers in `virtual-equipment/extensions.ts` enforce the structural
  preconditions so executable oracles can be wired in later.
- **Definition 3.9 / Lemma 3.13 / Lemma 3.14 hooks:** the pending laws
  `virtualEquipment.weighted.cone`, `virtualEquipment.weighted.cocone`,
  `virtualEquipment.weighted.colimitRestriction`,
  `virtualEquipment.weighted.limitRestriction`, and
  `virtualEquipment.weighted.leftExtension` are now catalogued.  The
  corresponding analyzers in `virtual-equipment/limits.ts` check that weighted
  cones/cocones reuse the appropriate boundaries, that B(f,1)/B(1,g)
  restrictions respect those boundaries, and that left extensions computed by
  weighted colimits inherit the cocone framing, paving the way for executable
  oracles mirroring Lemmas 3.13–3.14.
- **Definitions 3.19–3.24 hooks:** new registry entries
  `virtualEquipment.density.identity`, `virtualEquipment.absolute.colimit`,
  `virtualEquipment.absolute.leftExtension`, and
  `virtualEquipment.absolute.pointwiseLeftLift` document the density and
  absolute-colimit checks introduced in `virtual-equipment/absoluteness.ts`.
  The accompanying analyzers ensure identity restrictions witness companions,
  j-absolute colimits carry left-opcartesian comparisons, left extensions reuse
  those witnesses, and pointwise left lifts reference the same tight 1-cell.
- **Definitions 3.26–3.29 hooks:** registry paths
  `virtualEquipment.faithfulness.restrictions`,
  `virtualEquipment.faithfulness.pointwise`, and
  `virtualEquipment.faithfulness.leftExtension` catalogue the new analyzers in
  `virtual-equipment/faithfulness.ts`.  They enforce that fully faithful tight
  1-cells admit identity restrictions with representability witnesses, that
  pointwise left extensions and left lifts share their framing data, and that
  left extensions along fully faithful cells carry invertible counits.

### Relative monad scaffolding

- `relative/relative-laws.ts` mirrors Definition 4.1’s unit and extension
  diagrams.  The `relativeMonad.unit.framing` and
  `relativeMonad.extension.framing` entries back the structural invariant
  oracle `RelativeMonadOracles.framing`, ensuring the chosen 2-cells reuse the
  designated root/carrier boundaries.  `relativeMonad.extension.associativity`
  records the pending equality witness for the two composites that appear in
  the associativity pasting diagram.  Use `RelativeMonadOracles` to obtain the
  executable framing report (with issues enumerated) and a placeholder pending
  result for associativity until tight 2-cell comparisons land.
- `relativeMonad.enriched.compatibility` keeps Section 8’s enriched structure
  visible by checking that the recorded hom object and tensor comparison reuse
  the relative monad’s unit and extension witnesses.
- `relativeMonad.enriched.setCompatibility` specialises Example 8.14 to
  Set-enriched roots by requiring the fully faithful section and every listed
  correspondence to reuse the loose arrow, unit, and extension evidence.
- `relative/mnne-vector-monads.ts` replays Example 1 of *Monads Need Not Be
  Endofunctors* by enumerating Boolean finite vector spaces.  Use
  `describeBooleanVectorRelativeMonadWitness` and
  `analyzeFiniteVectorRelativeMonad` to inspect the unit/extension laws and the
  induced Kleisli composites.
- `RelativeMonadOracles.vectorKleisliSplitting` tightens Theorem 3/Example 5 by
  composing every Boolean matrix, confirming the Kleisli identities and
  associativity align with the recorded extension operator.
- `RelativeMonadOracles.vectorArrowCorrespondence` replays the Example 1 arrow
  semantics by comparing an `arr`/composition witness with the canonical
  relative monad extension, ensuring Boolean matrices act on vectors exactly as
  the relative monad prescribes on every enumerated dimension pair.
- `relative/mnne-lambda-monads.ts` mirrors Example 2’s λ-calculus relative
  monad, enumerating well-scoped terms across finite contexts, replaying the
  capture-avoiding substitution operator, and verifying the unit, identity, and
  associativity requirements via `analyzeUntypedLambdaRelativeMonad`.
- `RelativeMonadOracles.lambdaKleisliSplitting` records Example 6’s Kleisli
  category of Lam, reusing the λ-witness to ensure trivial substitutions act as
  identities and composition matches sequential substitution.
- `relative/mnne-indexed-container-monads.ts` operationalises Example 4’s
  indexed container presentation.  `describeIndexedContainerExample4Witness`
  enumerates finite Nat/Stream families while
  `analyzeIndexedContainerRelativeMonad` replays the Example 4
  unit/extraction data and checks the relative monad laws via the induced
  substitution operator.
- The same module also exposes `analyzeFiniteVectorLeftKanExtension` and
  `describeBooleanVectorLeftKanExtensionWitness`, which reconstruct the Example 1
  left Kan extension along FinSet → Set.  They enumerate the cocone data,
  quotient by the generated relations, and confirm the resulting classes match
  the Boolean vector functor on each target set, warning when the chosen
  dimension bound omits necessary generators.
- `relative/mnne-lax-monoidal.ts` packages Section 3.2’s lax monoidal structure
  on `[J,C]` by combining the Lan\_j witness with concrete endofunctors on the
  two-object category.  `analyzeMnneLaxMonoidalStructure` checks that the
  canonical inclusion, tensor, unitors, and associator agree with composing
  Lan\_j and that the triangle identity holds for the supplied triples.
- `analyzeMnneLaxMonoid` verifies the Theorem 3 lax-monoid structure derived
  from a relative monad by checking the recorded unit and multiplication
  transformations satisfy the left/right unit laws and the associativity
  composite using the Lan\_j tensor.
- `RelativeMonadOracles.functorCategoryLaxMonoidal` exposes the same diagnostics
  in the oracle registry, defaulting to the two-object witness so the Example 3
  computations appear alongside the other MNNE oracles.
- `relativeMonad.mnne.functorCategoryLaxMonoid` publishes the lax-monoid
  analyzer through the oracle registry so Example 3’s relative monad ↔ lax
  monoid bridge appears in demos and scripts by default.
- `relativeMonad.mnne.wellBehavedInclusion` witnesses Definition 4.1’s
  full-faithfulness requirement for j : J → C by enumerating finite hom-sets
  and checking that J induces bijections `C(JX, JY) ≅ J(X, Y)` on the supplied
  samples.
- `relativeMonad.mnne.lanExtension` packages Section 4.3’s theorem that a
  well-behaved inclusion extends a relative monad to an ordinary monad on C.
  The oracle checks that Lan\_J T preserves identities/composition, that the
  recorded unit/multiplication satisfy the monad laws, that κ\_T is an
  isomorphism with the supplied inverse, and that the Lan-derived Kleisli
  extension agrees with the relative extension operator on every enumerated
  arrow.
- `relativeMonad.enriched.eilenbergMooreAlgebra` realises Definition 8.16’s
  enriched T-algebra by checking that the carrier shares the monad boundaries,
  the extension operator reuses the enriched extension witness, and the unit
  and multiplication composites coincide with the recorded enriched
  comparisons.
- `relativeMonad.enriched.kleisliInclusion` exposes Lemma 8.7’s
  identity-on-objects inclusion into Kl(T), requiring the functor to reuse the
  loose arrow, unit, and extension witnesses and to supply the κ_T opalgebra
  comparison triangles recorded in the lemma.
- `relativeMonad.enriched.yoneda` packages Example 8.6’s Yoneda embedding,
  demanding that the representable presheaf reuse the enriched hom object,
  tensor comparison, and extension witnesses recorded with the monad.
- `relativeMonad.enriched.yonedaDistributor` captures Lemma 8.7’s comparison of
  the red/green composites through PZ(p,q), insisting that both composites share
  boundaries with the Yoneda witness, coincide with the supplied factorisation,
  and agree with the recorded right lift witnessing the universal property of
  `q ▷ p`.
- `relativeMonad.enriched.vcatSpecification` records Theorem 8.12’s enriched
  specification of a j-relative monad. The oracle demands that the unit and
  multiplication triangles reuse the enriched unit/extension witnesses, that the
  functorial identity/composition diagrams share those comparisons, and that the
  τ witnesses agree with the recorded naturality data.
- `relativeMonad.representableLooseMonoid` captures Theorem 4.16’s bridge
  between j-relative monads and monoids in `X[j]` whose loose arrows are
  representable.  `RelativeMonadOracles.representableLooseMonoid` consumes the
  `RepresentabilityWitness` emitted by the equipment layer’s left restriction
  builders and reports whether the relative monad’s loose arrow truly arises
  from restricting the identity along the chosen root.
- `relativeMonad.fiberEmbedding` records Theorem 4.22’s fully faithful functor
  `E(j,-) : \mathrm{RMnd}(j) → \mathrm{Mnd}_{X[j]}(A)`.  The
  `RelativeMonadOracles.fiberEmbedding` check packages the induced fiber
  monad—reusing the loose arrow, unit, and extension data—while marking the
  outstanding Street-calculus comparisons as pending.
- `relativeMonad.representableRecovery` tracks Remark 4.24’s observation that a
  representable root recovers Levy’s representable relative monads and the
  Altenkirch–Chapman–Uustalu skew monoids.  The oracle combines the fiber
  embedding with any supplied skew-monoid bridge data, surfacing pending status
  when the literature comparisons still await witnesses.
- `relativeMonad.skewMonoid.bridge` aggregates Theorem 4.29’s hypotheses:
  existence and preservation of left extensions along `j`, j-absolute and
  dense comparison data, and invertibility of the right unit.  The
  `RelativeMonadOracles.skewMonoidBridge` oracle threads the corresponding
  analyzers (`analyzeLeftExtensionFromWeightedColimit`,
  `analyzePointwiseLeftExtensionLiftCorrespondence`,
  `analyzeLeftExtensionPreservesAbsolute`,
  `analyzeDensityViaIdentityRestrictions`, and
  `analyzeFullyFaithfulLeftExtension`) together with a loose-monoid framing
  report to certify that the relative monad realises a monoid in the left skew
  monoidal category `X[j]`.
- `relativeMonad.identityReduction` implements Corollary 4.20’s observation that
  ordinary monads embed as j-relative monads with identity roots.  The
  associated oracle `RelativeMonadOracles.identityReduction` checks that the
  root and carrier coincide with the identity boundary and that the loose arrow
  is endo on that object, surfacing actionable diagnostics when the reduction
  fails.
- `enumerateRelativeMonadOracles` collects the default framing, identity,
  extension, and associativity reports into a single array so documentation and
  tooling can present the whole Definition 4.1 diagnostic surface alongside the
  pending associativity witness.
- `AlgebraOracles.relative.checkRelativeMonadLaws` aggregates these reports with
  the new unit-compatibility, associativity, and root-identity analyzers.  The
  helper returns `{holds, pending, details, analysis}` so law-checking tools can
  consume a single structural invariant while still seeing which Street-style
  witnesses remain to be implemented.  Each component exposes its witness data
  (the unit arrow, composed Street pastings, and restriction outputs) so
  downstream debuggers can inspect the exact morphisms responsible for a
  failure.

### Relative algebra scaffolding

- Definitions 6.1 and 6.4 introduce relative algebras and opalgebras.  The registry
  entries `relativeMonad.algebra.framing` and
  `relativeMonad.opalgebra.framing` now point at executable analyzers
  (`RelativeAlgebraOracles.algebraFraming` and
  `RelativeAlgebraOracles.opalgebraFraming`) that verify the supplied action
  2-cells reuse the j-root and carrier boundaries before any universal property
  checks fire.  These framing reports lead off
  `enumerateRelativeAlgebraOracles`, giving downstream tooling immediate
  confirmation that Definition 6.1/6.4 data is wired in before hitting the still
  pending Street-style witnesses.  Companion entries
  `relativeMonad.algebra.morphismCompatibility` and
  `relativeMonad.opalgebra.morphismCompatibility` now surface structural
  analyzers that ensure morphism boundaries reuse the source/target carriers.
  When those checks pass the oracles emit pending diagnostics noting that the
  Street composites `E(j,α)` and `E(t,α)` remain to be compared; any boundary
  mismatch produces an immediate non-pending failure so contributors can repair
  the supplied data before wiring in the remaining witnesses.
- Definition 6.4’s string diagrams split into the carrier triangle and extension
  rectangle.  The new registry entries `relativeMonad.opalgebra.carrierTriangle`
  and `relativeMonad.opalgebra.extensionRectangle` ensure the oracle layer
  captures the shared codomain boundary, the opalgebra carrier, and the monad
  unit/extension witnesses even while the Street equalities remain pending.
  `RelativeAlgebraOracles.opalgebraCarrierTriangle` and
  `RelativeAlgebraOracles.opalgebraExtensionRectangle` surface these structured
  reports so downstream tooling can display the same triangle/rectangle
  diagnostics used in the paper once the comparison pastings are executable.
- Definition 6.29 introduces graded \(T\)-algebra morphisms.
  `relativeMonad.algebra.gradedMorphisms` keeps the \((p_1,\ldots,p_n)\)
  grading data and the displayed comparison pastings visible so future
  analyzers gather the Street-style witnesses before certifying multi-input
  morphisms.
- Remark 6.30 rewrites the graded morphism definition as a single composite
  pasting.  The registry path `relativeMonad.algebra.gradedMorphismsAlternate`
  makes this alternative presentation executable by demanding the pasted
  2-cell and the comparison witnesses that recover the Definition 6.29
  equality.
- Example 6.31 constructs graded morphisms from the extension operator.
  `relativeMonad.algebra.gradedExtensionMorphisms` ensures that the canonical
  extension witnesses are recorded and verified against the graded comparison
  diagrams before the Street analyzers run.
- Remark 6.32 organises the fibrewise categories \(T\text{-Alg}_D\) into an
  indexed family.  The entry `relativeMonad.algebra.indexedFamily` tracks the
  restriction functors, coherence witnesses, and carrier reuse so oracle
  consumers can inspect the indexed structure directly.
- Definition 6.33 packages the fibrewise categories into the global category
  \(\mathrm{Alg}(T)\).  `relativeMonad.algebra.globalCategory` documents the
  object/morphism assignments together with the composition and identity
  witnesses required to run the future analyzer.
- Definition 6.34 introduces the mediating tight cell
  \(f_T : A \to \mathrm{Alg}(T)\) associated to an algebra object.
  `relativeMonad.algebra.mediatingTightCell` keeps the comparison data visible
  so the oracle layer can confirm that \(f_T\) reuses the monad’s unit and
  extension witnesses.
- Lemma 6.35 promotes an algebra object to a resolution.  The path
  `relativeMonad.algebra.resolutionFromAlgebraObject` ensures analyzers collect
  the boundary alignment and comparison data needed to match the Section 5
  resolution diagnostics.
- Remark 6.2 assembles \(T\)-algebras with fixed domain into a category via a
  faithful restriction functor.  The analyzer behind
  `relativeMonad.algebra.restrictionFunctor` now checks that the Street-action
  image reuses the recorded carriers and boundary data while reporting pending
  functoriality/faithfulness witnesses, keeping the comparison visible to
  downstream tooling.
- Example 6.3 highlights the canonical algebra obtained from a relative monad’s
  carrier.  The analyzer behind `relativeMonad.algebra.canonicalAction` now
  checks that the supplied algebra reuses the monad’s tight leg and extension
  2-cell while flagging Proposition 6.12’s Street comparisons as pending, so
  structural regressions surface immediately even before the comparison data
  lands.
- Corollary 6.17 ensures that 1_g-relative algebras reduce to ordinary
  algebras on \(E\).  The `relativeMonad.algebra.identityRootEquivalence`
  analyzer now checks that the relative algebra reuses the identity boundary and
  multiplication witnesses promised by Corollary 4.20, surfacing pending Street
  comparisons while confirming the structural collapse.
- Corollary 6.24 makes the analogous statement for opalgebras.  The new registry
  entry `relativeMonad.opalgebra.identityRootEquivalence` keeps this comparison
  visible so the future analyzer can demand the Street action witnesses and
  reuse the Corollary 4.20 diagnostics while collapsing to ordinary actions on
  \(A\).
- Definition 6.18 reframes \(T\)-opalgebras as right actions in Street’s
  skew-multicategory.  `relativeMonad.opalgebra.rightActionPresentation`
  now ships an analyzer that checks the Street action witness reuses the
  recorded opalgebra action, root, and carrier boundaries while marking the
  string-diagram comparisons as pending.
- Proposition 6.19 shows that the ambient skew multicategory acts on itself
  and that any monoid determines an \(M\)-action.  The
  `relativeMonad.opalgebra.rightActionFromMonoid` analyzer verifies that the
  recorded Street action is framed by the relative monad’s root/carrier and
  that its action 2-cell coincides with the monad extension, surfacing pending
  diagnostics for the remaining Street comparisons.
- Example 6.6 dualises the canonical construction for opalgebras.  The
  `relativeMonad.opalgebra.canonicalAction` analyzer now verifies that the
  recorded opalgebra reuses the monad’s tight leg and unit 2-cell, reporting a
  pending diagnostic until the Proposition 6.19 witnesses arrive so contributors
  can spot boundary mismatches early.
- Lemma 6.7 identifies \(j\)-relative opalgebras with extraordinary
  transformations of the associated loose monad.  The
  `relativeMonad.opalgebra.extraordinaryTransformations` analyzer now records
  the loose monoid witnesses and verifies that they reuse the relative monad’s
  root, carrier, and loose arrow, returning a pending diagnostic until the
  Section 1.4 comparison is executable.
- Section 6.2 reframes relative (op)algebras as Street-style actions and spells
  out concrete witnesses for Definitions 6.9–6.14.  The analyzers behind
  `relativeMonad.actions.rightLeftCoherence`,
  `relativeMonad.actions.streetActionData`,
  `relativeMonad.actions.streetActionHomomorphism`,
  `relativeMonad.actions.homomorphismCategory`,
  `relativeMonad.actions.canonicalSelfAction`,
  `relativeMonad.actions.looseAdjunctionAction`,
  `relativeMonad.actions.looseAdjunctionRightAction`, and
  `relativeMonad.actions.representableRestriction` now run today: each records
  the supplied Street witnesses, checks they reuse the expected root/carrier
  boundaries, and returns a pending diagnostic for the unresolved Street
  equalities so contributors see structural issues immediately.
  The remaining registry paths continue to track future analyzers:
  - `relativeMonad.actions.representableStreetSubmulticategory` captures
    Definition 6.21’s passage to \(\mathsf{X}[j, B]_\iota\) and its
    representable sub-multicategory, keeping the tight cell and representability
    diagnostics visible.
  - `relativeMonad.actions.representableStreetActionDiagrams` records the
    Definition 6.21 string-diagram equalities that identify Street actions with
    the Definition 6.4 opalgebra pastings, ensuring future analyzers request the
    displayed \(\rho\), \(\lambda\), and \(\mu\) composites.
  - `relativeMonad.actions.representableStreetActionHomomorphism` mirrors the
    Definition 6.21 action homomorphism equation, demanding witnesses that both
    composites of \(\mathsf{B}(1, \alpha)\) agree inside the representable
    sub-multicategory.
  - `relativeMonad.actions.relativeAlgebraBridge` now records the Street action
    extracted from Definition 6.1 \(T\)-algebra data, checking that the carrier
    and multiplication 2-cell reuse the algebra witnesses while flagging the
    remaining Street equalities as pending.
  - `relativeMonad.actions.algebraActionIsomorphism` packages Theorem 6.15’s
    comparison, bundling the algebra-to-action bridge, the action-to-algebra
    recovery, and the identity witnesses on both sides so downstream tooling can
    inspect the pending equivalence data.
  - `relativeMonad.actions.representabilityUpgrade` threads Remark 6.16’s
    representability witnesses through the Street action analyzer, verifying
    that the upgrade reuses the recorded action and keeping the representable
    restriction diagnostics visible while the comparison equalities remain
    pending.
  - `relativeMonad.actions.representabilityGeneralisation` extends this outlook
    to Remark 6.23’s Street action multicategories \(\mathsf{X}[j, B]\),
    signalling that future analyzers must gather the loose-extension witnesses
    establishing representability and compare them with the Theorem 4.29
    diagnostics already in the registry.
  - `relativeMonad.actions.representableActionIsomorphism` runs Theorem 6.22’s
    natural isomorphism \(\mathrm{Act}(\mathsf{X}[j,B]_\iota^{B}, T) \cong
    T\text{-Opalg}_B\) through `analyzeRelativeOpalgebraStreetActionEquivalence`,
    recording the Street/opalgebra bridge, recovery homomorphism, and structural
    comparison while leaving the inverse functor witnesses pending.
- `relativeMonad.opalgebra.representableActionBridge` extends the Street bridge
  to the representable setting, ensuring the analyzer requests the Definition 6.4
  opalgebra data, the representability witnesses, and the resulting action in
  \(\mathsf{X}[j,B]_\iota^{B}\).
- Remark 6.5 compares Definition 6.4 opalgebras with modules of Ahrens,
  Maillard’s Kleisli algebras, and Lobbia’s relative right modules.  The entry
  `relativeMonad.opalgebra.literatureRecoveries` records this cross-check so the
  future analyzer can demand witnesses that translate between the relative
  opalgebra data and each cited presentation.
- Remark 6.8 points toward a two-dimensional opmulticategory treatment of
  relative monads.  The placeholder `relativeMonad.actions.twoDimensionalModules`
  keeps the prospective module analyzers on the radar by documenting the need to
  compare the one-dimensional actions with Altenkirch–Chapman–Uustalu style
  modules.

### Relative comonad scaffolding

- `relative/relative-comonads.ts` dualises the relative monad analyzers to the
  counit/coextension setting.  The law entries
  `relativeComonad.counit.framing` and `relativeComonad.coextension.framing`
  back `RelativeComonadOracles.counitFraming` and
  `RelativeComonadOracles.coextensionFraming`, certifying that the 2-cells reuse
  the carrier/root boundaries required by the dual of Definition 4.1.
- `relativeComonad.corepresentableLooseComonoid` captures the dual of
  Theorem 4.16.  `RelativeComonadOracles.corepresentability` consumes the right
  restriction witness emitted by the equipment layer and confirms that
  `C(t,j)` arises from restricting the identity along `j`.
- `relativeComonad.identityReduction` mirrors Corollary 4.20: the
  `RelativeComonadOracles.identityReduction` oracle demands that the root and
  carrier are identities so the structure collapses to an ordinary comonad.
- `relativeComonad.enriched.structure` packages Proposition 8.22, asking
  `RelativeComonadOracles.enrichment` to compare the enriched cohom object and
  cotensor comparison against the recorded counit/coextension witnesses.
- `relativeComonad.coopAlgebra` documents Theorem 8.24 by invoking
  `RelativeComonadOracles.coopAlgebra`, which checks that the coopalgebra
  coassociativity/counit diagrams commute and reuse the enriched comparisons.

### Relative composition and representation scaffolding

- `relative/relative-composition.ts` introduces analyzers for Corollary 5.34 and
  Corollary 5.40, verifying that the right leg of one relative adjunction
  matches the root of the next and that consecutive relative monads share
  carriers/loose arrows.  The law registry entries
  `relativeAdjunction.composition.compatibility` and
  `relativeMonad.composition.compatibility` surface these diagnostics via
  `RelativeCompositionOracles.adjunctionComposition` and
  `RelativeCompositionOracles.monadComposition`.
- `relativeMonad.representation.looseMonoid` registers the executable bridge
  between relative monads and loose monoids.  The oracle
  `RelativeCompositionOracles.looseMonoidBridge` converts a loose monoid into a
  relative monad, combining the loose monoid framing report with the relative
  monad analyzer to document success or precise failures.

### Relative adjunction scaffolding

- `relative/relative-adjunctions.ts` introduces `RelativeAdjunctionData` and the
  analyzers `analyzeRelativeAdjunctionFraming` and
  `analyzeRelativeAdjunctionHomIsomorphism`, tracking Definition 5.1’s domain
  and codomain requirements for the root, left, and right legs together with the
  hom-set isomorphism between `C(ℓ-, -)` and `E(j-, r-)`. The associated law
  entries `relativeAdjunction.framing` and `relativeAdjunction.homIso.framing`
  surface structured diagnostics via `RelativeAdjunctionOracles`.
- `relativeAdjunction.section.partialRightAdjoint` realises Lemma 6.38’s
  partial right adjoint. The analyzer now certifies that the recorded section
  shares the left leg’s object boundaries, reuses the adjunction’s hom-set
  bijection, and that both composites ℓ ∘ σ and σ ∘ ℓ collapse to the supplied
  identity 2-cells, making the triangle identities executable.
- `relativeAdjunction.unitCounit.presentation` now executes the Lemma 5.5
  boundary checks. `RelativeAdjunctionOracles.unitCounitPresentation` accepts an
  explicit unit/counit presentation, verifies that the 2-cells reuse the root,
  left, and right tight boundaries, and reports a pending diagnostic only when
  no presentation accompanies the adjunction data.
- `relativeAdjunction.pointwiseLeftLift` captures Proposition 5.8, which
  computes the right relative adjoint as a pointwise left lift of \(ℓ\) along
  \(j\). The oracle `RelativeAdjunctionOracles.pointwiseLeftLift` threads the
  `analyzePointwiseLeftLift` report into the adjunction framing, flagging
  mismatched domains/codomains when the lift fails to recover the right leg.
- `relativeAdjunction.rightExtension` reflects Proposition 5.10’s construction
  of right relative adjoints via left extensions along a fully faithful root.
  The oracle aggregates `analyzeLeftExtensionFromWeightedColimit`,
  `analyzeFullyFaithfulLeftExtension`, and the pointwise lift correspondence to
  surface any missing hypotheses.
- `relativeAdjunction.colimitPreservation` enforces Proposition 5.11 by
  comparing a shared weight preserved by \(j\) and \(ℓ\). The oracle checks that
  both left extensions reuse the same weight boundaries and that, whenever the
  root preserves the colimit, the left leg does as well.
- `relativeAdjunction.leftMorphism` records Definition 5.14. The analyzer
  ensures both relative adjunctions share the same root, that the comparison
  tight cell runs between their apices, and that the supplied 2-cell reuses the
  left legs as its vertical boundaries, making Lemma 5.17’s embedding into the
  slice category \(\mathcal{X}/E\) executable.
- `relativeAdjunction.rightMorphism` dualises the previous item for
  Definition 5.18. The analyzer checks that the comparison tight cell runs
  between the domains of the right legs and that the framed 2-cell mirrors the
  coslice embedding from Lemma 5.21.
- `relativeAdjunction.strictMorphism` packages Definition 5.23. The oracle
  demands that the left and right morphism data agree on their comparison tight
  cell and combines both framing reports to witness strict morphisms as common
  refinements of the left/right notions.
- `relativeAdjunction.resolution.relativeMonad` keeps Theorem 5.24 visible in
  the registry; `relativeMonadFromAdjunction` now synthesises the induced
  relative monad so the analyzer can immediately compare the recorded
  unit/extension data against the adjunction’s hom-isomorphism witnesses.
- `relativeResolution.definition.5.25` certifies that a resolution records the
  inclusion \(j\), apex loose morphism, and comparison isomorphisms that
  reconstruct the underlying \(j\)-relative monad while caching the witnesses
  for Propositions 5.29–5.30, Remark 5.33, Example 5.31, Corollary 5.32, and
  Proposition 5.37.
- `relativeResolution.category.identities` checks that morphisms of resolutions
  admit identity arrows satisfying the left/right unit axioms so the category
  \(\mathrm{Res}(T)\) remains well defined.
- `relativeResolution.precomposition.suite` aggregates the executable data for
  Proposition 5.29 precomposition, Proposition 5.30 pasting, Remark 5.33 and
  Corollary 5.34’s resolute-composition guarantees, Example 5.31/Corollary 5.32
  fully faithful postcomposition, and Proposition 5.37 transport along left
  relative adjoints.
- `relativeAdjunction.pasting.leftMorphism` runs
  `analyzeRelativeAdjunctionPasting`, checking that a nested pair of relative
  adjunctions shares equipment, that the outer right leg matches the inner root,
  that the pasted left leg equals the composite of the two left legs, and that
  the induced left morphism report is free of issues, making Proposition 5.30
  executable.
- `relativeAdjunction.postcomposition.fullyFaithful` runs
  `analyzeRelativeAdjunctionFullyFaithfulPostcomposition`, confirming that a
  fully faithful tight 1-cell `u` postcomposes the root and right leg while
  leaving the left leg fixed. The oracle records the composites `u ∘ j` and
  `u ∘ r` together with the fully faithful analysis returned by the equipment
  layer.
- `relativeAdjunction.inducedMonads.coincide` compares the paired relative
  monads promised by Corollary 5.32, checking that their roots, carriers, loose
  arrows, and unit/extension frames agree verbatim.
- `relativeAdjunction.resolute` now runs
  `analyzeRelativeAdjunctionResolutePair`, combining the fully faithful
  postcomposition report with the induced-monad coincidence analysis while
  checking that the monad data reuse the original and postcomposed right legs.
- `relativeAdjunction.resolute.leftMorphism` aggregates
  `analyzeRelativeAdjunctionResoluteLeftMorphism`, threading the resolute pair,
  the Proposition 5.29 precomposition report, and the Proposition 5.30 pasting
  witness so the induced left morphism is only marked complete when all three
  diagnostics align.
- `relativeAdjunction.resolute.identityRoot` wraps the Corollary 5.34 analyzer
  via `analyzeRelativeAdjunctionOrdinaryLeftAdjointComposition`, bubbling up
  the same issues array while tagging the identity-root specialisation required
  by Example 5.35.
- `relativeAdjunction.relativeMonad.module` is backed by
  `analyzeRelativeAdjunctionRelativeMonadModule`, threading the Corollary 5.34
  resolute left morphism through the relative monad resolution diagnostics to
  certify the Proposition 5.36 module action.
- `relativeAdjunction.relativeMonad.pasting` now delegates to
  `analyzeRelativeAdjunctionRelativeMonadPasting`, which consumes the pasted
  unit and extension witnesses from Proposition 5.37 and checks that the
  resulting \(j'\)-relative monad and comparison morphism reuse the supplied
  adjunction boundaries.
- `relativeAdjunction.relativeMonad.pastingFullyFaithful` wraps
  `analyzeRelativeAdjunctionRelativeMonadPastingFullyFaithful`, layering the
  fully faithful right adjoint witness over the pasting diagnostics to expose
  the Example 5.38 functor on relative monads.
- `relativeAdjunction.relativeMonad.pastingAdjunction` collects the two
  Proposition 5.37 reports via
  `analyzeRelativeAdjunctionRelativeMonadPastingAdjunction`, confirming the
  shared intermediate monad required by Example 5.39.
- `relativeAdjunction.relativeMonad.compositeThroughRoot` relies on
  `analyzeRelativeAdjunctionRelativeMonadComposite`, combining the module
  assignment with the pasting witnesses so Corollary 5.40’s comparison against
  the pasted \(j'\)-relative monad is executable.
- `relativeAdjunction.relativeMonad.literatureRecoveries` invokes
  `analyzeRelativeAdjunctionRelativeMonadLiteratureRecoveries`, which now
  accepts Hutson and Altenkirch–Chapman–Uustalu witnesses to demonstrate the
  Example 5.41 recoveries.

The Section 6.4 entries `relativeAdjunction.relativeMonad.leftOpalgebra`,
  `relativeAdjunction.relativeMonad.rightAlgebra`, and
  `relativeAdjunction.relativeMonad.resolutionFunctor` execute via
  `analyzeRelativeAdjunctionRelativeMonadLeftOpalgebra`,
  `analyzeRelativeAdjunctionRelativeMonadRightAlgebra`, and
  `analyzeRelativeAdjunctionRelativeMonadResolutionFunctor`, checking that the
  recorded (op)algebra actions reuse the adjunction boundaries and the induced
  relative monad from Proposition 5.24 while marking the Street comparisons as
  pending.  Proposition 6.27’s transports now run through
  `analyzeRelativeAdjunctionRelativeMonadOpalgebraTransport` and
  `analyzeRelativeAdjunctionRelativeMonadAlgebraTransport`, which validate the
  pasting witness, confirm source/target framing, and record the supplied
  naturality diagnostics.  Remark 6.28’s strengthened statement is captured by
  `analyzeRelativeAdjunctionRelativeMonadTransportEquivalence`, aggregating the
  dual transports with unit/counit comparisons so the remaining equivalence
  witnesses stay visible to oracle consumers.

### Relative Kleisli and Eilenberg–Moore scaffolding

- `relative/relative-algebras.ts` provides
  `RelativeKleisliPresentation`/`RelativeEilenbergMoorePresentation` together
  with `analyzeRelativeKleisliUniversalProperty` and the enriched
  `analyzeRelativeEilenbergMooreUniversalProperty`. These analyzers ensure the
  opalgebra/algebra actions reuse the designated root/carrier boundaries while
  recording the comparison functor, partial right adjoint, and graded
  factorisations predicted by Theorem 6.39 and Theorem 6.49.
- `relativeMonad.algebra.partialRightAdjointFunctor` packages the witnesses
  from Corollaries 6.40–6.41 and Proposition 6.42. The oracle
  `RelativeAlgebraOracles.partialRightAdjointFunctor` threads the Lemma 6.38
  section report, invokes the fully faithful diagnostics for the comparison
  tight cell, and confirms that the supplied j-objects remain fixed under the
  partial right adjoint.
- `relativeMonad.opalgebra.resolution` wires Lemma 6.47 into code: the oracle
  lifts a relative opalgebra into the Lemma 6.35 resolution, reuses the carrier
  and action witnesses, and reports the κ\_t triangle identities alongside the
  nested relative-monad diagnostics.
- `relativeMonad.opalgebra.partialLeftAdjointSection` exposes Theorem 6.49’s
  section \(RAdj\_j(j) \to RMnd\_j\).  The analyzer reuses the opalgebra
  resolution, checks that the induced monad matches the Lemma 6.47 comparison,
  and confirms the recorded transpose is the identity on \(j\)-objects.
- `relativeMonad.kleisli.universalOpalgebra` and
  `relativeMonad.eilenbergMoore.universalAlgebra` catalogue the executable
  structural invariants exposed by `RelativeAlgebraOracles`. The registry entry
  `relativeMonad.universal.strengthenedComparisons` keeps the stronger universal
  property checks visible while their oracles remain pending.

## Core Algebraic Structures

### Initial tensor unit induces semicartesian structure

- **Domain**: Symmetric monoidal categories whose tensor unit is an initial object.
- **Statement**: For every object \(X\), the canonical arrow \(!_{X} : I \to X\) induced by initiality is unique, yielding a semicartesian structure.
- **Rationale**: These canonical global elements supply the discard-style maps required for the paper's weak infinite products.
- **Oracle**: `checkInitialUnitSemicartesian(data, targets, samples)` → `{ holds, witness, details, failures }`
- **Witness**: `SemicartesianStructure` exposing `globalElement(X)` for each object.
- **Tests**: `law.SemicartesianCRingPlus.spec.ts`
- **Examples**: `CRing_⊕` with initial object `ℤ` via `checkCRingPlusInitialSemicartesian`.
- **Implementation Notes**: Extendable to any category providing an `InitialObjectWitness` whose object matches the tensor unit.

### CRing⊕ causality counterexample

- **Domain**: Additive/unit-preserving morphisms between commutative rings regarded as objects of `CRing_⊕`.
- **Statement**: There exist morphisms \(h_1, h_2 : \mathbb{Z}[t] \to \mathbb{Z}[t]\), \(g : \mathbb{Z}[t] \to \mathbb{Z}[t]\), and \(f : \mathbb{Z}[t] \to \mathbb{Z}[t]\) such that \(f \circ g \circ h_1 = f \circ g \circ h_2\) yet \(g \circ h_1 \neq g \circ h_2\), demonstrating a failure of the causal no-signalling principle.
- **Rationale**: Demonstrates that semicartesian structure alone does not enforce the causal no-signalling principle, motivating the paper’s distinction between semicartesian and Markov infinite products.
- **Oracle**: `checkCRingPlusCausalityCounterexample()` → `{ holds, equalAfterObservation, equalBeforeObservation, witness, homChecks, details }`
- **Witness**: `buildCRingPlusCausalityScenario()` packages the canonical evaluation and shift morphisms on \(\mathbb{Z}[t]\) whose composites satisfy the counterexample.
- **Tests**: `law.CRingPlusCausalityCounterexample.spec.ts`
- **Examples**: Polynomial evaluation at 0 and 1 together with the substitution \(t \mapsto t+1\) supply the morphisms.
- **Implementation Notes**: Witness extraction records explicit polynomials separating \(g \circ h_1\) from \(g \circ h_2\) while confirming each morphism preserves 0, 1, addition, and negation.

### Complex numbers as a C*-algebra

- **Domain**: The C*-algebra of complex numbers with conjugation and the standard absolute-value norm.
- **Statement**: Complex conjugation is an involutive *-anti-automorphism, \(\|z^* z\| = \|z\|^2\) for every \(z \in \mathbb{C}\), and canonical *-homomorphisms are contractive.
- **Rationale**: Supplies the baseline C*-algebra promised in the paper so additional operator-algebra structures can reuse concrete witnesses and diagnostics.
- **Oracles**: `checkComplexCStarAxioms(samples, scalars, tolerance)` and `checkComplexIdentityHomomorphism(samples, scalars, tolerance)`.
- **Witness**: `ComplexCStarAlgebra` packages the algebraic operations, star, norm, and positivity; `identityComplexHom` exposes the canonical *-homomorphism.
- **Tests**: `law.CStarAlgebra.spec.ts`
- **Examples**: Default samples include \(0\), \(1\), \(i\), and \(-2 + 3i\) together with scalars \(1\), \(i\), and \(2 - i\).
- **Implementation Notes**: Diagnostics report the failing axiom along with tolerance-aware discrepancies whenever a user-supplied structure or morphism misbehaves.

### Spectral decomposition of complex C*-algebra elements

- **Domain**: The complex C*-algebra \(\mathbb{C}\) equipped with conjugation and the absolute-value norm.
- **Statement**: Every element \(z \in \mathbb{C}\) decomposes uniquely as \(z = y + i z'\) with \(y, z'\) self-adjoint (real-valued) and both \(y = \frac{1}{2}(z + z^*)\) and \(z' = -\frac{i}{2}(z - z^*)\) lying in the self-adjoint subspace.
- **Rationale**: Encodes the spectral-theory prerequisite that tail-event constructions rely on—showing that even in the base C*-algebra, self-adjoint parts and normal elements are observable with executable witnesses.
- **Oracle**: `checkComplexSpectralTheory(samples, tolerance)` and the general `checkCStarSpectralTheory(algebra, elements, tolerance)`.
- **Witness**: `ComplexCStarAlgebra` combined with `realPartCStar`/`imaginaryPartCStar` expose the decomposition, while `isSelfAdjoint` and `isNormal` certify structural properties.
- **Tests**: `law.CStarAlgebra.spec.ts` exercises decomposition, normality, and the canonical helper.
- **Examples**: Default samples \(0, 1, i, -2 + 3i\) illustrate real/imaginary projections and certify the normality of complex scalars.
- **Implementation Notes**: Reports include tolerance-aware discrepancy norms so alternative C*-algebra instances can diagnose failures in their spectral decomposition data.

### Copy/discard witness a commutative comonoid on every object

- **Domain**: Markov categories equipped with designated copy \(\Delta_X: X \to X \otimes X\) and discard \(!_{X}: X \to I\) morphisms.
- **Statement**: The chosen \(\Delta_X\) and \(!_{X}\) satisfy coassociativity, commutativity, and the left/right counit diagrams, making \(X\) a commutative comonoid.
- **Rationale**: Packages copy/discard data as law-checked structure rather than implicit assumptions, enabling reuse with inverse limits and other carriers.
- **Oracle**: `checkMarkovComonoid(witness)` → `{ holds, failures, details, copyCoassoc, copyCommut, copyCounitL, copyCounitR }`
- **Witness**: `MarkovComonoidWitness` bundling the object, copy, and discard morphisms (optionally relabelled).
- **Tests**: `law.MarkovCategory.spec.ts`
- **Examples**: Finite Markov kernels via `buildMarkovComonoidWitness(mkFin([...]))` and deterministic comonoid homomorphisms in the same spec.
- **Implementation Notes**: Homomorphisms validated with `checkMarkovComonoidHom(domain, codomain, f)` returning detailed preservation diagnostics.

### Deterministic morphisms are precisely comonoid homomorphisms

- **Domain**: Markov categories whose objects carry `MarkovComonoidWitness` data.
- **Statement**: A morphism \(f : X \to Y\) is deterministic iff it preserves copy and discard; equivalently, \(f\) is a comonoid homomorphism between \(X\) and \(Y\).
- **Rationale**: Characterizes the deterministic subcategory `C_det` highlighted in the paper and exposes executable checks for its cartesian behaviour.
- **Oracle**: `checkDeterministicComonoid(witness)` → `{ holds, deterministic, comonoidHom, equivalent, failures, details }`
- **Witness**: `MarkovDeterministicWitness` constructed via `buildMarkovDeterministicWitness` or `certifyDeterministicFunction` to pair kernels with their comonoid structures.
- **Tests**: `law.MarkovCategory.spec.ts`
- **Examples**: Dirac kernels over finite carriers, and nondeterministic mixtures that trigger the counterexample diagnostics.
- **Implementation Notes**: Equivalence failures report when deterministic recognition and comonoid preservation disagree, mirroring the paper’s discussion of deterministic subcategories.

### p-Almost-Sure Equality with Deterministic Left Leg

**Law**
 In a causal Markov category, for \(p : A \to X\) and \(f,g : X \to Y\) with \(f\) deterministic, if \(f \circ p = g \circ p\) on the support of \(p\), then \(f =_{p\text{-a.s.}} g\).

**Shape**

```
A ──p──▶ X ──f(det)──▶ Y  ≈  A ──p──▶ X ──g──▶ Y   (on supp(p))
```

**Oracle**
 `MarkovOracles.almostSure.check(witness, { tolerance })`
 Also: `MarkovOracles.almostSure.holds(witness, { tolerance })`

**Witness**
 `MarkovOracles.almostSure.witness(p, f, g, { label })`
 Records support mass, pointwise diffs, and composites \(f∘p\), \(g∘p\).

**Tests**

- Positive: \(g=f\) except on a set with mass < tolerance
- Negative: introduce a small but non-negligible discrepancy and expect a concrete counterexample in `failures`

### Conditional independence via factorization

- **Domain**: Markov categories equipped with copy/discard structure on the conditioning object and output factors.
- **Statement**: A kernel \(p : A \to X_1 \otimes \dots \otimes X_n\) displays conditional independence \(X_1 \perp \dots \perp X_n \mid A\) precisely when it equals the tensor product of its marginals composed with the iterated copy of \(A\), and this equality is invariant under permutations of the tensor factors.
- **Rationale**: Makes conditional independence a law-checked, witness-driven notion so stochastic processes and tails reuse the factorization principle without diagram chasing.
- **Oracle**: `checkConditionalIndependence(witness, { permutations })` → `{ holds, equality, components, factorized, failures, permutations, details }`
- **Witness**: `buildMarkovConditionalWitness(domain, outputs, p, { projections, label })` supplying comonoid data, the kernel, and (optionally) custom projections.
- **Tests**: `law.MarkovConditionalIndependence.spec.ts`
- **Examples**: Independent stochastic kernels built via `pair` or correlated counterexamples that fail the factorization check.
- **Implementation Notes**: Default projections assume left-associated tensor products; exotic codomains can override them via the witness options.

### Deterministic Pushforward under Conditional Independence

**Law**
 If \(p : A \to X\) and \(s : X \to T\) is deterministic, and the joint displays \(X \perp T \parallel A\), then \(s \circ p : A \to T\) is deterministic.

**Shape**

```
A ──p──▶ X ──s(det)──▶ T
   (X ⟂ T ∥ A)
```

**Oracle**
 `MarkovOracles.determinism.lemma(witness, { tolerance })`
 Internally uses:

- Conditional independence checker for \(X \perp T \parallel A\)
- `isDeterministic` on \(s \circ p\)

**Witness**
 `MarkovOracles.determinism.lemmaWitness(p, s, { label })`

**Tests**

- Positive: independent \(X,T\) under \(p\), with \(s\) a copy/discard-built deterministic map
- Negative: violate CI and confirm report flags `ciVerified=false` and/or `deterministic=false`

### Kolmogorov Zero–One Law

**Law**
 Let \(C\) be a Markov category with Kolmogorov products \(X_J\) and finite marginals. If \(p : A \to X_J\) displays \(\perp_{i\in J} X_i \parallel A\) and for every finite \(F\subseteq J\) the joint with \(\pi_F\) and deterministic \(s : X_J \to T\) displays \(X_F \perp T \parallel A\), then \(s \circ p\) is deterministic.

**Shape**

```
A ──p──▶ X_J ──s(det)──▶ T
  (⊥ over i∈J)      and  (∀ finite F: X_F ⟂ T ∥ A)
```

**Oracle**
 `MarkovOracles.zeroOne.kolmogorov.check(witness, { tolerance })`
 Internally uses:

- CI checker for the family independence and each finite \(F\) clause
- `MarkovOracles.determinism.lemma(...)` to conclude determinism

**Witness**
 `MarkovOracles.zeroOne.kolmogorov.witness(p, s, finiteMarginals, { label })`
 `finiteMarginals` supplies \(\pi_F\) entries to test.

**Tests**

- `law.MarkovZeroOne.spec.ts`
- `law.MarkovZeroOneBorel.spec.ts`

### Hewitt–Savage Zero–One Law

**Law**
 If \(C\) is a causal Markov category, \(X_J\) the Kolmogorov power of \(X\), and \(p : A \to X_J\), \(s : X_J \to T\) deterministic, then:

1. \(p\) displays conditional independence \(\perp_{i\in J} X_i \parallel A\).
2. For every finite permutation \(\sigma : J \to J\), we have \(\hat\sigma \circ p = p\) and \(s \circ \hat\sigma = s\).
    Then the composite \(s \circ p : A \to T\) is deterministic.

**Shape**

```
   A ──p──▶ X_J ──s──▶ T
```

with invariance under finite permutations of \(J\).

**Oracle**
 `MarkovOracles.zeroOne.hewittSavage.check(witness, {tolerance})`

- Internally reuses:
  - `MarkovOracles.zeroOne.kolmogorov.check(...)`
  - `MarkovOracles.determinism.lemma(...)`
  - `MarkovOracles.almostSure.check(...)`

so failures can be traced to sub-lemmas.

**Witness**
 Built via `MarkovOracles.zeroOne.hewittSavage.witness(p, s, finiteMarginals, permutations, {label})`

- Stores the Kolmogorov power, deterministic statistic \(s\), finite marginal projections, and chosen permutation family.

**Tests**

- Finite product families \(X_J\) with toy distributions.
- Check that deterministic statistics are permutation invariant.
- Ensure failures are reported if `s` is replaced by a non-invariant kernel.

### Kolmogorov zero–one law in BorelStoch

> If \(\Omega\) is a standard Borel space with probability measure \(P\) and \((f_i)\) a sequence of
> independent random variables, then any tail event \(T\) has \(P(T) \in \{0,1\}.\)

**Witness Builder:** `buildBorelKolmogorovWitness(omega, coords, product, projF, tail, options)`

**Check:** `MarkovOracles.zeroOne.borel.check(witness)`

**Registry Path:** `zeroOne.borel`

**Interpretation:** determinism of `s ∘ p` encodes `P(T) ∈ {0,1}` for tail events in BorelStoch.

### Hewitt–Savage zero–one law in BorelStoch

> If \(\Omega\) is a standard Borel space with probability measure \(P\) and \((f_i)\) are i.i.d.
> random variables, then any permutation-invariant event \(T\) has \(P(T) \in \{0,1\}.\)

**Witness Builder:**
`buildBorelHewittSavageWitness(omega, coords, product, projF, permutations, indicator, options)`

**Check:** `MarkovOracles.zeroOne.borelHewittSavage.check(witness)`

**Registry Path:** `zeroOne.borelHewittSavage`

**Interpretation:** determinism of `s ∘ p` expresses `P(T) ∈ {0,1}` under finite permutation invariance.

### Top/Vietoris (Kl(H))

- **Kolmogorov products:** Supported via the standard infinite product topology.
  These guarantee the categorical requirements for Kolmogorov zero–one laws.
  Stub + witness adapters live in `top-vietoris-examples.ts`.

- **Constant-function law:** Continuous maps into a Hausdorff space that are
  independent of all finite subsets of the input are necessarily constant. This mirrors the
  tail-triviality intuition for topological hyperspaces.

- **Hewitt–Savage zero–one law:** **Not supported.**
  Kl(H) is not causal. As per guidelines, HS oracles are implemented as explicit throwing
  stubs, so limitations are visible at runtime.

- **Open problem:** Finding an interesting causal Markov category with all Kolmogorov
  products remains open.

**Registry Path:** `top.vietoris`

### Semicartesian infinite tensor products

- **Domain**: Semicartesian symmetric monoidal categories equipped with finite tensor products over every finite subset of an index set.
- **Statement**: The chosen object \(X_J\) together with projections \(\pi_F : X_J \to X_F\) forms a cone compatible with all restriction maps and is universal among such cones.
- **Rationale**: Encodes the universal property underpinning infinite tensor products so that joint states can be reasoned about synthetically.
- **Oracles**: `checkSemicartesianProductCone(product, restrictions)` and `checkSemicartesianUniversalProperty(product, cones, subsets)`.
- **Witness**: `SemicartesianProductWitness` bundling the diagram, projections, and factorization builder; cones supplied via `SemicartesianCone`.
- **Tests**: `law.SemicartesianInfiniteProduct.spec.ts`
- **Examples**: Finite-set cones extending assignments by restriction and deterministic completions that witness uniqueness.
- **Implementation Notes**: Mediator candidates expose uniqueness diagnostics, while subset selections keep the compatibility checks tractable for large index sets.

### CRing⊕ infinite tensors as filtered colimits

- **Domain**: Commutative rings and additive/unit-preserving morphisms viewed inside `CRing_⊕` together with index families of tensor factors.
- **Statement**: The formal sum object generated by finitely supported elementary tensors realises the filtered colimit of the finite tensor diagram; inclusions from finite subsets commute with restrictions and every element is determined by a finite support.
- **Rationale**: Implements Example 3.4 by turning the folklore “finite sums of elementary tensors” description into executable colimit structure on the algebraic side of the paper.
- **Oracles**: `checkFilteredCompatibility(witness, inclusions)` and `checkColimitCoverage(witness, samples)`.
- **Witness**: `defaultFilteredWitness(family)` derived from `TensorFamily` data packages inclusions, restrictions, and support tracking for the filtered diagram.
- **Tests**: `law.CRingPlusInfiniteTensorColimit.spec.ts`
- **Examples**: Tensor families generated from copies of `ℤ` confirm that addition, multiplication, and inclusions respect the filtered system, with samples covering mixed-support sums.
- **Implementation Notes**: Normalisation removes unit-valued factors and merges duplicate elementary tensors so compatibility can be checked symbolically.

### Finite-index reduction for Kolmogorov products

- **Domain**: Projective families in Markov categories endowed with Kolmogorov-consistent marginals and a chosen distribution on the limit carrier.
- **Statement**: When the index set \(J\) is finite, pushing a projective family's measure forward along the universal projection \(\pi_J\) reproduces the canonical finite tensor marginal specified by the family.
- **Rationale**: Confirms that the abstract infinite tensor coincides with the ordinary finite tensor product whenever only finitely many factors are involved.
- **Oracle**: `checkFiniteProductReduction(obj, measure, subset)` → `{ ok, expected, actual }`.
- **Witness**: Uses the family’s marginal distributions together with the supplied limit measure; no additional witness extraction is required.
- **Tests**: `law.MarkovInfinite.spec.ts`
- **Examples**: Independent Bernoulli product measures whose two-factor pushforwards yield the same \(\mathrm{Bernoulli}^{\otimes 2}\) distribution computed directly from coordinates.
- **Implementation Notes**: Raises whenever the provided measure’s semiring disagrees with the family, keeping cross-semiring reasoning sound.

### Copy/discard compatibility of infinite projections

- **Domain**: Infinite product objects in Markov categories equipped with commutative comonoid (copy/discard) structure.
- **Statement**: For every finite subset \(F \subseteq J\), the projection \(\pi_F\) factors through copy followed by discarding one leg and projecting the other, matching the canonical diagram from Remark 3.3.
- **Rationale**: Demonstrates that the universal projections cooperate with comonoid data, ensuring tail constructions respect the Markov-category copy/discard intuition.
- **Oracle**: `checkCopyDiscardCompatibility(obj, subsets, samples)` → `{ ok, failures }`.
- **Witness**: Diagnostics list offending samples together with direct and copy/discard-composed pushforwards when compatibility fails.
- **Tests**: `law.MarkovInfinite.spec.ts`
- **Examples**: IID Bernoulli cylinders where every tested section yields identical pushforwards whether projected directly or via copy/discard composition.
- **Implementation Notes**: Works with deterministic copy maps returned by `createInfObj`, but also surfaces violations for bespoke infinite carriers that implement non-standard copy semantics.

### Kolmogorov products via deterministic marginals

- **Domain**: Infinite tensor products in Markov categories whose canonical projections land in finite tensor factors.
- **Statement**: The projections \(\pi_F : X_J \to X_F\) of a Kolmogorov product are deterministic and commute with the copy/discard comonoid, so every tested sample yields a unique finite section and matches the copy–discard factorization.
- **Rationale**: Encodes the Kolmogorov compatibility requirement between infinite tensor products and comonoid structure, distinguishing Kolmogorov products from merely semicartesian cones.
- **Oracle**: `checkKolmogorovProduct(obj, subsets, samples)` → `{ ok, deterministic, copyDiscard, determinismFailures }`.
- **Witness**: Failure reports return the offending subset, sample, and aggregated marginal distribution whenever determinism breaks.
- **Tests**: `law.MarkovInfinite.spec.ts`
- **Examples**: Independent Bernoulli families satisfy the determinism and copy/discard conditions, whereas modified projective families with randomized projections fail the determinism check while keeping copy/discard data intact.
- **Implementation Notes**: Builds atop `checkCopyDiscardCompatibility`, reusing countability and measurability diagnostics already threaded through infinite product objects.

### Deterministic mediators for Kolmogorov products

- **Domain**: Kolmogorov product objects whose projective families carry positivity metadata and deterministic singleton projections.
- **Statement**: Any deterministic family of component arrows \((f_j)_{j\in F}\) into the coordinates of a Kolmogorov product factors uniquely through the universal deterministic mediator, and any competing mediator agreeing on the chosen coordinates coincides on all tested inputs.
- **Rationale**: Operationalises Proposition 4.3 by providing executable evidence for the categorical product universal property inside the deterministic subcategory, rather than relying on external reasoning.
- **Oracle**: `checkDeterministicProductUniversalProperty(witness, candidate, subset, options)` → `{ ok, components, factorization, mediatorAgreement, mismatches, uniqueness, partitions, … }`.
- **Witness**: Uses `DeterministicKolmogorovProductWitness` to assemble mediators via the projective-family extension; the oracle also records deterministic component checks performed with positivity-aware marginal diagnostics.
- **Tests**: `law.MarkovInfinite.spec.ts`
- **Examples**: Deterministic coin-flip mediators over independent Bernoulli coordinates certify unique factorisation, while non-deterministic components or perturbed mediators yield counterexamples with explicit cylinder sections.
- **Implementation Notes**: Reports reuse countability, measurability, and positivity metadata so downstream zero–one law tooling can consume the same diagnostics without recomputation.

### FinStoch infinite tensor obstruction

- **Domain**: Families of finite stochastic objects (`Fin`) indexed by a countable set inside the `FinStoch` Markov category.
- **Statement**: When no factor is empty and infinitely many factors have at least two elements, the FinStoch infinite tensor object fails to exist (Example 3.7).
- **Rationale**: Highlights the categorical limitation that prevents building path-space style objects inside FinStoch, motivating richer categories such as `BorelStoch` for infinite products.
- **Oracle**: `analyzeFinStochInfiniteTensor(index, carrier, options)` → `{ status, details, inspected, sampleLimit, exhausted, truncated, emptyFactors, multiValuedFactors, multiValuedCount, countability }`.
- **Witness**: Not required; the oracle samples the enumeration, recording empty factors and multi-valued examples as constructive evidence.
- **Tests**: `law.MarkovInfinite.spec.ts`
- **Examples**: Alternating singleton and two-point factors trigger a `likelyObstructed` status, while finite index sets and empty factors report the appropriate `ok` or `obstructed` statuses.
- **Implementation Notes**: Sampling is capped (`options.sampleLimit`) to keep diagnostics finite; callers can tighten `options.threshold` to demand more evidence before reporting the Example 3.7 obstruction.

### Kolmogorov extension witnesses for projective families

- **Domain**: Projective families in Markov categories that supply an extension operator turning finite cylinder sections into elements of the limit carrier.
- **Statement**: The Kolmogorov extension measure obtained from any finite subfamily reproduces every tested marginal, providing the “probability measures are consistent families” bijection stated in Remark 3.5.
- **Rationale**: Bridges the semicartesian definition with the probabilistic interpretation by packaging the Kolmogorov extension theorem as an executable universal property.
- **Oracle**: `checkKolmogorovExtensionUniversalProperty(obj, subsets)` → `{ ok, baseSubset, measure, reductions }`.
- **Witness**: Reuses the projective family’s marginals together with its extension adapter; no additional user-supplied witness is required.
- **Tests**: `law.MarkovInfinite.spec.ts`
- **Examples**: IID Bernoulli product families extend their one- and two-dimensional marginals to a global measure whose projections match the originals.
- **Implementation Notes**: Aggregates subsets into a controlling finite index so the constructed measure only depends on marginals that the caller requests.

### Tail independence for Kolmogorov products

- **Domain**: Kolmogorov product objects equipped with a global measure and deterministic tail-event predicates valued in booleans.
- **Statement**: Every tested tail event is independent from the σ-algebra generated by any chosen finite coordinate subset; concretely \(\mathbb{P}(E \wedge C) = \mathbb{P}(E)\mathbb{P}(C)\) for all sampled cylinder events \(C\).
- **Rationale**: Encodes the classic result that tail σ-algebras are independent of finite marginals, packaging it as an executable diagnostic feeding the zero–one law story.
- **Oracle**: `checkTailSigmaIndependence(obj, measure, tailEvent, subsets)` → `{ ok, tailProbability, subsets }` with per-subset factorizations and counterexamples.
- **Witness**: The oracle tabulates each cylinder section’s probability, the joint mass with the tail event, and the expected product; discrepancies surface explicit independence failures.
- **Tests**: `law.MarkovInfinite.spec.ts`
- **Examples**: Independent Bernoulli paths where tail events depending on later coordinates factor from early cylinders, while events tied to the head coordinate violate independence.
- **Implementation Notes**: Reuses countability and measurability metadata threaded through `InfObj`, so diagnostics still report when foundational hypotheses are absent.

### Kolmogorov zero-one law

- **Domain**: Kolmogorov product objects with a chosen measure, deterministic tail predicate, and conditional-independence witnesses relating the product mediator to the tail event.
- **Statement**: When the tail event is independent of every tested finite marginal and the determinism lemma hypotheses hold, the composite \(s \circ p\) becomes deterministic, so the tail event has probability 0 or 1.
- **Rationale**: Encodes the categorical zero–one principle as an executable report combining conditional independence, tail independence, and deterministic mediator diagnostics.
- **Oracle**: `checkKolmogorovZeroOneLaw(witness, options)` → `{ ok, zeroOne, tail, independence, tailConditional, determinism, universal }`.
- **Witness**: `KolmogorovZeroOneLawWitness` packages the deterministic Kolmogorov product, domain comonoid data, determinism-lemma witness, optional conditional-independence witnesses, and the tail predicate.
- **Tests**: `law.MarkovInfinite.spec.ts`
- **Implementation Notes**: Aggregates optional deterministic-product data so universal-property checks can be reused when provided.

### Hewitt–Savage zero-one law

- **Domain**: Kolmogorov zero–one witnesses paired with permutation actions exhibiting exchangeability of the chosen measure.
- **Statement**: If the underlying measure is exchangeable for the supplied finite permutations and the Kolmogorov zero–one diagnostics succeed, the tail event remains deterministic, mirroring the classical Hewitt–Savage conclusion.
- **Rationale**: Elevates the Hewitt–Savage zero–one law to an oracle that simultaneously checks exchangeability, permutation invariance of the tail event, and the Kolmogorov zero–one hypotheses.
- **Oracle**: `checkHewittSavageZeroOneLaw(witness, options)` → `{ ok, exchangeability, zeroOne, tail, determinism, … }`.
- **Witness**: `HewittSavageZeroOneLawWitness` extends the Kolmogorov witness with a permutation family, enabling reusable exchangeability diagnostics.
- **Tests**: `law.MarkovInfinite.spec.ts`
- **Implementation Notes**: Reuses the exchangeability witness from `hewittSavageZeroOneWitness` so permutation diagnostics stay consistent across oracles.

### Set-based multivalued morphisms and products

- **Domain**: The SetMult category of sets with multi-valued morphisms equipped with copy/discard structure and indexed products.
- **Statement**: Copy and discard maps satisfy the semicartesian comonoid laws on every sampled object; the cartesian product of a SetMult family projects to each finite coordinate subset; and a SetMult morphism is deterministic precisely when every fibre is singleton.
- **Rationale**: Implements the paper’s Set-based multi-valued morphisms so infinite products and determinism checks are executable alongside the Markov infrastructure.
- **Oracles**: `checkSetMultComonoid(obj, samples)`; `checkSetMultInfiniteProduct(family, assignment, tests)`; `checkSetMultDeterminism(witness)` and the lightweight `checkSetMultDeterministic(witness, samples)`.
- **Witness**: `buildSetMultDeterminismWitness(domain, codomain, morphism)` packages finite carriers with their SetMult morphisms for deterministic comparisons.
- **Tests**: `law.SetMult.spec.ts`
- **Examples**: Boolean carriers with copy/discard; deterministic indicator functions; finite Boolean products whose projections recover the original tuple.
- **Implementation Notes**: Determinism reports cross-check SetMult fibres against optional finite Markov kernels, providing explicit counterexamples when supports disagree.

### Sets with total functions

- **Objects:** all sets drawn from our working universe.
- **Morphisms:** total functions between those sets.
- **Identities/Composition:** usual identity maps and function composition.
- **In code:** `set-cat.ts` exposes `SetCat` with `obj`, `id`, `hom`, `compose`, and `isHom` helpers for small carriers.
- **Tests:** `test/set-cat.spec.ts` covers identity construction, composition, and codomain validation failures.

### Set basics via hom-set counts

- **Unique map from ∅:** `set.uniqueFromEmpty.check(set.uniqueFromEmpty.witness(Y))` confirms \(|\operatorname{Hom}(\emptyset, Y)| = 1\) for any sampled finite codomain.
- **Empty-set characterisation:** `set.emptyByHoms.check(set.emptyByHoms.witness(E, samples))` succeeds precisely when \(E\) is empty and no sampled nonempty set admits a morphism into \(E\).
- **Singleton characterisation:** `set.singletonByHoms.check(set.singletonByHoms.witness(S, samples))` verifies that \(S\) has a single point and every sampled domain maps to it uniquely.
- **Graph reminder:** Even identical graphs can correspond to different arrows because `SetHom` retains both domain and codomain; `test/set-laws.spec.ts` walks through the comparison.
- **Registry Path:** `set`

#### Elements as arrows

- Fixing a singleton object \(1\), elements of a set \(A\) correspond bijectively to arrows \(1 \to A\).
- **Oracle:** `set.elementsAsArrows.check(set.elementsAsArrows.witness(A))` compares \(|\operatorname{Hom}(1, A)|\) with \(|A|\) using the chosen singleton.

#### Concrete categories

- A category is **concrete** when a faithful functor into `Set` exhibits its objects as underlying sets with structure-preserving maps.
- Examples include familiar algebraic categories such as groups or preorders. Categories presented purely up to equivalence need not be concrete.

#### Mega-category of sets

- Our `SetCat` stands for a large ambient universe of sets and functions suitable for the surrounding development.
- Alternative foundations can reuse the same notation by interpreting “Set” as their chosen universe of things and maps.

### Relations on sets

- **Objects:** plain sets.
- **Morphisms:** relations \(R \subseteq A \times B\) treated as finite sets of pairs.
- **Intuition:** relations generalise partial or multi-valued functions; composition chains matching middle elements.
- **In code:** `rel.ts` exposes `Rel<A, B>`, constructors, identities, and `RelCat` helpers for small carriers.
- **Tests:** `test/rel-mat.spec.ts` exercises identity witnesses and relation composition.

### Matrices over the reals

- **Objects:** natural numbers representing finite-dimensional real vector spaces.
- **Morphisms:** real matrices of compatible shape, composed via matrix multiplication.
- **Intuition:** linear algebra packaged as a category with dimensions as objects and matrices as arrows.
- **In code:** `mat.ts` provides identity matrices, multiplication, and `MatCat` helpers with dimension checks.
- **Tests:** `test/rel-mat.spec.ts` multiplies sample matrices and validates identities.

### Graphs and the free category

- **Underlying graph:** `graph.ts` models directed multigraphs with labelled edges. Small categories expose their objects/morphisms as graphs when needed for visualisation.
- **Free category:** `freecat.ts` builds the path category on a graph; morphisms are finite edge sequences with identities as empty paths.
- **Helpers:** `arrows(graph)` lifts edges to length-1 paths, and `pathsFrom(node, maxLen)` enumerates short paths for examples.
- **Tests:** `test/graph-freecat.spec.ts` checks units, composition, and bounded path enumeration.

### Discrete dynamical systems

- **Objects**: pairs \((X, f)\) with \(X\) a set and \(f : X \to X\) an endofunction.
- **Morphisms**: functions \(j : X \to Y\) satisfying \(j \circ f = g \circ j\) between \((X, f)\) and \((Y, g)\).
- **Intuition**: morphisms transport the time evolution of one system into another while preserving the step-by-step dynamics.
- **In code**: `DynSys<X>` captures the carrier and step map, `DynHom<X, Y>` stores commuting maps, and `isDynHom` certifies the commutativity condition against the enumerated carriers.
- **Witness**: `test/dynsys.spec.ts` exercises identities, composition, and non-commuting counterexamples.

### Monoids as one-object categories

- **Objects**: a single point ★.
- **Morphisms**: elements of a monoid \((M, \cdot, e)\) acting as endomorphisms of ★.
- **Composition**: multiplies monoid elements, and the identity arrow corresponds to \(e\).
- **In code**: `MonoidCat(M)` produces the category façade with `hom`, `id`, and `compose` mirroring the monoid operations.
- **Witness**: `test/monoid-cat.spec.ts` checks identities and composition against the underlying monoid.
- **Conversely**: any category with a single object recovers a monoid by taking its endomorphisms with composition as the multiplication.

### Mon, the category of monoids

- **Objects**: monoids \((M, \cdot, e)\).
- **Morphisms**: monoid homomorphisms preserving \(e\) and multiplication.
- **Identities/Composition**: ordinary identity and composition of the underlying functions.
- **In code**: `mon-cat.ts` exposes `MonCat` and `isMonoidHom` for constructing and validating morphisms.
- **Witness**: `test/mon-cat.spec.ts` exercises identities, composition, and failure cases.

### Preorders as thin categories

- A preorder `(P,≤)` determines a category with the elements of `P` as objects and at most one morphism between any pair.
- An arrow `x → y` exists exactly when `x ≤ y`; reflexivity and transitivity provide identities and composition.
- **In code**: `PreorderCat({ elems, le })` constructs the thin category façade. For posets, choose an antisymmetric `le`.
- **Witness**: `test/preorder-cat.spec.ts` exercises arrow existence and transitive composition.
- **Conversely**: every category with at most one arrow between any two objects determines a preorder by declaring `x ≤ y` precisely when an arrow `x → y` exists.

### Discrete and ordinal categories

- **Discrete categories**: given a set of objects, include only identity arrows. `DiscreteCategory.create` in `allTS.ts` realises this construction and underpins the discrete diagram utilities and Kan extension helpers.
- **Ordinal skeletons**: finite ordinals viewed as chains yield the sparsest non-discrete examples (`FinOrd` models them explicitly). Category "1" has a single object and only its identity; category "2" adds one non-identity arrow alongside the two identities; larger ordinals continue the pattern.
- **Empty case**: the empty set produces the initial example of a discrete category—no objects and no arrows—already supported by the discrete helpers.

### Slice and coslice categories

- **Slice `C/X`**: objects are arrows `f : A → X`; morphisms are mediating arrows `h : A → B` satisfying `g ∘ h = f`. Use `makeSlice(base, anchor)` to build the anchored view of a finite category.
- **Coslice `X\C`**: objects are arrows `f : X → A`; morphisms are mediating arrows `h : A → B` with `h ∘ f = g`. Use `makeCoslice(base, anchor)` for the dual “fan-out” perspective.
- **Finite categories**: `finite-cat.ts` defines the `FiniteCategory` interface, capturing explicit object and arrow listings alongside composition and equality checks needed for slicing.
- **Examples**: `examples/slice-coslice-demo.ts` prints the slice and coslice of a toy “tasks anchored to projects” category. `test/slice-cat.spec.ts` validates object enumeration and the commuting-square condition for both constructions.
- **Slice axioms**: `checkSliceCategoryLaws(base, anchor)` traverses every object and mediating arrow produced by `makeSlice` to confirm identity/unit laws and associativity hold on-the-nose. It returns a structured report with offending triples when they fail.
- **Tests**: `test/slice-laws.spec.ts` exercises the checker on the task/user/project example and a deliberately corrupted base composition to show failures are detected.

#### Strict slice and coslice arrows

- Use `makeSliceTripleArrow` / `makeCosliceTripleArrow` when you need the commuting triangles explicitly. They carry the mediating map together with both anchor legs so diagnostics can quote the precise witnesses that make the triangles commute.
- `composeSliceTripleArrows` and `composeCosliceTripleArrows` validate pasted triangles before returning a result, preventing silent failures in complex constructions. `sliceArrowToTriple` and `cosliceArrowToTriple` upgrade the thin encodings from `makeSlice`/`makeCoslice` when witnesses are required.
- `test/slice-triple.spec.ts` and `test/coslice-triple.spec.ts` check the identity/composition behaviour and the thin/triple round-trips on the running task/user/project example.

#### Coslice precomposition and pushout reindexing

- `makeCoslicePrecomposition(base, h, X, Z)` implements the always-defined functor \(h^{\ast} : Z\backslash C \to X\backslash C\) by precomposing coslice legs with `h : X → Z`.
- `makeFinitePushoutCalculator` mirrors the pullback searcher: given a finite category it locates pushout squares and the universal mediating map obtained from a commutative triangle. Supply a custom `PushoutCalculator` if you have a more efficient description.
- `makeCosliceReindexingFunctor(base, calculator, h, X, Z)` uses pushouts to form the dual reindexing functor \(h_! : X\backslash C \to Z\backslash C\). The helper transports both objects and arrows and relies on `coinduce` for the universal mediating square.
- `test/coslice-reindexing.spec.ts` demonstrates both constructions on the toy category, verifies the functorial laws, and shows that failures surface with informative error messages.

### Reindexing slices along pullbacks

- Requires pullbacks in the ambient category. Supply them with `makeFinitePullbackCalculator(base)` or a custom `PullbackCalculator` implementation.
- `makeReindexingFunctor(base, calculator, h, X, Z)` reindexes the slice over `Z` along `h : X → Z` by taking pullbacks on objects and mediating maps. The helper returns object and arrow actions directly.
- `checkReindexIdentityLaw` and `checkReindexCompositionLaw` offer quick sanity checks on finite samples, and `sampleSlice` gathers representative objects and arrows from `makeSlice`.
- `test/reindexing.spec.ts` demonstrates the construction on a finite toy category and verifies the on-the-nose identity and composition laws.

### Preord, the category of preorders

- **Objects**: preordered collections `(P,≤)`.
- **Morphisms**: monotone maps preserving the preorder relation.
- **Identities/Composition**: ordinary identity and composition of functions; monotone maps compose.
- **In code**: `preord-cat.ts` defines `PreordCat` and `isMonotone` to build and certify monotone morphisms.
- **Witness**: `test/preord-cat.spec.ts` validates accepted morphisms and rejects non-monotone maps.

### Monoid Laws
For any monoid `(M, ⊕, ε)`:

**Associativity**: `(a ⊕ b) ⊕ c = a ⊕ (b ⊕ c)`
**Identity**: `ε ⊕ a = a = a ⊕ ε`

**Witness**: Property test with random `a, b, c ∈ M`

### Functor Laws
For any functor `F`:

**Identity**: `map(id) = id`
**Composition**: `map(f ∘ g) = map(f) ∘ map(g)`

**Witness**: Property test with random functions `f, g` and random `fa ∈ F[A]`

### Applicative Laws
For any applicative `F`:

**Identity**: `pure(id) <*> v = v`
**Composition**: `pure(∘) <*> u <*> v <*> w = u <*> (v <*> w)`
**Homomorphism**: `pure(f) <*> pure(x) = pure(f(x))`
**Interchange**: `u <*> pure(y) = pure(λf.f(y)) <*> u`

**Witness**: Property test with random `f, x, y` and random `u ∈ F[A → B], v ∈ F[A]`

### Monad Laws
For any monad `M`:

**Left Identity**: `return(a) >>= f = f(a)`
**Right Identity**: `m >>= return = m`
**Associativity**: `(m >>= f) >>= g = m >>= (λx.f(x) >>= g)`

**Witness**: Property test with random `a, f, g` and random `m ∈ M[A]`

## Arrow Laws

### Arrow category

- `makeArrowCategory(base)` builds the arrow category \(C^{\rightarrow}\) of commutative squares. Objects are arrows of `base`; morphisms are pairs `(j, k)` that make the square commute. Identity and composition are validated against the base category.
- `makeArrowDomainFunctor` and `makeArrowCodomainFunctor` expose the canonical domain/codomain projections \(C^{\rightarrow} \to C\). `test/arrow-category.spec.ts` checks the category laws and confirms the functors preserve identity and composition on representative squares.
- In Set-like settings this realises the “two-stage variable set” intuition: an object `u_X : X_0 → X_1` evolves data from stage 0 to stage 1, and a morphism `(j, k)` transports both stages coherently.

### Category Laws
For any category `C`:

**Left Identity**: `id ∘ f = f`
**Right Identity**: `f ∘ id = f`
**Associativity**: `(f ∘ g) ∘ h = f ∘ (g ∘ h)`

**Witness**: Property test with random arrows `f, g, h`

### Arrow Laws
For any arrow `A`:

**Arrow Identity**: `arr(id) = id`
**Arrow Composition**: `arr(f ∘ g) = arr(f) ∘ arr(g)`
**Arrow Extension**: `first(arr(f)) = arr(f × id)`
**Arrow Exchange**: `first(f ∘ g) = first(f) ∘ first(g)`
**Arrow Unit**: `first(f) ∘ arr(λx.(x, ⊥)) = arr(λx.(f(x), ⊥))`
**Arrow Association**: `first(first(f)) ∘ arr(λx.((x, y), z)) = arr(λx.(x, (y, z))) ∘ first(f)`

**Witness**: Property test with random functions `f, g` and random arrows

### ArrowChoice Laws
For any ArrowChoice `A`:

**Left Identity**: `left(arr(f)) = arr(left(f))`
**Left Exchange**: `left(f ∘ g) = left(f) ∘ left(g)`
**Right Identity**: `right(arr(f)) = arr(right(f))`
**Right Exchange**: `right(f ∘ g) = right(f) ∘ right(g)`

**Witness**: Property test with random functions `f, g` and Either-like values

### ArrowLoop Laws
For any ArrowLoop `A`:

**Right-Tightening**: `loop(σ) ∘ arr(g) = loop(σ ∘ arr(g × id))`
**Loop Identity**: `loop(arr(λ(x,y).(y,x))) = id` (when well-defined)

**Witness**: Property test with random functions and loop bodies

### Profunctor Laws
For any profunctor `P`:

**Identity**: `dimap(id, id) = id`
**Composition**: `dimap(f ∘ g, h ∘ i) = dimap(g, h) ∘ dimap(f, i)`

**Witness**: Property test with random functions `f, g, h, i`

### Strong Laws
For any strong profunctor `P`:

**Naturality**: `first(f) ∘ dimap(g, h) = dimap(g, h) ∘ first(f)`
**Associativity**: `first(first(f)) ∘ assoc = assoc ∘ first(f)`
**Unitality**: `first(f) ∘ unitor = unitor ∘ f`

**Witness**: Property test with random functions and arrows

### ArrowApply Laws
For any ArrowApply `A`:

**Apply Identity**: `app ∘ arr(λx.(x, id)) = id`
**Apply Composition**: `app ∘ first(app) ∘ assoc = app ∘ arr(λx.(x, f ∘ g))`

**Witness**: Property test with random arrows `f, g`

## Kleisli Arrow Laws

### Kleisli Category Laws
For any monad `M`, the Kleisli category `Kl(M)` satisfies:

**Left Identity**: `return >=> f = f`
**Right Identity**: `f >=> return = f`
**Associativity**: `(f >=> g) >=> h = f >=> (g >=> h)`

**Witness**: Property test with random Kleisli arrows `f, g, h`

### Kleisli Arrow Laws
For Kleisli arrows `A → M[B]`:

**Arrow Identity**: `arr(id) = return`
**Arrow Composition**: `arr(f ∘ g) = arr(f) >=> arr(g)`
**Arrow Extension**: `first(f) = λ(x, y).f(x) >>= λa.return(a, y)`

**Witness**: Property test with random functions and Kleisli arrows

## State Laws

### State Monad Laws
For `State[S, A] = S → (A, S)`:

**Left Identity**: `put(s) >> get = put(s) >> return(s)`
**Right Identity**: `get >>= put = return(())`
**Put-Put**: `put(s) >> put(s') = put(s')`
**Get-Put**: `get >>= put = return(())`

**Witness**: Property test with random states `s, s'`

## Reader Laws

### Reader Monad Laws
For `Reader[R, A] = R → A`:

**Ask Identity**: `ask >>= return = return(())`
**Local Identity**: `local(id) = id`
**Local Composition**: `local(f) ∘ local(g) = local(f ∘ g)`
**Local Ask**: `local(f) ∘ ask = ask >>= return ∘ f`

**Witness**: Property test with random functions `f, g` and random environments

## Result/Validation Laws

### Result Monad Laws
For `Result[E, A]`:

**Left Identity**: `Ok(a) >>= f = f(a)`
**Right Identity**: `r >>= Ok = r`
**Associativity**: `(r >>= f) >>= g = r >>= (λx.f(x) >>= g)`
**Error Propagation**: `Err(e) >>= f = Err(e)`

**Witness**: Property test with random `a, f, g` and random results

### Validation Applicative Laws
For `Validation[E, A]`:

**Accumulation**: `Err(e1) <*> Err(e2) = Err(e1 ++ e2)`
**Success**: `Ok(f) <*> Ok(a) = Ok(f(a))`
**Mixed**: `Ok(f) <*> Err(e) = Err(e) = Err(e) <*> Ok(a)`

**Witness**: Property test with random errors and values

## Streaming/Iteration Laws

### Stream Fusion Laws
For streams `Stream[A]`:

**Map Fusion**: `map(f) ∘ map(g) = map(f ∘ g)`
**Filter Fusion**: `filter(p) ∘ filter(q) = filter(λx.p(x) ∧ q(x))`
**Map-Filter Commute**: `map(f) ∘ filter(p) = filter(p) ∘ map(f)` (when `f` is total)

**Witness**: Property test with random functions and predicates

### Fold Laws
For folds `Fold[A, B]`:

**Associativity**: `fold(f, z, xs ++ ys) = fold(f, fold(f, z, xs), ys)`
**Identity**: `fold(f, z, []) = z`
**Homomorphism**: `fold(f, z, map(g, xs)) = fold(f ∘ g, z, xs)`

**Witness**: Property test with random functions and lists

## Parallel/Concurrent Laws

### Parallel Applicative Laws
For parallel execution `Par[A]`:

**Commutativity**: `par(f, g) = par(g, f)` (when both succeed)
**Associativity**: `par(par(f, g), h) = par(f, par(g, h))`
**Identity**: `par(f, pure(id)) = f`

**Witness**: Property test with random parallel computations

### Concurrent Monad Laws
For concurrent execution `Concurrent[A]`:

**Race Identity**: `race(f, never) = f`
**Race Commutativity**: `race(f, g) = race(g, f)`
**Timeout Identity**: `timeout(∞, f) = f`

**Witness**: Property test with random concurrent computations

## Optimization Laws

### Fusion Laws
For any composable operations:

**Map Fusion**: `map(f) ∘ map(g) = map(f ∘ g)`
**Filter Fusion**: `filter(p) ∘ filter(q) = filter(λx.p(x) ∧ q(x))`
**Fold Fusion**: `fold(f, z) ∘ map(g) = fold(λx y.f(g(x), y), z)`

**Witness**: Property test ensuring semantic equivalence

### Commutation Laws
For operations that can be reordered:

**Map-Filter Commute**: `map(f) ∘ filter(p) = filter(p) ∘ map(f)` (when `f` is total)
**Filter-Filter Commute**: `filter(p) ∘ filter(q) = filter(q) ∘ filter(p)`

**Witness**: Property test with random functions and predicates

## Witness Implementation

Each law should have a corresponding property test that:

1. **Generates random inputs** of the appropriate types
2. **Applies both sides** of the law equation
3. **Compares results** for equality (or equivalence)
4. **Reports counterexamples** if the law fails
5. **Captures minimal reproducers** for debugging

### Example Witness Template

```typescript
export const witnessFunctorIdentity = <A>(
  genA: () => A,
  genFA: () => F<A>
): PropertyTest => ({
  name: "Functor Identity Law",
  test: () => {
    const fa = genFA()
    const left = map(id)(fa)
    const right = fa
    return equals(left, right)
  },
  shrink: (counterexample) => shrinkFA(counterexample)
})
```

## Law Verification

All laws should be verified with:
- **Property-based testing** using random generators
- **Edge case testing** with boundary values
- **Performance testing** to ensure laws don't introduce inefficiencies
- **Documentation** explaining when laws might not hold (e.g., floating-point precision)

## Recursion Scheme Laws

### Catamorphism Laws
For `cataArray<A, B>(nil, cons)`:

**Identity**: `cataArray(nil, cons)([]) = nil`
**Consistency**: `cataArray(nil, cons)([a, ...as]) = cons(a, cataArray(nil, cons)(as))`
**Fusion**: `cataArray(nil, cons) ∘ map(f) = cataArray(nil, λa b.cons(f(a), b))`

**Witness**: Property test with random `nil, cons, f` and random arrays

### Anamorphism Laws
For `anaArray<A, S>(step)`:

**Termination**: `anaArray(step)(s)` terminates when `step(s) = None`
**Consistency**: `anaArray(step)(s) = [a, ...anaArray(step)(s')]` when `step(s) = Some([a, s'])`
**Coalgebra Fusion**: `anaArray(step ∘ f) = anaArray(step) ∘ f`

**Witness**: Property test with random `step, f` and random seeds

### Hylomorphism Laws
For `hyloArray<A, S, B>(step, alg, nil)`:

**Efficiency**: `hyloArray(step, alg, nil)(s) = cataArray(nil, alg)(anaArray(step)(s))`
**Fusion**: `hyloArray(step, alg, nil) ∘ f = hyloArray(step ∘ f, alg, nil)`
**Algebra Fusion**: `f ∘ hyloArray(step, alg, nil) = hyloArray(step, λa b.f(alg(a, b)), f(nil))`

**Witness**: Property test ensuring semantic equivalence without intermediate structures

### Paramorphism Laws
For `paraArray<A, B>(nil, cons)`:

**Identity**: `paraArray(nil, cons)([]) = nil`
**Consistency**: `paraArray(nil, cons)([a, ...as]) = cons(a, as, paraArray(nil, cons)(as))`
**Tail Access**: `paraArray(nil, cons)` provides access to unprocessed tail

**Witness**: Property test with random `nil, cons` and random arrays

### Apomorphism Laws
For `apoArray<A, S>(step)`:

**Embedding**: `apoArray(step)(s) = [...prefix, ...tail]` when `step(s) = Err(tail)`
**Continuation**: `apoArray(step)(s) = [a, ...apoArray(step)(s')]` when `step(s) = Ok([a, s'])`
**Coalgebra Fusion**: `apoArray(step ∘ f) = apoArray(step) ∘ f`

**Witness**: Property test with random `step, f` and random seeds

### Endomorphism Monoid Laws
For `MonoidEndo<A>()`:

**Identity**: `empty ∘ f = f = f ∘ empty`
**Associativity**: `(f ∘ g) ∘ h = f ∘ (g ∘ h)`
**Composition**: `concat(f, g)(x) = g(f(x))`

**Witness**: Property test with random endomorphisms and random values

## Monoidal Functor Laws

### Monoidal Functor Laws
For any lax monoidal functor `F` on the category of types with tensor = product and unit = void:

**Functor Laws**:
- **Identity**: `F.map(id) = id`
- **Composition**: `F.map(g ∘ f) = F.map(g) ∘ F.map(f)`

**Unit Coherence**:
- **Left Unit**: `F.map(λ.from) = a => F.tensor(F.unit, a)` where `λ: A ≅ [void, A]`
- **Right Unit**: `F.map(ρ.from) = a => F.tensor(a, F.unit)` where `ρ: A ≅ [A, void]`

**Associativity Coherence**:
- **Associator**: `F.map(α.from) ∘ F.tensor(F.tensor(a, b), c) = F.tensor(a, F.tensor(b, c))` where `α: [A, [B, C]] ≅ [[A, B], C]`

**Naturality of Tensor**:
- **Tensor Naturality**: `F.tensor(F.map(f)(a), F.map(g)(b)) = F.map(bimap(f, g))(F.tensor(a, b))`

**Witness**: Property test with random functions `f, g` and random values `a, b, c`

### Monoidal Functor Instances
The following instances satisfy the monoidal functor laws:

**Option Monoidal Functor**:
- **Unit**: `Some(undefined)`
- **Tensor**: `zipOption(fa, fb) = fa <*> fb.map(b => a => [a, b])`

**Result Monoidal Functor** (short-circuiting):
- **Unit**: `Ok(undefined)`
- **Tensor**: `zipResult(fa, fb) = fa <*> fb.map(b => a => [a, b])`

**Reader Monoidal Functor**:
- **Unit**: `Reader.of(undefined)`
- **Tensor**: `zipReader(fa, fb) = r => [fa(r), fb(r)]`

**ReaderTask Monoidal Functor**:
- **Unit**: `ReaderTask.of(undefined)`
- **Tensor**: `zipReaderTask(fa, fb) = r => Promise.all([fa(r), fb(r)])`

**ReaderTaskEither Monoidal Functor**:
- **Unit**: `RTE.of(undefined)`
- **Tensor**: `zipRTE(fa, fb) = r => Promise.all([fa(r), fb(r)]).then(([ra, rb]) => ra <*> rb.map(b => a => [a, b]))`

**Validation Monoidal Functor** (accumulating):
- **Unit**: `VOk(undefined)`
- **Tensor**: `zipValidation(fa, fb) = fa <*> fb.map(b => a => [a, b])` (accumulates errors)

**Witness**: Property test for each instance with random generators and equality functions

## 2-Functor Laws

### Strict 2-Functor Laws
For any strict 2-functor `U: C → D` between 2-categories:

**on2 respects vertical composition**: `U(β ∘v α) = U(β) ∘v U(α)`
**on2 respects horizontal composition**: `U(β ⋆ α) = U(β) ⋆ U(α)`
**on2 preserves identity**: `U(id_F) = id_{U(F)}`

**Witness**: Property test with random natural transformations and endofunctors

### Lax 2-Functor Laws
For any lax 2-functor `U: C → D`:

**μ, η are natural in their arguments**
**Unit Coherence**: 
- `(U(F) ∘ η) ; μ_{F,Id} = id_{U(F)}`
- `(η ∘ U(F)) ; μ_{Id,F} = id_{U(F)}`
**Associativity Coherence**: 
- `(μ_{F,G} ⋆ id_{U(H)}) ; μ_{F∘G,H} = (id_{U(F)} ⋆ μ_{G,H}) ; μ_{F,G∘H}`

**Witness**: Property test with random endofunctors and natural transformations

### Oplax 2-Functor Laws (Dual)
For any oplax 2-functor `U: C → D`:

**η^op, μ^op are natural in their arguments**
**Unit Coherence**: 
- `η^op ; (U(F) ∘ μ^op_{F,Id}) = id_{U(F)}`
- `η^op ; (μ^op_{Id,F} ∘ U(F)) = id_{U(F)}`
**Associativity Coherence**: 
- `μ^op_{F∘G,H} ; (μ^op_{F,G} ⋆ id_{U(H)}) = μ^op_{F,G∘H} ; (id_{U(F)} ⋆ μ^op_{G,H})`

**Witness**: Property test with random endofunctors and natural transformations

### Concrete Instances

#### PostcomposeReader2<R> (Lax)
- **on1**: `F ↦ Reader<R, F<_>>`
- **on2**: `α ↦ Reader<R, α>`
- **η**: `a ↦ (_) => a` (unit)
- **μ**: `Reader<R, F<Reader<R, G<_>>>> ↦ Reader<R, F<G<_>>>` (evaluate inner Reader at same environment)

#### PrecomposeEnv2<E> (Oplax)
- **on1**: `F ↦ F ∘ Env<E, _>`
- **on2**: `α ↦ α` (applied to Env<E, A>)
- **η^op**: `[e, a] ↦ a` (counit - drop environment)
- **μ^op**: `F<G<Env<E, A>>> ↦ Env<E, F<G<A>>>` (using strength to pull Env outward)

**Witness**: Property test for each instance with random endofunctors and natural transformations

## Indexed Family Laws

### Reindexing Functoriality
For reindexing operation `u*` along `u: J → I`:

**Identity**: `id* = id`
**Composition**: `(v ∘ u)* = u* ∘ v*`

**Witness**: Property test with random functions `u, v` and random families

### Dependent Sum/Product Adjunction
For families `X: I → Set`:

**Σ ⊣ u* ⊣ Π**: `Σu ⊣ u* ⊣ Πu`
**Triangle Identities**: 
- `u* ε ∘ η = id` on `u*Y`
- `ε ∘ u* η = id` on `ΣuX`

**Witness**: Property test with pullback squares and fiber computations

### Beck-Chevalley Law
For pullback square of index maps:

**Substitution Commutes**: `f* Σw ≅ Σu v*`

**Witness**: Property test comparing counts over pullback indices

### Kan Extension Laws
For discrete index maps `u: J → I`:

**Left Kan**: `(Lanu F)(i) = ⨁{j | u(j)=i} F(j)`
**Right Kan**: `(Ranu F)(i) = ∏{j | u(j)=i} F(j)`
**Naturality**: Kan extensions are natural in the family

**Witness**: Property test with fiber size comparisons

## Diagram Laws

### Diagram basics ↔ Code mapping

- **Representational diagram**: a labelled directed graph that pictures
  objects (nodes) and arrows (edges).
- **Diagram in a category**: the concrete selection of objects and morphisms
  inside a category matching that picture.
- **Paths and composites**: any composable chain of arrows yields a single
  composite arrow from its source to its target. Distinct paths between the
  same objects form a commutative diagram precisely when their composites
  agree.
- **Associativity and pasting**: triangles commute by definition of
  composition. Pasting commuting polygons along shared edges produces larger
  commuting diagrams.
- **Identity arrows**: each object has a neutral loop that leaves every arrow
  unchanged; repeated labels in a diagram always refer to the same object or
  morphism.

#### (§6.3) Revised commutativity (Def 20*)
A representational diagram commutes when any two directed paths X ⇒ Y—where at
least one path has length ≥ 2—have equal composites; parallel single-edge
arrows may differ, so forks can satisfy f ∘ e = g ∘ e without forcing f = g.

**In code:**

- `diagram.ts` provides `composePath`, `commutes`, `paste`, `allCommute`, `id`,
  and `isIdentity` for function-like arrows, plus `composeAbstract`,
  `commutesAbstract`, and `pasteAbstract` for abstract morphism data.
- `Diagram`/`DiagramClosure` in `allTS.ts` capture representational diagrams;
  `DiagramLaws` validates commutativity and limit-style constraints on those
  values. The suite `test/indexed-families.spec.ts` exercises these checks.

### Functoriality Laws
For diagrams `D: I → C`:

**Identity**: `D(id_i) = id_{D(i)}`
**Composition**: `D(g ∘ f) = D(g) ∘ D(f)`

**Witness**: Property test with `DiagramLaws.validateFunctoriality`

### Closure Laws
For diagram closure operations:

**Idempotence**: `saturate(saturate(D)) = saturate(D)`
**Preservation**: If `D` satisfies functoriality, so does `saturate(D)`

**Witness**: Property test with closure validation

## Markov Category Laws

### Faithfulness via monomorphisms

- **Domain**: Markov category with commutative semiring R
- **Statement**: ∇ is split mono ⇒ monic (Δ ∘ ∇ = id)
- **Rationale**: Establishes faithfulness of the distribution functor
- **Oracle**: `checkFaithfulness(R, samples, domain)` → `{splitMono: boolean, deltaMonic: boolean}`
- **Witness**: Split mono witness + δ monicity proof
- **Tests**: `law.PullbackCheck.spec.ts`

### Entirety implies representability

- **Domain**: Commutative semiring R with no zero divisors
- **Statement**: If R is entire, then the relevant pullback square always holds
- **Rationale**: Connects algebraic properties to categorical representability
- **Oracle**: `checkEntirety(R, domain, f, g)` → `boolean`
- **Witness**: Pullback square verification for entire semirings
- **Tests**: `law.EntiretyCheck.spec.ts`

### Pullback square uniqueness

- **Domain**: Deterministic morphisms f: A→X, g: A→Y in Markov category
- **Statement**: Only joint with Dirac marginals is the Dirac pair
- **Rationale**: Core representability property for Markov categories
- **Oracle**: `checkPullbackSquare(R, Avals, f, g, candidates?)` → `boolean`
- **Witness**: Counterexample detection for exotic semirings
- **Tests**: `law.PullbackSquare.spec.ts`

### Thunkability ⇔ determinism

- **Domain**: Kleisli morphisms f: A → P(B) in Markov category
- **Statement**: f is thunkable ⇔ f is deterministic (factors through δ)
- **Rationale**: Characterizes when morphisms respect the monoidal structure
- **Oracle**: `isThunkable(R, f, samples, probes)` → `{thunkable: boolean, base?: Function}`
- **Witness**: Extracted base function for deterministic morphisms
- **Tests**: `law.MarkovThunkable.spec.ts`

### Monoidal structure

- **Domain**: Symmetric monoidal Markov category
- **Statement**: δ and sampling are monoidal; strength is natural in second argument
- **Rationale**: Ensures independence properties work correctly
- **Oracle**: `checkAllMonoidalLaws(R, testData)` → `{diracMonoidal: boolean, strengthNaturality: boolean, ...}`
- **Witness**: Commuting diagrams for monoidal coherence
- **Tests**: `law.MarkovMonoidalSimple.spec.ts`

### Sampling cancellation

- **Domain**: Kleisli morphisms with sampling function in a.s.-compatible setting
- **Statement**: If samp∘f# = samp∘g# (a.s.), then f# = g# (a.s.)
- **Rationale**: Characterizes when sampling determines distributional equality
- **Oracle**: `samplingCancellation(R, Avals, f, g, samp, nullMask?)` → `boolean`
- **Witness**: Counterexample (Ghost semiring) where cancellation fails
- **Tests**: `law.ASEquality.spec.ts`, `law.GhostCounterexample.spec.ts`

### Ghost semiring counterexample

- **Domain**: Ghost semiring Rε = {0, ε, 1}
- **Statement**: Representable but not a.s.-compatible (f# ≠ g# but samp∘f# = samp∘g#)
- **Rationale**: Demonstrates limits of representability theory
- **Oracle**: `samplingCancellation(GhostRig, ...)` → `false` (counterexample)
- **Witness**: Concrete distributions differing by ε-weights
- **Tests**: `law.GhostCounterexample.spec.ts`

## Dominance Theory Laws

### SOSD via Dilation Witnesses

- **Domain**: Distributions with evaluation function e: P(A) → A
- **Statement**: p ⪯_SOSD q ⇔ ∃ dilation t: q = t#(p) ∧ e∘t = id
- **Rationale**: Characterizes second-order stochastic dominance constructively
- **Oracle**: `sosdFromWitness(R, p, q, e, t, samples, direction)` → `boolean`
- **Witness**: Mean-preserving dilation witnessing the dominance
- **Tests**: `law.SOSD.spec.ts`

### Dilation Validation

- **Domain**: Kernels t: A → P(A) with evaluation function e
- **Statement**: t is a dilation ⇔ e∘t = id (mean-preserving property)
- **Rationale**: Validates mean-preserving spread transformations
- **Oracle**: `isDilation(R, t, e, samples)` → `boolean`
- **Witness**: Verification that evaluation is preserved
- **Tests**: `law.SOSD.spec.ts`

## Information Theory Laws

### Blackwell Sufficiency (Informativeness)

- **Domain**: Experiments f, g: Θ → P(X), P(Y) with prior m
- **Statement**: f is more informative than g ⇔ ∃ garbling c: f = c∘g
- **Rationale**: Characterizes when one experiment provides more information
- **Oracle**: `moreInformativeClassic(R, Θvals, f, g, candidates)` → `{ok: boolean, c?: Function}`
- **Witness**: Garbling function c witnessing the information ordering
- **Tests**: `law.Garbling.spec.ts`

### Standard Experiments

- **Domain**: Prior m: P(Θ) and experiment f: Θ → P(X)
- **Statement**: Standard measure f̂_m distributes over posterior distributions
- **Rationale**: Canonical representation for Bayesian decision theory
- **Oracle**: `standardMeasure(m, f, xVals)` → `StandardMeasure<Θ>`
- **Witness**: Distribution over posterior distributions
- **Tests**: `law.StandardExperiment.spec.ts`

### BSS Equivalence

- **Domain**: Experiments f, g with prior m
- **Statement**: f ⪰ g ⟺ f̂_m ⪯_SOSD ĝ_m (informativeness ⇔ SOSD on standard measures)
- **Rationale**: Connects all three characterizations of informativeness
- **Oracle**: `bssCompare(m, f, g, xVals, yVals)` → `boolean`
- **Witness**: Equivalence of garbling, joint, and SOSD characterizations
- **Tests**: `law.BSS.spec.ts`

## Oracle Coverage Summary

| Domain | Laws Covered | Oracles Implemented | Tests |
|--------|--------------|-------------------|-------|
| **Foundational** | Faithfulness, entirety, pullbacks, thunkability, monoidal coherence, sampling cancellation | 15+ | 139 |
| **Dominance** | SOSD, dilations | 5+ | 25 |
| **Information** | Blackwell sufficiency, BSS equivalence | 8+ | 47 |
| **Counterexamples** | Ghost semiring | 3+ | 10 |
| **Infrastructure** | Semirings, distributions | 10+ | 23 |

**Total**: 41+ oracles, 244 tests, complete coverage of advanced probability theory

## Future Extensions

This document should grow to include:
- **Lens laws** (get-put, put-get, put-put)
- **Prism laws** (preview-review, review-preview)
- **Traversal laws** (traversal composition, traversal identity)
- **Comonad laws** (extract, duplicate, extend)
- **Distributive laws** (distributivity over products/coproducts)
- **Monad transformer laws** (lift laws, transformer composition)
- **Infinite-dimensional laws** (Kolmogorov extension, zero-one laws)
- **Ergodic theory laws** (invariant σ-algebras, ergodic decomposition)
