# NEW_PLAN

## Milestone 1 – Stabilize arithmetic primitives for natural numbers
Before attempting any Grothendieck-style integer completion, carve out a reusable `naturalNumbersAddition` helper beside `naturalNumbersPrimitiveRecursion` in `stdlib/category-limits.ts`, along with a thin type-level witness object so downstream code can obtain the canonical addition map without re-creating the recursion boilerplate. Once the helper exists, retrofit the FinSet natural numbers tests to depend on it—this both exercises the helper in a concrete category and locks in backwards-compatible behavior before more constructions reuse it. Where existing proofs appeal directly to primitive recursion, update them to import the helper while keeping the recursive witness exposed for future multiplicative or exponential structure.

- [x] Extract the helper in `stdlib/category-limits.ts`, modeling its signature on `naturalNumbersPrimitiveRecursion` while defaulting the base and step data.
- [x] Add a `NaturalNumbersAdditionWitness` (or similarly named) export so downstream modules can import both the morphism and its recursion provenance.
- [x] Rewrite the FinSet natural-number tests and examples to use the helper, ensuring law proofs continue to pass and documenting any deviations.
- [x] Sweep for direct primitive-recursion references elsewhere in the repository and migrate them to the helper when they encode plain addition.

## Milestone 2 – Package existing FinSet structure as an elementary topos witness
Collect the currently scattered FinSet capabilities—finite limits, cartesian closure, subobject classifier, and natural numbers object—into a single `ElementaryToposWitness` interface that advertises each universal property with oracular witnesses. Implement the aggregator in the FinSet module by delegating to the existing constructors, and add smoke tests that confirm the witness packages the same data the current exports provide. This consolidation will make subsequent constructions (like integer completion or power object manipulations) demand a single capability object rather than a pile of ad-hoc parameters, better matching the categorical bookkeeping laid out in the text.

- [x] Define the `ElementaryToposWitness` interface with fields for finite limits, exponentials, subobject classifier, natural numbers object, and any existing oracles we already maintain.
- [x] Implement a builder in the FinSet module that assembles the witness from current exports without changing their signatures.
- [x] Author targeted smoke tests that unpack the witness and assert it matches the pre-existing exports, catching accidental drift.
- [x] Update documentation and call sites (examples, experiments) to import the consolidated witness instead of bespoke combinations where possible.

## Milestone 3 – Build the Grothendieck-style integer completion for natural numbers objects
With addition factored out and the FinSet topos witness assembled, implement an `integerCompletion` builder that, given a natural numbers object equipped with finite products and coequalizers, forms the parallel pair on \((N \times N) \times (N \times N)\) induced by “crossed” addition, equalizes it, and then quotients to obtain the universal arrow \(N \times N \to I\). In FinSet, wire this builder to the existing coequalizer machinery and ensure the resulting object satisfies the expected universal property via executable oracles. Document the resulting witness so other elementary topoi can adopt the same pattern.

- [x] Express the two “crossed” addition morphisms explicitly using the addition helper and product associators to remove ambiguity about evaluation order.
- [x] Construct the equalizer and resulting coequalizer witness with the existing `CategoryLimits` utilities, making the intermediate object reusable for diagnostics.
- [x] Specialize the builder to FinSet, delegating to the concrete coequalizer implementation and supplying regression tests that verify the universal property and addition embedding.
- [x] Provide documentation and type exports that make the construction discoverable for other categories satisfying the same hypotheses.

## Milestone 4 – Strengthen functor witnesses and law reporting
The newly reviewed material emphasizes that a functor consists of object- and arrow-level assignments that strictly respect identities and composition. Audit `functor.ts` and related helpers to ensure this perspective is reflected operationally: introduce a `FunctorWitness` type that pairs the raw `Functor` data with finite generating sets of objects and arrows, expose an oracle `isFunctor` that simultaneously checks endpoint, identity, and composition laws (folding the existing checks into one structured report), and thread this witness through modules such as `virtual-equipment/tight-primitives.ts`. Add regression tests on representative categories (FinSet, monoids as categories, etc.) so failures highlight which law broke, matching the textbook’s emphasis on coherence over mere data assignment.

- [x] Stabilize a `FunctorWitness` interface that carries the functor data, generating sets, and structured metadata for law verification.
- [x] Implement the unified `isFunctor` oracle, refactoring existing ad-hoc checks to reuse the shared reporting pipeline.
- [x] Thread the witness through modules that currently accept raw functors, updating their type signatures and internal checks accordingly.
- [x] Expand the regression test suite to cover the representative categories and ensure the oracle reports which specific law fails when a counterexample is introduced.

## Milestone 5 – Systematize canonical identity, diagonal, forgetful, and constant functors
Section 26.3 reminds us that even “obvious” functors such as the identity functor \(1_C\) and the diagonal functor \(\Delta : C \to C^2\) deserve executable witnesses, because they participate in product/exponential adjunctions and pull constructional weight in later chapters. Expand our functor tooling to ship constructors for these canonical examples: the diagonal functor should bundle both object and arrow duplication along with proofs that projection composition recovers the original morphisms, while the product projections \(F_1, F_2 : C^2 \to C\) ought to be emitted with explicit naturality checks. In parallel, extend the forgetful-functor initiative (e.g., `FinSet/I_n → FinSet`, `Grp → Set`, `Ring → Set`, `Grp → Mon`) so each builder advertises which structure is discarded and reuses the strengthened witnesses from Milestone 4. Finally, generalize the constant-object functor `Δ_X` for slice and coslice categories so its law witnesses document how identities and compositions collapse, and compose these with the new diagonal/projection helpers to mirror the commuting diagrams highlighted in the text.

- [x] Implement reusable constructors for identity, diagonal, and projection functors that return both the functor and its strengthened witness.
- [x] Catalogue existing forgetful functor helpers, upgrade them to the new witness style, and add missing ones called out in the text.
- [x] Extend the constant-object functor builders for slice and coslice contexts, making their collapse-on-arrows behavior explicit in witnesses and documentation.
- [x] Cross-link the constructors so diagonal/projection composition identities appear directly in examples or regression tests, demonstrating the textbook commuting diagrams.

## Milestone 6 – Capture algebraic and order-theoretic actions as functors
Examples F11–F14 reinterpret classical algebraic data as functors: the list construction as an endofunctor `List : Set → Set`, monoid homomorphisms as functors between single-object categories, monotone maps as functors between poset categories, and group actions as functors into `Set`. Audit our category encyclopedia to ensure each of these interpretations is available with reusable constructors. For the list endofunctor, expose an interface that packages the familiar `map`, `unit`, and concatenation structure alongside the functoriality witness so later work can reuse it when forming free monoids. For monoids and posets, build adapters that turn a homomorphism or monotone map into a functor object plus an oracle that verifies the induced arrow function respects the ambient order or multiplication. For groups, surface a `groupActionAsFunctor` helper that records the underlying set together with the action law witnesses \(F(e)=\mathrm{id}\) and \(F(gm)=F(g) \circ F(m)\); supplement with regression tests that round-trip between the action formulation and existing action encodings, ensuring the codebase can fluidly swap between algebraic and categorical viewpoints.

- [x] Build or audit the list endofunctor constructor so it exposes `map`, `unit`, concatenation, and the strengthened functor witness for reuse in free-monoid contexts.
- [x] Provide adapters that turn monoid homomorphisms and monotone maps into functors, pairing them with oracles that certify multiplication and order preservation, respectively.
- [x] Implement `groupActionAsFunctor` with explicit witnesses for identity and composition laws, plus utilities that recover traditional action data from the functor form.
- [x] Add regression coverage that round-trips between algebraic definitions and the functor constructors to ensure bi-directional interoperability.

## Milestone 7 – Operationalize binary product and tensor functors from universal properties
Section 26.4 formalizes the functors that arise from binary products and tensor-like structure—specifically, the “product with \(C\)” functor \((- \times C) : C \to C\) on any category with all products, and the bifunctorial tensor \((- \otimes C) : C^2 \to C\) assembled from associativity and projection data. Translate these textbook proofs of functoriality into reusable builders that accept the universal property witnesses already surfaced in earlier milestones. Each builder should emit both the object/arrow level components and an oracle that confirms identities and compositions are preserved exactly as in the derivations: identities via Theorem 54/55 style reasoning, and compositions by unfolding the product/tensor definitions step by step. Package these alongside diagnostics that spell out the componentwise equations so failures point to the precise universal property that broke.

- [x] Introduce a `productWithObjectFunctor` helper that consumes binary product witnesses and returns the endofunctor \((- \times C)` with a strengthened functor witness mirroring the text’s verification of identity and composition preservation.
- [x] Extend the diagonal/projection suite to include a `tensorWithObject` (or similarly named) constructor for categories equipped with a tensor product, reusing associators and unitors to define the arrow component and certify its laws via executable traces of the textbook equalities.
- [x] Author focused regression tests that derive the relevant equations (e.g., \((f, g) \circ (f', g')\) expansions) and feed them to the new oracles so the automated checks replicate the reasoning in Section 26.4.
- [x] Document how these helpers interact with the canonical functors from Milestone 5, emphasizing compositional identities such as \(\otimes(f, g) = (f \otimes 1_C) \circ (1_C \otimes g)\) where appropriate.

## Milestone 8 – Exponentiation-by-object and evaluation functors in monoidal settings
The surrounding commentary highlights that once \(C\) is monoidal, tensoring with a fixed object and exponentiating by that object both act functorially, and that the induced evaluation morphisms must be tracked carefully to avoid conflating the distinct exponentials \((X^C, \mathrm{ev}_X)\) and \((Y^C, \mathrm{ev}_Y)\). Extend our roadmap to cover these constructions explicitly: given a monoidal category witness, surface builders for the currying functor \((-)^C : C \to C\) together with the canonical evaluation and coevaluation natural transformations, and coordinate them with the tensor-oriented helpers from Milestone 7. Ensure the resulting APIs expose the naturality squares that certify “keeping the two exponentials straight,” and encode the book’s proof obligations—such as the commutative outer rectangles whose unique fillers enforce \((g \circ f)^C = g^C \circ f^C\)—so downstream code can rely on the bookkeeping the text emphasizes.

- [x] Introduce an `exponentiateByObject` constructor that accepts a monoidal closed witness (or separate internal hom data) and returns the functor \((-)^C\) with the strengthened functor witness plus explicit evaluation maps, capturing the exponential transposition logic in reusable utilities.
- [x] Build adapters that package the evaluation morphisms as natural transformations, verifying the triangle identities that relate them to tensoring with \(C\) and to the diagonal/constant functors already planned, and emitting diagnostics mirroring diagrams (F17) and the associated outer-rectangle fillers.
- [x] Implement law oracles that confirm the exponential assignment respects identities and composition by constructing the comparison morphisms from the book (e.g., \(1_X^C = 1_{X^C}\), \((g \circ f)^C = g^C \circ f^C\)) and checking the commutative squares used in their proofs.
- [x] Audit existing constant and forgetful functor builders to thread through the evaluation data where the text warns about conflations, and add regression tests that check the distinct exponentials specialize correctly (e.g., comparisons of \(X^C\) versus \(Y^C\) within functor categories).
- [x] Document the interplay between tensoring, exponentiation, and evaluation in our examples and guides so later milestones (like integer completions inside monoidal topoi) can reuse the curated witnesses without re-deriving the coherence proofs, including diagrammatic annotations referencing the shared outer-rectangle argument.

## Milestone 9 – Natural transformation calculus and functor categories
Having fixed the functorial building blocks, the text pivots to the two-dimensional structure supplied by natural transformations and functor categories. Operationalize this layer by standardizing the data we attach to natural transformations—sources, targets, component morphisms, and naturality diagnostics—and by making vertical composition, whiskering, and horizontal composition executable with interchangeable witnesses. This milestone aligns our code with the book’s emphasis on the interchange law and on viewing \([C, D]\) as a category in its own right, ensuring our functorial constructions from Milestones 5–8 slot cleanly into this enriched setting.

- [x] Define a `NaturalTransformationWitness` that records component morphisms alongside naturality oracles, and retrofit existing helpers (e.g., evaluation and diagonal comparison maps) to produce the new witness format.
- [x] Implement vertical composition and whiskering constructors that emit updated witnesses and verify naturality by replaying the commutative squares from the textbook proofs, including descriptive failure diagnostics.
- [x] Add a horizontal composition builder that assembles the double-coset diagrams underlying the interchange law, producing oracles that certify \((\beta \ast \alpha) \circ (\delta \ast \gamma) = (\beta \circ \delta) \ast (\alpha \circ \gamma)\).
- [x] Expose a `functorCategory` constructor that accepts small categories \(C\) and \(D\) plus the strengthened functor and natural transformation witnesses, returning objects/arrows and executable identity/composition structure for \([C, D]\).
- [x] Create regression tests that cover canonical natural isomorphisms (currying/uncurrying, product projections, tensor-evaluation adjunctions) using the new witness APIs, keeping the plan synchronized with Milestones 7 and 8.

## Milestone 10 – Free monoid functor from Set to Mon and allied abelian variants
Section 26.5 constructs the exemplar functor \(F : \mathbf{Set} \to \mathbf{Mon}\) that freely adjoins monoid structure by mapping a set to the list monoid it generates and a function to its listwise action. Extend the roadmap to capture this free-monoid machinery in executable form: build a `freeMonoidFunctor` constructor that packages the list-based object assignment, the induced homomorphism on arrows, and an oracle certifying the functorial laws by replaying the book’s identity and composition arguments. Thread this builder through our algebraic adapters so that downstream categories can request either the raw functor or its universal property witnesses (unit and multiplication satisfying the free monoid adjunction). In parallel, note the text’s remark about variants to `Ab`; queue follow-up tasks to specialize the construction to free abelian monoids and to compare against existing abelianization helpers.

- [x] Define a `freeMonoidFunctor` helper that targets `Mon`, returning both the functor data and the strengthened witness from Milestone 4, while exporting the canonical unit/embedding maps used in the universal property.
- [x] Equip the helper with diagnostics that verify a set function lifts to a monoid homomorphism on lists, highlighting preservation of the empty list and concatenation as in the textbook proof that \(F\) is a functor.
- [x] Integrate the constructor with our list endofunctor tooling from Milestone 6 so the free monoid functor can delegate to shared list witnesses and expose the adjunction structure needed for later free/forgetful pairs.
- [x] Plan an extension path to `Set \to Ab` by enumerating the additional abelian relations that must be enforced (commutativity of concatenation) and by documenting how existing abelianization adapters can be reused once the monoid-level helper lands.

With the Set→Mon functor operational, the follow-up for `Set → Ab` will quotient the list monoid by the commutativity congruence, reuse the new unit/flatten hooks, and lean on existing abelianization adapters so the adjunction in Milestone 11 can be specialized without duplicating diagnostics.

## Milestone 11 – Free/forgetful adjunctions and induced monads/comonads
Section 26.6 crystallizes the relationship between free constructions and their corresponding forgetful functors via adjunctions, highlighting that the free monoid/list machinery yields a monad on `Set` and, dually, comonads when paired with cofree gadgets. Extend the roadmap to encode this structure explicitly: express the `freeMonoidFunctor` and the upgraded `forgetfulMonoidFunctor` from Milestone 5 as an adjoint pair, expose executable unit/counit witnesses, and package the induced monad so downstream code can reuse the Kleisli structure without reinventing the algebra. Mirror the book’s triangle-identity derivations in oracles, and set the stage for analogous adjunctions in other algebraic contexts (free Abelian monoids, free groups) once their functors land.

- [x] Implement a `buildAdjunction` helper for `Set ⊣ Mon` that takes the free and forgetful functors plus universal property witnesses, returning structured data for unit, counit, and triangle-identity diagnostics.
- [x] Derive the corresponding list monad by composing the adjunction witnesses, threading them through existing `List` tooling to expose Kleisli composition, multiplication, and law oracles driven by the triangle identities.
- [x] Provide regression tests that replay the Section 26.6 diagrams: verify the adjunction bijection between set maps and monoid homomorphisms, and ensure the unit/counit oracles pinpoint failures down to their component equations when sabotaged.
- [x] Document how the adjunction scaffold generalizes to other algebraic pairs (free Abelian monoid, free group), including checklists of the additional witnesses those variants will require once Milestone 10’s follow-ups complete.

## Milestone 12 – Contravariant functors and opposite-category infrastructure
Section 26.6’s introduction of contravariance underscores that reversing arrow direction is not a mere curiosity but a structural tool for dualizing constructions, particularly once we pass to the opposite category \(C^{op}\). Extend the plan to make contravariant functors first-class: furnish a `ContravariantFunctorWitness` that records the object map \(F : C \to D\) together with the reversed arrow assignment \(f : A \to B \mapsto Ff : FB \to FA\), and verify that identities and compositions are preserved after the reversal exactly as the definition stipulates. Build ergonomic adapters that turn an ordinary functor \(F : C^{op} \to D\) into the contravariant form and back again, and enrich our category tooling so `op` constructions deliver the data needed for these witnesses. Document and test canonical examples—including hom-functors, power objects, and dualizing involutions—to ensure the operationalization matches the textbook exposition.

- [x] Introduce a `ContravariantFunctor` type (or reuse the existing functor machinery parameterized over `C^{op}`) alongside a `contravariantFunctorWitness` helper that checks the flipped identity/composition laws and reports diagnostic diagrams when violations occur.
- [x] Operationalize Theorem 128 by providing explicit adapters `contravariantToOppFunctor` and `oppFunctorToContravariant` that shuttle between a contravariant assignment `F : C \to D` and the corresponding covariant functor `F^{op} : C^{op} \to D`, including regression tests that verify the round-trip is an isomorphism of witnesses.
- [x] Capture the textbook observation that \((C^{op})^{op} = C\) by extending the opposite-category infrastructure with an involutive oracle and diagnostics that replay the proof, and thread this through the functor converters so users can hop between variance choices without losing data.
- [x] Extend the category infrastructure with explicit `OppositeCategoryWitness` data so callers can request objects, arrows, identities, and composition in \(C^{op}\) without re-deriving the reversal mechanics; ensure this integrates with existing `dual-cat.ts` helpers.
- Provide constructors for canonical contravariant examples:
  - [x] `Hom(-, X)` on `C^{op}` with regression coverage illustrating the Hom-functor law checks.
  - [x] Dual vector space functors in the linear algebra adapters once the finite-dimensional infrastructure is upgraded.
  - [x] Power-object assignments in elementary topoi, mirroring the direct/inverse image pairing.
- [x] Update documentation and milestone cross-links so the new contravariant tooling interoperates with the functor-category plans (Milestone 9) and the tensor/exponential utilities (Milestones 7–8), clarifying how to shuttle between covariant and contravariant contexts when forming natural transformations or adjunction data.

## Milestone 13 – Covariant power-object and dual-space functors with contravariant companions
Examples F19 and F20 highlight that the powerset assignment \(\mathcal{P} : \mathbf{Set} \to \mathbf{Set}\) and the dual-space assignment \((-)^* : \mathbf{FVect}_k^{fd} \to \mathbf{FVect}_k^{fd}\) deliver rich functorial structure whose contravariant behavior is best understood through their opposite-category viewpoints. Expand the roadmap to encode both the covariant and contravariant faces of these constructions: for sets, provide executable witnesses that the pushforward of subsets along a function aligns with the direct-image description, while also emitting the pullback-as-contravariant companion needed for inverse images. For finite-dimensional vector spaces, expose the dualization functor together with evaluation/coevaluation data and diagnostics confirming involutivity up to canonical isomorphism. Tie these examples back to the general contravariant infrastructure so the codebase can shuttle between covariant power objects, inverse-image functors, and dual vector space transposes exactly as the text prescribes.

- [x] Implement a `powersetFunctor` on `Set` that outputs both the covariant direct-image action and a linked `inverseImageContravariant` helper, each returning strengthened witnesses that replay the textbook proofs of identity and composition preservation.
- [x] Build a `finiteDimensionalDualFunctor` constructor for the linear-algebra adapters that pairs each space with its dual, packages the transpose-on-arrows mapping, and verifies involutive behavior via executable double-dual comparison witnesses.
- [x] Expose natural transformations that connect the covariant and contravariant facets (e.g., adjunction-like relationships between direct and inverse image) and ensure their components align with the opposite-category machinery from Milestone 12.
- [x] Augment documentation and regression tests so the new functors appear in the contravariant examples catalogue, covering set-theoretic direct/inverse images and finite-dimensional dualizations side by side.

## Milestone 14 – Representable functors, Yoneda embeddings, and density diagnostics
Section 27 pivots from concrete functor examples to the Yoneda machinery that reconstructs objects from their hom-set fingerprints. Extend the roadmap by making representable functors executable artifacts: surface builders that, given an object \(C\) in a locally small category, return the hom-functors \(\mathrm{Hom}_C(C, -)\) and \(\mathrm{Hom}_C(-, C)\) together with the natural transformation witnesses supplied by Yoneda’s lemma. Encode the Yoneda embeddings for both covariant and contravariant sides, record the evaluation bijections promised by the lemma as reusable diagnostics, and ensure density arguments (e.g., characterizing objects by their presheaf of points) can be mechanized with categorical search utilities. Coordinating these constructions with the functor-category infrastructure from Milestone 9 will let later milestones tap into the full presheaf topos toolkit without re-deriving the core equivalences.

- [x] Introduce `representableFunctor` helpers that assemble the covariant and contravariant hom-functors from a `Category` witness, returning strengthened functor data plus metadata about the representing object.
- [x] Implement `yonedaEmbedding` constructors that map each object to its representable presheaf, emitting natural isomorphisms \(\mathrm{Nat}(\mathrm{Hom}_C(C, -), F) \cong F(C)\) as executable witnesses and packaging their inverse constructions for diagnostics.
- [x] Provide utilities that check density and separation properties by leveraging Yoneda: e.g., oracles verifying that morphisms are determined by their components under all representables, and helpers that search for natural transformations realizing specified elements of presheaves.
- [x] Integrate the new representable tooling with Milestones 9 and 12 by supplying whiskering/transpose adapters for natural transformations and documenting how contravariant representables populate presheaf categories, including regression tests that replay canonical examples (evaluation for exponentials, unit/counit for adjunctions).

## Milestone 15 – Functor composition constructors, associativity, and variance diagnostics
Section 26.7 reminds us that functors compose just like functions, and the textbook’s Theorems 129–130 spell out both the associativity of composition and the variance behavior: covariant functors compose to covariant functors, while composing two contravariant functors flips variance back to covariant. Extend the roadmap by operationalizing explicit composition builders that emit strengthened witnesses confirming identities and composition preservation across the chain. Provide constructors for covariant∘covariant, covariant∘contravariant, and contravariant∘contravariant composition, each paired with diagnostics that replay the proof obligations the book emphasizes—especially the outer-rectangle argument that guarantees equality of the composite arrow assignment. Finally, expose associativity and identity oracles so the category of (co/contra)variant functors can be treated as a legitimate category in code, paving the way for Milestone 9’s functor-category infrastructure to rely on reusable composition primitives rather than ad-hoc glue.

- [x] Introduce a `composeFunctors` helper that accepts strengthened witnesses from Milestone 4 and returns both the composite functor and a structured report verifying the identity and composition equations from Theorem 129.
- [x] Add dedicated adapters for variance-mixing cases (`composeCovariantContravariant`, `composeContravariantContravariant`, etc.), each emitting metadata about the resulting variance and regression tests that demonstrate Theorem 130’s “contra ∘ contra = co” law.
- [x] Implement associativity diagnostics that compare `H ∘ (G ∘ F)` with `(H ∘ G) ∘ F` at both object and arrow levels, surfacing explicit commutative diagrams when discrepancies appear.
- [x] Provide identity-law oracles that certify left/right unit behavior for identity functors and integrate these checks into Milestone 9’s functor-category builders so the category structure is grounded in executable witnesses rather than assumptions.

## Milestone 16 – Kan extension machinery and (co)end calculators
Section 27’s Yoneda perspective sets the stage for Kan extensions as the universal way to extend functors along functors. Queue a milestone to operationalize both left and right Kan extensions in our framework: given functors \(F : C \to D\) and \(K : C \to E\), build constructors that emit the left Kan extension \(\mathrm{Lan}_K F\) and right Kan extension \(\mathrm{Ran}_K F\) together with executable universal arrows. Implement reusable `(co)end` evaluators that compute the pointwise formulas appearing in the textbook proofs—especially the coend presentation of left Kan extensions and the end presentation of right Kan extensions—so callers can materialize the induced natural transformations. Layer diagnostics that replay the triangle diagrams certifying minimality/universality, and integrate the machinery with Milestones 9 and 14 so representables, Yoneda embeddings, and functor categories can request Kan extensions as first-class citizens.

- [x] Implement `leftKanExtension` and `rightKanExtension` builders that accept functors \(F\) and \(K\) plus smallness/complete-cocomplete witnesses, returning the extended functor, its universal natural transformation, and structured diagnostics for uniqueness proofs.
- [x] Provide `(co)end` helper utilities that compute finite/cofiltered coends and ends using our existing limit/colimit constructors, exposing intermediate witnesses for debugging when the universal properties fail.
- [x] Integrate the Kan extension constructors with the functor-category tooling from Milestone 9 so composition, whiskering, and naturality checks reuse the new universal arrows automatically.
- [x] Add regression tests grounded in concrete categories (FinSet, small posets) that replay textbook examples—e.g., extending a diagram along an inclusion—and ensure the diagnostics flag any deviation from the universal property.
- [x] Document how Yoneda-based density arguments (Milestone 14) can be rephrased via Kan extensions, and provide adapters that specialize the general machinery to familiar constructions such as left Kan extensions along inclusions of subcategories or Kan extensions that recover limits/colimits as special cases.

## Milestone 17 – Functor images, subcategory detection, and preservation/reflecting diagnostics
Section 27.1 cautions that the object-and-arrow images of a functor need not assemble into a subcategory, while Definition 106 in Section 27.2 formalizes what it means for a functor to preserve or reflect a property. Extend the roadmap with infrastructure that captures these nuances: build analyzers that, given a functor \(F : C \to D\), determine whether the image of each generating object/arrow closes under identities and composition, emitting explicit counterexamples when it fails, and surface constructors for the textbook “image factorization” through the wide subcategory generated by the image. In parallel, design a reusable `preservesProperty`/`reflectsProperty` oracle pattern that functor builders can instantiate for properties like monomorphisms, epimorphisms, limits, or object-level predicates, complete with diagnostic witnesses showing how preservation or reflection succeeds or fails on chosen samples.

- [x] Implement `analyzeFunctorImage` utilities that inspect the object and arrow images of a `FunctorWitness`, check closure under identities/composition, and return structured reports (including explicit composites) whenever the image is not a subcategory, matching the examples highlighted in Section 27.1.
- [x] Provide an `imageSubcategoryFactorization` helper that, when closure holds, constructs the induced wide subcategory of \(D\) on the image objects, together with the inclusion and factorized functors, and verifies the commuting diagram via executable witnesses.
- [x] Introduce a generic `FunctorPropertyOracle` interface that captures preservation and reflection checks for arrow- or object-level properties, parameterized by the property oracle on \(C\) and \(D\), and thread it through existing functor constructors (Milestones 4–15) so each can advertise which properties they preserve/reflect.
- [x] Package canned instances for standard properties called out in the text—e.g., monomorphisms/epimorphisms in concrete categories, possession of terminal objects, or membership in reflective subcategories—and add regression tests that sabotage preservation/reflection to ensure the diagnostics surface the violated morphisms.
- Update documentation and milestone cross-links so future Yoneda/Kan extension tooling (Milestones 14–16) can demand preservation/reflection metadata when forming image factorization arguments or density proofs.

## Milestone 18 – Fullness, faithfulness, essential surjectivity, and categorical equivalences
Section 27.3 pivots from raw functor images to qualitative properties—fullness, faithfulness, essential injectivity on objects (Definition 109), and essential surjectivity—that characterize equivalences of categories. Extend the plan with executable infrastructure that captures these notions uniformly: expose oracles that certify when a functor hits every morphism between image objects (full), embeds hom-sets injectively (faithful), detects when objects are unique up to isomorphism in the image (essentially injective on objects), or is essentially surjective via explicit isomorphism witnesses. Bundle these diagnostics into an `EquivalenceWitness` constructor that assembles the quasi-inverse functor, unit/counit natural isomorphisms, and triangle identities whenever the textbook criteria hold. Align the tooling with existing image-factorization and Yoneda machinery so the codebase can reason about categorical equivalences without duplicating arguments across modules.

- [x] Implement `checkFullFunctor` and `checkFaithfulFunctor` oracles that operate on strengthened `FunctorWitness` data, returning structured counterexamples (pairs of distinct arrows or missing lifts) when the properties fail and integrating with the preservation/reflection metadata from Milestone 17.
- [x] Ensure the new oracles evaluate Definition 108 literally by iterating over generating pairs of objects and arrows, validating identity-on-objects behavior for faithfulness and objectwise surjectivity on hom-sets for fullness, with diagnostics that quote the offending arrows when checks fail; in parallel, implement `checkEssentialInjectivityOnObjects` so Definition 109’s “iso implies equality” condition is enforced with witnesses or counterexamples that name the specific non-isomorphic duplicates in the target.
- [x] Design an `isEssentiallySurjective` helper that searches for isomorphism witnesses between target objects and image objects, delegating to existing isomorphism enumeration utilities where available, and emitting diagnostic traces when the search fails; coordinate its implementation with the essential-injectivity oracle so the combined diagnostics distinguish between duplicates (Definition 109) and missing image representatives.
- [x] Introduce a `buildEquivalenceWitness` routine that, given a functor together with fullness, faithfulness, and essential-surjectivity witnesses, constructs the quasi-inverse functor and unit/counit natural isomorphisms, verifies the triangle identities via executable proofs, and packages the result for downstream reuse.
- [x] Add regression tests in archetypal settings (finite groupoids, skeletal vs. non-skeletal categories, inclusion of core subcategories) that demonstrate how the new utilities detect equivalences and expose informative diagnostics when one of the three conditions is sabotaged.
- Update documentation and cross-links so adjunction tooling (Milestone 11), functor-category constructors (Milestone 9), and Yoneda/Kan extension infrastructure (Milestones 14–16) can depend on equivalence witnesses to streamline reuse of categorical equivalence arguments.

## Milestone 19 – Exhibit and diagnose non-preservation by forgetful functors
Section 27.4’s cautionary tales (Theorems 132–133) show that even familiar forgetful functors fail to preserve canonical limits and monomorphisms: the forgetful functor `U : Mon → Set` can send a coequalizer in `Mon` to a non-coequalizing pair of functions, and the same `U` fails to preserve certain coproducts or reflect monicity. Extend the roadmap with infrastructure that both constructs these counterexamples and exposes reusable diagnostics for future forgetful or inclusion functors. Doing so ensures the codebase can demonstrate, not just assert, where preservation breaks and how those failures interact with the property-oracle framework from Milestones 5 and 17.

- [x] Codify the textbook counterexample for coequalizers by implementing a `forgetfulCoequalizerCounterexample` helper that builds the offending monoid diagram, computes the coequalizer inside `Mon`, maps it through `U`, and packages witnesses that the resulting Set-level map fails the universal property.
- [x] Provide analogous `forgetfulCoproductCounterexample` utilities that stage the monoid coproduct example from Theorem 133, including diagnostics highlighting which inclusion/section equations fail after applying `U`.
- [x] Extend the functor preservation oracles to record negative evidence: augment `FunctorPropertyOracle` so it can attach explicit counterexamples when a functor does **not** preserve or reflect a property, and ensure the forgetful functor constructors surface these diagnostics in their metadata.
- [x] Add regression tests in `test/functor` (or a new suite) that execute the counterexample builders, confirming the witnesses break the expected preservation laws while maintaining sanity checks (e.g., `U` still preserves underlying functions and composition).
- [x] Document the new counterexamples alongside existing forgetful-functor helpers from Milestone 5, noting how these diagnostics inform later milestones that rely on preservation hypotheses (Kan extensions, representables, etc.).

## Milestone 20 – Reflective and coreflective subcategories with adjunction detectors
Section 27.5 revisits how reflective and coreflective subcategories arise from adjunctions and how unit/counit witnesses encode the universal arrows back into the ambient category. Extend the roadmap to make these structures executable: add builders that, given a fully faithful inclusion functor, search for and package the associated left or right adjoint together with explicit unit or counit natural transformations. Provide analyzers that check whether a proposed subcategory is reflective or coreflective by verifying the triangle identities and documenting how limits/colimits transfer along the adjunction. This machinery should dovetail with Milestones 11 (adjunction witnesses) and 18 (equivalences) so reflective subcategories can be recognized, diagnosed, and reused throughout the codebase.

- [x] Implement `buildReflectiveSubcategoryWitness` and `buildCoreflectiveSubcategoryWitness` helpers that take an inclusion functor and construct the adjoint plus unit/counit natural transformations, returning structured diagnostics that replay the universal property obligations from Section 27.5.
- [x] Integrate the new builders with the adjunction infrastructure from Milestone 11 so that reflective/coreflective witnesses can be synthesized automatically from existing adjunction data, including regression tests on canonical examples (e.g., abelianization `Grp → AbGrp`, completion of posets under ideals).
- [x] Add analyzers that inspect a subcategory candidate and determine whether the unit or counit components satisfy the triangle identities, emitting counterexamples and visualization-ready diagrams when the reflective/coreflective criteria fail.
- [x] Update documentation and cross-links so the preservation/reflection tooling from Milestones 17–18 can exploit reflective adjoints to transfer limits, colimits, and equivalences more systematically.


## Milestone 21 – Conservative functors, pullback preservation, and collapse-style counterexamples
Section 27.2’s closing remarks and Theorem 134 highlight several operational nuggets that our roadmap should capture: every functor preserves isomorphisms, but it may fail to preserve or reflect monomorphisms, epimorphisms, or right inverses; Definition 107 packages iso-reflection as “conservativity”; and preserving pullbacks (resp. pushouts) forces preservation of monomorphisms (resp. epimorphisms). Extend the plan to encode these facts executably. Start by enriching the functor-property framework so iso preservation becomes a first-class oracle and iso reflection is exposed via a dedicated `isConservative` diagnostic. Build collapse-style counterexample generators that witness the failures described in the text—functors that collapse everything to a one-object category preserve neither monics nor epics and fail to reflect right inverses—so the new oracles can surface precise why-not traces. Finally, connect pullback/pushout preservation witnesses to the monomorphism/epimorphism oracles, providing reusable diagnostics that certify Theorem 134’s implications and flag when the hypotheses are missing.

- [x] Extend the `FunctorPropertyOracle` suite (Milestone 17) with a mandatory `preservesIsomorphisms` report that witnesses the textbook proof directly and threads through all functor constructors.
- [x] Implement an `isConservativeFunctor` helper that searches for iso reflection witnesses, returning structured counterexamples when a functor fails to be conservative and integrating with Milestone 18’s equivalence tooling.
- [x] Create reusable collapse-functor constructors that instantiate the text’s non-preservation examples, along with regression tests and documentation excerpts that demonstrate failures to preserve/reflect monics, epics, and right inverses.
- [x] Add `preservesPullbacksImpliesMonomorphisms` and `preservesPushoutsImpliesEpimorphisms` diagnostics that consume pullback/pushout preservation witnesses, produce the induced monomorphism/epimorphism oracles per Theorem 134, and alert callers when the preservation hypotheses are absent.
- [x] Update the preservation/reflection docs and API surface so downstream code can query for these implications declaratively, linking to the counterexamples whenever a functor lacks the necessary hypotheses.

## Milestone 22 – Limit and colimit preservation along adjunctions
Section 27’s adjoint-theoretic corollaries remind us that right adjoints automatically preserve limits, left adjoints preserve colimits, and creation of universal constructions can be certified via unit/counit data. Strengthen the roadmap with executable infrastructure that captures these facts: given an adjunction witness (Milestone 11), derive oracles that confirm the expected preservation/creation behavior on sampled diagrams, expose diagnostics when the underlying limit or colimit witnesses are missing, and integrate the results with the preservation framework from Milestones 17–21. Complement the positive results with counterexample builders showing how functors lacking adjoints can fail to preserve the same constructions, mirroring the cautionary examples at the end of the section.

- [x] Extend the adjunction witness API so each `AdjunctionWitness` carries derived `preservesLimits`/`preservesColimits` metadata that replays the textbook proofs using the unit/counit triangle equations.
- [x] Implement reusable `createLimitFromRightAdjoint` and `createColimitFromLeftAdjoint` helpers that, given a limit/colimit witness in the source category and an adjunction, produce the corresponding universal construction in the target together with verification oracles.
- [x] Integrate the new preservation metadata into the `FunctorPropertyOracle` pipeline so downstream functor constructors automatically expose limit/colimit preservation when sourced from adjunctions, and emit structured warnings when the necessary adjoint information is absent.
- Build counterexample utilities that demonstrate how non-adjoint functors can fail to preserve representative limits or colimits (products, equalizers, coequalizers), providing regression tests and documentation snippets that contrast them with the adjoint-backed cases.
- Cross-link the documentation for Milestones 17–21 so preservation-by-adjunction, conservative functors, and reflective/coreflective subcategory tooling present a unified story about when categorical structure transfers across functors.

## Milestone 23 – Catalogue textbook case studies on faithfulness, fullness, and essential injectivity
Definition 109 and Examples (1)–(8) foreground a gallery of familiar functors whose object and arrow behavior tests the boundaries between faithfulness, fullness, essential injectivity on objects, and essential surjectivity. Extend the plan with executable case studies that exercise the new diagnostics from Milestones 18–22: assemble canonical witnesses for the forgetful functors `Ab → Grp`, `Grp → Set`, and `Mon → Set`, the thinning and inclusion functors between pointed or skeletal categories, and the “total collapse” functors that destroy structure. Each case study should ship with proofs or counterexamples for the relevant properties—e.g., why `Grp → Set` is faithful but not essentially injective, why the thinning functor is neither full nor faithful, or how the collapse functor annihilates monomorphisms—so the roadmap captures the nuanced taxonomy presented in the text.

- [x] Build a `textbookFunctorGallery` module that instantiates the highlighted functors with strengthened witnesses, tagging each with expected property outcomes (faithful, full, essentially injective on objects, essentially surjective) drawn from the examples.
- [x] Author executable property checks that replay the textbook arguments: witness faithfulness of `Ab → Grp` and `Grp → Set`, detect non-fullness by exhibiting missing hom-set lifts, and certify failures of essential injectivity by constructing non-isomorphic preimages mapping to isomorphic targets.
- [x] Implement explicit counterexample generators for the thinning and total-collapse functors that demonstrate the loss of faithfulness/fullness, including diagnostics that trace the offending morphisms or object identifications.
- [x] Integrate the gallery with the preservation/reflection metadata (Milestones 17 and 21) so each functor advertises which categorical structures it preserves, reflects, or destroys, providing regression tests that pin the expected outcomes.
- [x] Document the gallery and wire it into `NEW_PLAN.md` cross-references so future milestones (e.g., equivalence detection, reflective subcategories) can reuse the curated examples as regression fixtures and tutorial material.


## Milestone 24 – Skeletons, essential images, and equivalence normal forms
Section 27’s discussion of equivalence-on-objects encourages us to package “skeleton” constructions as first-class utilities so any category can be collapsed onto a representative subcategory that is equivalent but easier to analyze. Extend the roadmap with tooling that computes skeletal representatives, aligns them with the essential-image and equivalence diagnostics from Milestones 17–18, and exposes reusable witnesses for the equivalence between a category and its skeleton. Doing so will let future proofs normalize problems to skeletal forms, replay textbook arguments about uniqueness up to isomorphism, and compare different functors via their induced maps on skeleta.

- [x] Implement a `computeSkeleton` helper that, given object and isomorphism oracles, selects canonical representatives, produces the inclusion functor, and certifies its essential surjectivity via executable witnesses.
- [x] Build `skeletonEquivalenceWitness` constructors that pair the inclusion with a quasi-inverse functor back to the original category, verify the unit/counit triangle equations, and integrate with Milestone 18’s `buildEquivalenceWitness` pipeline.
- [x] Add analyzers that compare functors after skeletal reduction—e.g., by factoring them through the skeleton of the domain or codomain—to detect when two functors become naturally isomorphic or when essential injectivity fails only because of redundant isomorphic objects.
- [x] Document the skeleton machinery alongside the essential-image tooling, illustrating how to normalize categorical data, and provide regression tests on archetypal categories (finite groupoids, posets, and skeletal/non-skeletal presentations) that demonstrate the helpers in action.

## Milestone 25 – Idempotent completions and Karoubi envelopes
Section 27’s closing remarks gesture toward splitting idempotents to obtain Cauchy-complete categories. Extend the roadmap with executable support for Karoubi envelopes: implement utilities that detect idempotent endomorphisms, construct their images as new objects, and witness the universal property of the idempotent completion. Pair these builders with adapters that compare a category to its Karoubi envelope, reusing the equivalence tooling from Milestones 18 and 24, and document how localization or reflective-subcategory workflows can leverage the completions when skeletal reductions are insufficient.

- [x] Implement `findIdempotents` analyzers that enumerate and classify idempotent endomorphisms using existing hom-set traversal utilities, emitting structured diagnostics when factorization data is missing.
- [x] Build a `karoubiEnvelope` constructor that packages the completion as a new category object, supplies the inclusion functor, and proves functoriality of morphism factorizations through the idempotent images.
- [x] Reuse `buildEquivalenceWitness` to certify when the inclusion is an equivalence (e.g., in already Cauchy-complete categories) and to generate counterexamples when idempotents fail to split.
- [x] Cross-link the completion tooling with Milestones 20 and 22 so reflective/coreflective subcategory detectors and adjunction-based preservers can invoke idempotent splitting when forming localizations or resolving partial adjoints.

## Milestone 26 – Leverage full faithfulness to certify essential injectivity
Theorem 138 underlines that a fully faithful functor is automatically essentially injective on objects. Extend the roadmap so this implication becomes executable: derive essential-injectivity witnesses directly from the fullness and faithfulness diagnostics introduced in Milestone 18, expose short-circuiting oracles that reuse an isomorphism search to build the required comparison maps, and document failure modes when the functor lacks either property. Integrate the new tooling with the case studies of Milestone 23 and the equivalence builders of Milestone 18 so that once a functor is proven fully faithful, the plan immediately schedules checks (and counterexample harvesters) for essential injectivity without re-enumerating objects from scratch.

- [x] Implement a `essentialInjectiveFromFullyFaithful` helper that consumes the strengthened fullness/faithfulness witnesses and produces the isomorphism data promised by Theorem 138, complete with diagnostics for when either hypothesis is absent.
- [x] Thread the helper through the equivalence-construction pipeline so `buildEquivalenceWitness` can automatically add essential-injectivity certificates whenever fully faithful data is available, and emit informative metadata when only one side of the implication holds.
- [x] Extend the textbook functor gallery (Milestone 23) with regression scenarios that verify the derived helper succeeds for archetypal fully faithful functors and surfaces counterexamples when fullness or faithfulness is deliberately sabotaged.
- [x] Update documentation and preservation dashboards to highlight the new implication, linking back to Milestones 17–19 so conservative functor checks and counterexample builders can compose with the essential-injectivity oracle.

## Milestone 27 – Fundamental group functor and fixed-point diagnostics
Section 27.4’s pointed-topology example operationalizes how functoriality constrains geometric retractions: the fundamental group functor \(\pi_1 : \mathbf{Top}_* \to \mathbf{Grp}\) carries any continuous, basepoint-preserving map to a group homomorphism, so a hypothetical retraction from the punctured disk to the circle would force a contradiction—recovering Brouwer’s fixed-point theorem. Extend the roadmap to capture this reasoning executable: enrich our pointed-topological-space tooling, expose a `fundamentalGroupFunctor` witness that packages loop concatenation, homotopy classes, and induced maps on \(\pi_1\), and add analyzers that detect when a proposed retraction or deformation retract is impossible because \(\pi_1\) would map a nontrivial group to the trivial group. Pair these diagnostics with fixed-point theorems by showing how the absence of such retractions implies existence of fixed points for self-maps of the disk, and surface counterexample builders that demonstrate the necessity of the basepoint and continuity hypotheses.

- [x] Audit the current `top`/`Top` modules to ensure we have pointed-space objects, basepoint-preserving morphisms, and path concatenation witnesses; extend them with explicit loop and homotopy combinators when missing.
- [x] Implement a `fundamentalGroupFunctor` constructor that produces the object/arrow assignments, supplies group-structure witnesses for loop homotopy classes, and emits the strengthened functor witness from Milestone 4.
- [x] Create `retractionObstructionFromPi1` analyzers that, given maps \(r : X \to A\) and \(i : A \to X\) with \(r \circ i = \mathrm{id}\), compare the induced \(\pi_1\) homomorphisms and report contradictions when \(\pi_1(A)\) is nontrivial but \(\pi_1(X)\) is trivial.
- [x] Derive a `brouwerFixedPointFromNoRetraction` helper that packages the textbook argument: if every continuous self-map of the closed disk lacked a fixed point, construct a retraction onto the boundary circle and invoke the obstruction oracle to reach a contradiction.
- [x] Add counterexample utilities and regression tests in simplified settings (e.g., annulus retracts, wedge sums) that validate the obstruction machinery, ensuring basepoint and continuity requirements are enforced and documenting how the diagnostics fail when hypotheses are weakened.

## Milestone 28 – Localizations, calculus of fractions, and universal property diagnostics
Section 27.6’s treatment of localizing categories along subcollections of morphisms highlights how calculus-of-fractions data generalizes the reflective/coreflective story while demanding additional coherence (Ore conditions, saturation). Extend the roadmap so localization becomes executable infrastructure: introduce data types that record the fraction data (left/right fractions, denominator classes), builders that construct the localized category and universal functor, and oracles that replay the universal property by checking that inverted morphisms become isomorphisms and that maps out of the localization correspond to fraction-compatible functors. Integrate these tools with the existing adjunction and equivalence milestones so localizations can be analyzed alongside reflective subcategories and idempotent completions.

- [x] Define `CalculusOfFractionsData` interfaces capturing the Ore conditions, saturation, and closure properties required for left/right fraction calculi, along with diagnostics that surface missing hypotheses.
- [x] Implement a `localizeCategory` constructor that consumes the fraction data, forms formal roofs, composes them via the calculus laws, and emits both the localized category object and the canonical localization functor equipped with the strengthened functor witness from Milestone 4.
- [x] Develop `localizationUniversalProperty` oracles that, given a candidate functor into another category, certify the unique factorization through the localization when it inverts the designated morphisms, supplying explicit witnesses or counterexamples when the factorization fails.
- [x] Connect the localization machinery to Milestones 17–22 by reusing the preservation/reflection diagnostics to track which categorical properties survive the localization, and by integrating with the equivalence tooling to detect when the localization is actually an equivalence.
- [x] Document exemplar localizations (e.g., inverting homotopy equivalences in `Top`, groupoid completions of categories) and add regression tests that exercise the oracles on these case studies, verifying the calculus-of-fractions axioms and the universal property end-to-end.

## Milestone 29 – Orthogonality and factorization system tooling
Section 27’s closing remarks link localization data with orthogonality classes and factorization systems that split morphisms into “good” and “bad” parts. Extend the roadmap with executable infrastructure for weak factorization systems \((\mathcal{E}, \mathcal{M})\): introduce orthogonality oracles that search for diagonal fillers, builders that synthesize factorizations functorially from lifting data, and analyzers that detect when a functor preserves or reflects a chosen system. Pair the new utilities with documentation and regression suites so we can demonstrate textbook examples (Set surjections/injections, group homomorphism factorizations) and counterexamples where the axioms fail, aligning the codebase with the book’s factorization-system perspective.

- [x] Design an `OrthogonalityWitness` interface whose `hasLifting` oracle reports diagonal fillers (and counterexamples) for a chosen morphism pair, threading witness data suitable for compositional reuse.
- [x] Implement a `buildFactorizationSystem` helper that, given orthogonality witnesses for candidate classes \(\mathcal{E}\) and \(\mathcal{M}\), constructs functorial \(\mathcal{E}\)-then-\(\mathcal{M}\) factorizations, validates closure under composition and retracts, and surfaces diagnostics when axioms fail.
- [x] Provide category-specific instantiations—surjection/injection factorization in `Set`, regular epi/mono in `FinSet`, group homomorphism image-kernel factorizations—complete with property oracles that replay the lifting proofs from the text.
- [x] Extend the functor-property framework (Milestones 17–23) so witnesses can record whether a functor preserves or reflects a given factorization system, highlighting how adjunctions or localizations interact with orthogonality classes.
- [x] Document the new tooling with diagrams mirroring the book’s orthogonality squares, include regression tests that sabotage lifting conditions to ensure diagnostics are informative, and cross-link to localization and reflective-subcategory milestones where these factorizations drive constructions.

## Milestone 30 – Concrete category witnesses and faithful forgetful functors
Definition 10 reframes “concreteness” as the existence of a faithful functor \(U : \mathcal{C} \to \mathbf{Set}\), so extend the roadmap with infrastructure that packages such data and differentiates genuinely structured-set categories from exotic faithful representations. Build a `ConcreteCategoryWitness` that records the underlying-set functor, a faithfulness oracle, and metadata describing which structure is forgotten. Provide adapters that automatically produce these witnesses from our expanding gallery of forgetful functors (Milestones 5, 21–23) while also supporting textbook counterexamples such as the “sets with a singled-out subset” category whose faithfulness is tautological rather than structural. Use the witnesses to drive diagnostics that explain when a category fails to be concrete, when multiple faithful forgetfuls coexist, and how adjunctions or monadic presentations recover structure.

- [x] Specify a `ConcreteCategoryWitness` interface with slots for the category, its `U : \mathcal{C} \to \mathbf{Set}` functor, strengthened functor witness (Milestone 4), and a `checkFaithful` oracle that provides explicit hom-set separation diagnostics when faithfulness fails.
- [x] Implement builders that assemble concrete witnesses for standard categories (`FinSet`, `Mon`, `Grp`, `Ring`, `Preord`, pointed spaces) by reusing the forgetful constructors from Milestone 5 and annotating the structural features (operations, relations) that `U` forgets.
- [x] Capture exotic faithful representations from the text (e.g., sets equipped with a singled-out subset, or categories equivalent to `Set` but presented with redundant data) to highlight how faithfulness alone does not guarantee “structured sets”; emit metadata explaining the auxiliary structure that gets ignored.
- [x] Add analyzers that attempt to certify non-concreteness by searching for obstructions to faithful functors into `Set`, integrate them with the counterexample builders from Milestones 21 and 23, and document both positive and negative results with executable witnesses.
- [x] Wire the concrete-category witnesses into adjunction and monadic tooling (Milestones 11 and 22) so we can automatically detect when a forgetful functor admits a left/right adjoint, when it is monadic/comonadic, and how the concrete structure lifts along free functors.

## Milestone 31 – Adjoint functor theorem diagnostics and solution-set tooling
Freyd’s adjoint functor theorem and its special variants explain when a limit-preserving functor admits a left adjoint, provided the source category is complete, well-powered, and satisfies a solution-set condition. Extend the roadmap so these abstract hypotheses become executable: formalize completeness/cocompleteness witnesses, encode accessibility checks for hom-sets, and automate the search for weakly initial solution sets. Couple these utilities with our existing adjunction builders (Milestone 11) and reflective/coreflective tooling (Milestone 20) so we can derive adjoints rather than postulating them, and surface counterexamples when the hypotheses fail.

- [x] Introduce `CompletenessWitness` and `CocompletenessWitness` interfaces that collect the necessary limit/colimit constructors alongside diagnostics verifying closure under small diagrams, leveraging the limit/oracle machinery from Milestones 1–3.
- [x] Implement a `solutionSetCondition` analyzer that, given a functor and object, searches for weakly initial families of arrows, records witnesses when found, and emits detailed counterexamples highlighting where the condition breaks down (e.g., failure of smallness or boundedness).
- [x] Build an `adjointFromSolutionSet` helper that consumes completeness data, solution-set witnesses, and limit-preservation diagnostics to synthesize the left adjoint promised by Freyd’s theorem, integrating with the adjunction registry from Milestone 11 and documenting the extracted unit/counit.
- [x] Provide specialized adapters for the Special Adjoint Functor Theorem by wiring cocompleteness and accessibility checks for locally small categories, including fast paths for familiar settings such as `Top`, `Set`, and `Grp`.
- [x] Add regression suites and counterexample galleries that demonstrate both the success and failure modes of the analyzers—highlighting categories that violate well-poweredness, functors that preserve only finite limits, and how these obstructions prevent the automatic construction of adjoints.

## Milestone 32 – Diagram functors, cone orchestration, and limit/colimit normal forms
Section 28 reframes a “diagram of shape J in C” as nothing more than a functor \(D : J \to C\), with cones and limit cones encoded as structured families of arrows satisfying functorial coherence. Upgrade our diagram infrastructure so this perspective becomes the default: tighten the relationship between our existing `Diagram` data types and genuine functors, expose constructors that lift any functor \(D : J \to C\) into the diagram interface, and ensure constant functors \(\Delta_C\) participate in cone witnesses exactly as Definition 112 prescribes. Once the foundations align, retool the limit and colimit builders to produce cone data whose verification logic simply checks naturality against the diagram-functor action on arrows. This alignment will make future Kan-extension and co/end milestones (15–16) easier to express and will let us replay the book’s proofs directly in code.

- [x] Audit `diagram.ts`, `cone.ts`, and the limit helpers to confirm every diagram witness carries both object assignments and their induced arrow maps; when gaps exist, extend the types so diagrams become fully faithful reifications of functors between small categories.
- [x] Add adapters `functorToDiagram` and `diagramToFunctorWitness` that shuttle between our strengthened `FunctorWitness` (Milestone 4) and the diagram utilities, including explicit naturality diagnostics for each arrow \(j : J \to K\) required by Definition 112(1).
- [x] Refactor the cone and cocone builders so the coherence condition \(c_J = D(j) \circ c_K\) is enforced by a shared oracle that iterates over the indexing category’s arrows, reporting detailed failures when any component drifts; ensure constant-diagram cones \(\Delta_C \Rightarrow D\) are emitted with the same machinery.
- [x] Update limit and colimit constructors (products, equalizers, coequalizers, etc.) to package their universal cones via the upgraded oracle, guaranteeing Definition 112(2)’s uniqueness clause is validated through executable searches for mediating morphisms.
- [x] Extend regression coverage with canonical shapes—spans, co-spans, triangles, and walking parallel pairs—verifying that the functor-centric diagram representation interoperates with existing examples and that the rewritten cone oracles catch intentionally broken naturality equations.

## Milestone 33 – Reindexing diagrams and comparing induced (co)limits
Section 28.1 stresses that a functor \(u : I \to J\) lets us reindex any diagram \(D : J \to C\) by precomposition, with natural transformations mediating limit comparison morphisms such as \(\lim D \to \lim D \circ u\). Extend the roadmap so change-of-shape functors become first-class operators: enrich the diagram toolkit with precomposition and left/right Kan extension adapters between indexing categories, provide witnesses that describe how cones and cocones transport along these reindexings, and surface diagnostics that detect when a functor preserves or creates the corresponding (co)limits. This infrastructure will connect the diagram normalization of Milestone 32 with the Kan-extension agenda of Milestone 16, letting us restate the textbook comparison theorems directly within the executable framework.

- [x] Implement a `reindexDiagram` helper that, given \(u : I \to J\) and a diagram \(D : J \to C\), returns the composite \(D \circ u\) together with transformed cone/cocone witnesses, ensuring the induced naturality checks reuse the upgraded cone oracle.
- [x] Add `limitComparisonAlong` and `colimitComparisonAlong` constructors that build the canonical morphisms between limits (respectively colimits) of \(D\) and \(D \circ u\), report whether they are isomorphisms, and expose failure diagnostics when \(u\) lacks the properties demanded by the text (e.g., finality/cofinality).
- [x] Encode final and initial functor detectors that reuse the preservation/reflection tooling from Milestones 17–22 to certify when reindexing preserves limits or colimits, and integrate these results with the Kan extension planners of Milestone 16.
- [x] Document exemplar reindexings (e.g., inclusion of a cofinal subcategory, collapse onto the walking parallel pair) and add regression tests where the comparison morphisms succeed or fail, confirming the new helpers align with the textbook lemmas.
