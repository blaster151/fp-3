# Dayâ€“Chu Interaction Law Implementation Plan

## 0. Context and Objectives
- Leverage the existing Day convolution + Chu space infrastructure to model the interaction-law story outlined by Katsumataâ€“Rivasâ€“Uustalu (2019).
- Provide first-class runtime objects for functorâ€“functor interaction laws, expose dual/Sweedler constructions, lift the setup to monadâ€“comonad interaction laws (monoid/comonoid objects under Day convolution), and prepare for residual/stateful generalisations.
- Maintain oracle-driven verification and integration with the current category-theory toolkit; every new abstraction must surface diagnostics, witnesses, and LAWS.md/Oracle integration points.

### 0.1 Literature and Related-Work Alignment
- Track the neighbouring formalisms cited in SectionÂ 6â€™s â€œRelated workâ€ so implementation steps can import constructive insights when necessary. The key comparison points are:
  - Powerâ€“Shkaravska on comodels and Bauerâ€™s tutorial on runners/handlers, which motivate explicit comodel-oracle hooks when translating interaction laws into operational semantics.
  - Plotkinâ€“Powerâ€™s tensors of models/comodels and Hancockâ€“Hyvernatâ€™s interaction structures, which supply alternate universal properties for Day convolution pairings that may inform oracle design.
  - Uustaluâ€™s runners (2006) and the Katsumataâ€“Uustaluâ€“Rivas references that introduced stateful runners; these anchor the runner sections of the roadmap.
- **Tasks**
  1. Create a lightweight â€œrelated workâ€ registry (e.g., `docs/day-chu-related-work.md`) summarising each cited source with actionable checklists (what structures/oracles might be borrowed, which diagrams must be compared). Link this registry from the main plan once drafted.
  2. When implementing each phase, perform a gap analysis against the corresponding references (e.g., ensure PhaseÂ IIIâ€™s monoid/comonoid translators cover Plotkinâ€“Powerâ€™s tensor perspectives, PhaseÂ IVâ€™s runner adapters capture Hancockâ€“Hyvernat lenses). Record the outcomes in the registry so future revisions know whether further literature study is required.
  3. Flag open research questions discovered during implementation (for example, whether comodel-based semantics expose additional degeneracy witnesses) and feed them back into the roadmap as optional enhancements.

## 1. Phase I â€” First-class Functorâ€“Functor Interaction Laws
### Goals
- Wrap `buildDayPairingData` outputs into dedicated interaction-law values that mirror the paperâ€™s definitions.
- Preserve indexed carriers, contribution collectors, and Chu aggregators so no information is lost compared to todayâ€™s lower-level API.

### Tasks
1. **Module creation (`functor-interaction-law.ts`).**
   - Define a `FunctorInteractionLaw` record that packages: promonoidal kernel reference, left/right witnesses, `DayConvolutionResult`, indexed carriers, contribution aggregator, and the induced `ChuSpace`.
   - Provide constructors for common kernels (strict monoidal, finite toy kernels) that internally invoke existing promonoidal helpers.
   - Ensure the record exposes evaluation helpers (e.g. `evaluate(primalWitness, dualWitness)`) that internally reuse the collected Day contributions.
2. **Public surface integration.**
   - Export constructors from the main barrel (`allTS.ts`) and document provisional usage.
   - Introduce module-level JSDoc describing how the object realises the interaction-law diagram (functor pairs, evaluation to the dualising object) shown in the paperâ€™s SectionÂ 3 figure.
3. **Testing.**
   - Add regression coverage (extend `test/chu-space.spec.ts` or introduce `test/functor-interaction-law.spec.ts`) that instantiates a known promonoidal kernel, constructs a law, and checks the evaluation against the raw Chu pairing.
   - Include a check mirroring the interaction-law composition square to ensure the evaluation is natural with respect to the underlying functor morphisms.

## 1.5 Phase Ib â€” Degeneracy Results and Operation Interfaces (TheoremsÂ 1â€“2)
### Goals
- Encode SectionÂ 2â€™s **comment-on-operations** viewpoint explicitly: an `n`-ary operation on a monad is a natural transformation `Î±â¿_X : T(Xâ¿) â†’ TX` whose components commute with substitution (Plotkinâ€“Power format), arise from Kleisli composition (`T` applied to coproduct injections), and can be reinterpreted as morphisms of Lawvere theories `Î¼â‚™ : L â†’ L âŠ— n`.
- Dualise the description for comonads/cooperations where each `Î²â¿_X : TX â†’ T(Xâ¿)` is natural and respects the drop/duplication structure (`TX â†’ T(1)` compatibility).
- Record and operationalise the **degeneracy theorems** supplied in SectionÂ 2:
  - **TheoremÂ 1 (nullary collapse).** If a functor (or monad viewed as its underlying functor) carries a nullary operation `c_X : 1 â†’ FX` natural in `X`, then every functor interacting with `F` is forced to be the constant-zero functor `G â‰… 0`. The plan must surface checks that detect nullary operations and witness the induced zero object comparisons.
  - **TheoremÂ 2 (commutative binary collapse).** If `F` admits a commutative binary operation `c_X : X Ã— X â†’ FX` (natural in `X` and symmetric under the swap map), then any interacting `G` again degenerates to the constant-zero functor. We need executable counterparts for both proof parts: (1) the pullback/diagonal argument that collapses coproduct components, and (2) the uniqueness factorisation through the zero object.
- Capture these degeneracy results (including both parts of TheoremÂ 2â€™s proof) as executable checks/oracles ensuring that operations factoring through `T` coincide with canonical monad/comonad structure maps once transported along the Lawvere-theory comparison functor, while also surfacing the constant-zero witnesses guaranteed by the theorems.

### Tasks
1. **Operation type definitions.**
   - Introduce `MonadOperation`/`ComonadCooperation` types representing natural transformations of the form `Î±â¿_X : T(Xâ¿) â†’ TX` and `Î²â¿_X : TX â†’ T(Xâ¿)`.
   - âœ… Added reusable constructors (`makeNullaryMonadOperation`, `makeCommutativeBinaryMonadOperation`, and comonad counterparts) that package nullary/commutative-binary data together with optional Kleisli/Day/Lawvere witnesses so interaction laws can record SectionÂ 2 operations directly from monad/comonad structure.
   - Store for each operation: its arity `n`, the induced Kleisli morphism on generic elements (`T` applied to coproduct injections from `X` into `Xâ¿`), Lawvere-theory witness (`Î¼â‚™`), Day-convolution indices so interaction laws can reuse the same carriers, andâ€”for nullary/binary casesâ€”the specific nullary element `c_X : 1 â†’ TX` or commutative operation `c_X : X Ã— X â†’ TX` itself.
   - âœ… `makeFunctorInteractionLawOperations` now derives nullary/binary operation scaffolding directly from the supplied monad/comonad structure: monad units feed the recorded generic-element maps `Îº_Y = Î·_Y`, while comonad counits/comultiplications populate the dual `Îµ_Y`/`Î²_Y` witnesses so degeneracy analyzers can replay TheoremÂ 2 without manual substitutions.
2. **Degeneracy checkers.**
   - Implement structural oracles (e.g., `checkNullaryDegeneracy`) that replay TheoremÂ 1: detect natural nullary operations, compute the induced constant element `c_1 : 1 â†’ T1`, and build the canonical natural transformation exhibiting any interacting functor `G` as constant zero by producing explicit morphisms `GY â†’ 0` and `0 â†’ GY` with zero-object witnesses.
   - âœ… `checkNullaryDegeneracy`, `checkCommutativeBinaryDegeneracy`, and `analyzeFunctorOperationDegeneracy` now reconstruct the zero-object comparison maps for each object, returning explicit `SetCat` homs `GY â†’ 0` and `0 â†’ GY` beside the proof steps so the collapse in TheoremsÂ 1â€“2 has executable witnesses.
  - Add a complementary oracle (`checkCommutativeBinaryDegeneracy`) capturing TheoremÂ 2â€™s two-part argument for endofunctors: (i) verify the pullback diagram used to form `f_Y` commutes by reconstructing the coproduct stability argument, and (ii) materialise the uniqueness map `k_Y : GY â†’ 0` that factors through the zero object via the coproduct diagonals `Î´ : PY â†’ 0 + 0` and `Î´' : PY â†’ 1 + 1` discussed in the proof.
  - âœ… `checkCommutativeBinaryDegeneracy` now assembles the uniqueness data explicitly, constructing `h_Y`, the diagonal `Î´'_Y : GY â†’ 1 + 1`, and the factorisation `k'_Y : GY â†’ 0 + 0` before returning the canonical collapse map `k_Y : GY â†’ 0`.
   - Extend the existing `analyzeFunctorOperationDegeneracy` tooling so it also reports Lawvere morphisms `Î¼â‚™`, substitution comparison maps `Îºâ¿_X : T(Xâ¿) â†’ (TX)â¿`, and any counterexamples returned by recomputing the drop map `TX â†’ T1` used to certify constant-zero behaviour.
3. **Proof-structure tooling.**
   - Encode the reusable components from TheoremÂ 2â€™s proof: duplication of the generic element via `Î´â¿`, application of `Î·_X`, comparison with the canonical `Î¼â‚™`, and the final evaluation through `Îµ_X`, plus the explicit construction of the maps `f_Y`, `k'_Y`, and `k_Y` appearing in partsÂ (1) andÂ (2).
   - Provide tracing utilities that log each proof step (construct `Î´â¿`, lift via `T`, apply `Î±â¿`, compare with `Î¼â‚™`, evaluate with `Îµ_X`, and collapse to the zero object) so future low-level reads can refine the reasoning without rebuilding diagnostics.
   - âœ… `checkCommutativeBinaryDegeneracy` now emits detailed traces and artifacts per object, covering `Î´_Y`, lifted `Î±^2_Y`, substitution arrows, Lawvere comparisons, Day-fiber metadata, and explicit zero-factorisation gaps.
4. **Integration with interaction laws.**
   - Extend `FunctorInteractionLaw` records to optionally carry the primary operations/cooperations (including nullary/commutative binary metadata) so later phases (dual/Sweedler, monoid/comonoid lifts) can quote them directly and trigger degeneracy analysis automatically when present.
   - Update PhaseÂ I tests to validate that a sample monad exposes its binary operation through the new interface and that the degeneracy oracles report â€œconstant zeroâ€ with explicit witnesses when applied to the constructed interaction laws.
   - Add regression checks derived from TheoremÂ 2â€™s commutative diagrams (swap invariance, pullback stability, diagonal factorisation) to ensure functor-level degeneracy witnesses remain aligned with the interaction-law evaluation.
   - âœ… Operations metadata now propagates through stretching, products, and coproducts, and `test/functor-interaction-law.spec.ts` exercises `analyzeFunctorOperationDegeneracy` to confirm the recorded nullary/binary witnesses drive the collapse diagnostics.

## 1.75 Phase Ic â€” SectionÂ 2.3 Constructions (Stretching, Self-duality, Final Law)
### Goals
- Incorporate the SectionÂ 2.3 toolkit for manufacturing interaction laws directly from existing ones:
  - **Stretching:** given a law `(F, G, Ï†)` and natural transformations `f : F' â‡’ F`, `g : G â‡’ G'`, produce `(F', G', g âˆ˜ Ï† âˆ˜ f)` with inherited evaluation witnesses.
  - **Self-duality:** exploit the canonical symmetry `sym_X : X Ã— X â†’ X Ã— X` and the dualising Chu-space involution to obtain `(F^{op}, G^{op}, Ï†^{op})` together with evaluation comparison maps showing the `((IL(C))^{op})` equivalence described in the text.
  - **Final functor interaction law:** expose the terminal object `(1, 0, Ï†)` where `Ï†_{X,Y} : 1 Ã— GY â†’ 0` witnesses the constant-zero collapse highlighted alongside TheoremsÂ 1â€“2.
- Ensure these constructors are first-class on `FunctorInteractionLaw` and interoperable with degeneracy metadata (nullary/binary markers) so the plan keeps all prior detail intact while enabling SectionÂ 2.3 workflows.
- Register at least one new entry in `LAWS.md` summarising the â€œstretching lawâ€ and its oracle so that future implementers have a concrete executable law derived from the paper.

### Tasks
1. **Constructor implementations.**
   - Add `stretchInteractionLaw(law, f, g)` that replays SectionÂ 2.3â€™s stretching formula, reusing contribution collectors and ensuring the resulting evaluation equals `g âˆ˜ Ï† âˆ˜ f` on every coend representative.
   - Implement `selfDualInteractionLaw(law)` that transports the Day pairing along the symmetry `sym` and leverages `dualChuSpace` to return the law over `C^{op}`, emitting the comparison isomorphisms between the original and dual evaluations.
   - Provide `finalInteractionLaw(kernel)` that materialises `(1, 0, Ï†)` using the zero object of `Set` (or the chosen dualising object) and stores the unique morphisms into the zero functor; hook this into the degeneracy oracles so TheoremÂ 1â€™s constant-zero witness is now constructed via the final law helper.
2. **Oracle coverage.**
   - Extend the degeneracy checkers to call `finalInteractionLaw` whenever a nullary or commutative binary operation is detected, verifying that stretching along the canonical maps reproduces the same collapse proof as in TheoremsÂ 1â€“2.
   - Add structural oracles validating that stretching preserves interaction-law axioms (naturality squares, compatibility with Day convolution), following the â€œstretching lawâ€ text snippet.
   - âœ… Introduced `checkInteractionLawStretching`, which compares stretched evaluations against the base law across sampled witnesses and reports kernel mismatches or value discrepancies.
3. **Documentation & tests.**
   - Update the PhaseÂ I spec to include targeted tests for stretching/self-duality/final law: construct a toy kernel, stretch along nontrivial `f`/`g`, confirm evaluation equality, and assert that the self-dual law matches the explicit dual Chu space.
   - Record the new law in `LAWS.md`, citing the SectionÂ 2.3 formulae and pointing to the accompanying oracle/test harness.
   - âœ… Regression suite now invokes `checkInteractionLawStretching` alongside the direct evaluation comparison, and `LAWS.md` documents the oracle entry under the stretching law catalogue.

## 1.9 Phase Id â€” SectionÂ 2.4 Categorical (Co)products and (Co)algebra Constructions
### Goals
- Support the categorical operations on interaction laws highlighted after TheoremÂ 2, ensuring the roadmap covers both the product/coproduct of laws and the algebraâ€“coalgebra constructions obtained by currying the evaluation maps.
- Preserve compatibility with the degeneracy metadata from PhaseÂ Ib and the constructors from PhaseÂ Ic so stretching/self-duality/final-law workflows compose with these new operations.

### Tasks
1. **Binary product & coproduct constructors.**
   - âœ… Implemented `productInteractionLaw(law0, law1)` realising the displayed composite `Ï†â°Ã—Â¹_{X,Y}`: the helper now pairs Day fibers, aggregates witnesses with the underlying oracles, and exposes projection metadata for both functor components and the dualising carrier.
   - âœ… Added `coproductInteractionLaw(law0, law1)` by dualising the product recipe, threading coproduct injections for both witnesses, enforcing summand agreement on Day contributions, and surfacing the resulting injections for primal, dual, and value carriers.
   - âœ… Added `checkInteractionLawProductUniversalProperty`/`checkInteractionLawCoproductUniversalProperty`, which replay the projection/injection composites over sampled Day witnesses and confirm each factorâ€™s evaluation agrees with the recorded product or coproduct value.
2. **Initial algebraâ€“final coalgebra adapters.**
   - âœ… Added `deriveInteractionLawCurrying(law)` to curry each Day fiber, record the uncurry comparison, and emit discrepancy diagnostics when the reconstructed `Ï†^X_Y` diverges from the original evaluation.
   - âœ… Currying data surfaces alongside the fiber carriers, enabling oracles to inspect the `Î¸`/`Ï†` witnesses objectwise; discrepancies feed into the degeneracy analyzers for replaying SectionÂ 2.4 arguments.
3. **Fix-one-side interaction categories.**
   - âœ… Implemented `makeFixedLeftInteractionMorphism` and `makeFixedRightInteractionMorphism` to transport natural transformations on the right/left components into morphisms of `IL(C)_{F,-}` and `IL(C)_{-,G}`, returning comparison tables for evaluation preservation.
   - Provide isomorphism witnesses `IL(C)^op â‰… IL(C^op)` aligned with the SectionÂ 2.4 note, leveraging the self-dual constructor and logging the induced equivalence on objects/morphisms.
4. **Initial object accessors.**
   - âœ… Delivered `buildFixedLeftInitialObject` and `buildFixedRightInitialObject`, packaging the constant-zero collapse with canonical maps (or diagnostics when the fixed-right collapse is obstructed) and threading the results into degeneracy reports.
   - âœ… `LAWS.md` documents the currying adapters, fixed-side morphisms, and initial-object helpers together with their regression coverage.
6. **Testing.**
   - âœ… Expanded the interaction-law test suite with scenarios covering product/coproduct compositions, initial algebraâ€“final coalgebra derivations on toy kernels, and the verification that fixing a functor produces the promised initial objects.
   - âœ… Added regression traces demonstrating that the new helpers commute with stretching workflows (stretching a product/coproduct matches the product/coproduct of stretched laws), with elementwise comparisons recorded in `test/functor-interaction-law.spec.ts`.

## 1.95 Phase Ie â€” Cartesian-Closed Dual Presentation of Interaction Laws
### Goals
- Capture the â€œdual-of-an-endofunctorâ€ presentation from the SectionÂ 2.4 setup: when `ğ’` is Cartesian closed, define the dual of `G` at an object `X` as `G^X(Z) := ğ’(Z Ã— X, GX)` (using the internal hom/exponential object representing morphisms `Z Ã— X â†’ GX`).
- Rephrase interaction laws via the three equivalent natural-transformation viewpoints spelled out beneath equation (2.16):
  1. `Ï†^X_Y : FX âŠ— GY â†’ G(X âŠ— Y)` compatible with the symmetry and associativity constraints.
  2. `Ï†Ì‚^X_Y : G^X(FX âŠ— Y) â†’ G^Y` satisfying the coherence equation `G^X(Ï†Ì‚^Y_Z) âˆ˜ Ï†Ì‚^X_{FY,Z} = Ï†Ì‚^{XâŠ—Y}_Z`.
  3. `Ï†ÌŒ^X : FX â†’ G^X` where the preceding condition transports to exponential transpose equations.
- Provide executable conversions between these forms and confirm that all three yield the same Day/Chu evaluation data, enabling future phases to depend on the CCC-based dual description.
- Surface diagnostics for the existence of duals: detect when the exponential object `GX â‡’ ?` fails to exist, emit constructive witnesses when it does, and report conservative fallbacks for non-dualisable endofunctors as highlighted in the text.
- Materialise the â€œfinal transformationâ€ `Î´^X_Y : F^X(X Ã— Y) â†’ GY` obtained by instantiating the interaction law at the dual object, ensuring its computation is recorded alongside the CCC dual metadata.

### Tasks
1. **Cartesian-closed prerequisites.**
   - Extend the categorical infrastructure with detectors/constructors for Cartesian closed categories (CCC) that surface exponential objects, evaluation maps, and currying/uncurrying witnesses.
   - Provide helpers `internalHom(G, X)` or `dualizeEndofunctorCCC(G, X)` that materialise `G^X` along with the evaluation/counit `ev^X : G^X Ã— X â†’ GX` required by the SectionÂ 2.4 derivation.
   - Cache diagnostics when an exponential is missing and expose them through the interaction-law planning oracles so callers know when CCC-derived conversions are unavailable.
2. **Equivalence translators.**
   - Implement bidirectional translators between the three presentations: `(Ï†^X_Y) â†” (Ï†Ì‚^X_Y) â†” (Ï†ÌŒ^X)` using the CCC evaluation/coevaluation maps. Ensure each translator records the composite witnesses listed in the paper (e.g., the composition through `Î´^X`, the pullback squares, and the use of `Î¼_n`).
   - Attach algebraic simplifiers that verify the coherence law `G^X(Ï†Ì‚^Y_Z) âˆ˜ Ï†Ì‚^X_{FY,Z} = Ï†Ì‚^{XâŠ—Y}_Z`, logging every intermediate morphism so low-level reviews can trace the proof-of-equality path.
3. **Oracles and regression checks.**
   - Add CCC-aware oracles that confirm: (a) `Ï†^X_Y` agrees with the original Day evaluation when transposed twice, (b) `Ï†ÌŒ^X` coincides with the exponential transpose of `Ï†Ì‚^X_1`, and (c) stretching/self-duality respect the dual presentation.
   - Provide counterexample tracing that replays the â€œconservativeâ€ argument from the text: when a functor lacks a dual at some `X`, the oracle should emit the obstructing morphism and suggest falling back to the non-CCC formulation.
   - Extend the interaction-law tests to run through a toy CCC (e.g., `FinSet`) and assert the triple equivalence and coherence equation explicitly.
4. **Integration points.**
   - Thread CCC metadata into `FunctorInteractionLaw` so later phases (dual/Sweedler, monoid/comonoid lifts) can preferentially use CCC-based duals when available, while reverting to existing Day/Chu constructions otherwise.
   - Update `LAWS.md` with a SectionÂ 2.4 â€œCCC dual presentationâ€ entry describing the three interchangeable forms and referencing the new oracles/tests.

### Status
- âœ… PassÂ 6 attached CCC metadata to `deriveInteractionLawCurrying`, introduced the `deriveInteractionLawCCCPresentation` alias, recorded the `(Ï†, \hat{Ï†}, \check{Ï†})` triple together with evaluation-consistency diagnostics, and now tabulates each `Î´^X_Y` over the promonoidal tensor object `X âŠ— Y`, storing the Day-evaluation tables for downstream reconstruction of the explicit natural transformation.
- âœ… PassÂ 9 (PhaseÂ I follow-up) added the oracle `checkInteractionLawCCCPresentation` to replay the CCC summary, surfacing double-transpose/Ï†Ì‚ discrepancies and cataloguing per-object final-transformation diagnostics for downstream phases.

## 1.97 Phase If â€” Category-Level Equivalences and Comma Presentations
### Goals
- Implement the categorical equivalences spelled out after SectionÂ 2.4: the category `IL(ğ’)` of functorâ€“functor interaction laws is isomorphic to both comma categories `(ğ’, ğ’)_{â†“}` (objects `(F, G, Ïƒ)` with `Ïƒ : F â‡’ G'`) and `(ğ’, ğ’)^{op}_{â†“}` (objects `(F, G, Ï„)` with `Ï„ : G â‡’ FÂ°`, where `(-)'`/`(-)Â°` denotes the dual functor extracted from the Day/Chu pairing).
- Track the consequences for slice categories such as `IL(ğ’)_{-, G}` and `IL(ğ’)_{F, -}`: identify their initial/final objects explicitlyâ€”`(G, G, id_G)` and `(G', G, Îµ^G)` on the `G`-fixed side, `(F, F, id_F)` and `(F, FÂ°, Î·^F)` on the `F`-fixed sideâ€”and record the comparison maps that witness these universal properties (with `G'`/`FÂ°` supplied by the Day/Chu duals and `Îµ^G`, `Î·^F` taken from the evaluation/coevaluation witnesses).
- Ensure these equivalences are executable: provide functors in both directions, prove (via structured diagnostics) that they are quasi-inverse, and surface the induced morphism translations needed for later phases (monoid/comonoid lifts and CCC dual presentations).

### Tasks
1. **Data model for comma presentations.**
   - Introduce TypeScript records for comma objects `(F, G, Ïƒ)` and `(F, G, Ï„)` where `Ïƒ : F â‡’ G'` and `Ï„ : G â‡’ FÂ°` are natural transformations into the Day/Chu dual functors.
   - Provide constructors that build `G'`/`FÂ°` using the dualisation helpers already planned in PhasesÂ Icâ€“Ie so the comma models reuse the same witnesses and evaluation data.
   - Store explicit morphism representations (`Î± : F â‡’ Fâ‚`, `Î² : G â‡’ Gâ‚`) together with the compatibility squares required in the comma categories, ensuring diagnostics enumerate any failing naturality components.
   - âœ… PassÂ 7 delivered `deriveInteractionLawLeftCommaPresentation`, materialising the `G'` internal-hom functor, caching `Ïƒ` components, and emitting evaluation/naturality diagnostics plus an opposite-functor witness for `(F, G, Ïƒ)` objects.
2. **Equivalence functors.**
   - Define functors `IL(ğ’) â†’ (ğ’, ğ’)_{â†“}` and `(ğ’, ğ’)_{â†“} â†’ IL(ğ’)` that send an interaction law `(F, G, Ï†)` to `(F, G, Ïƒ)` with `Ïƒ` obtained by currying `Ï†`, and conversely reconstruct `Ï†` by uncurrying `Ïƒ`; mirror the construction for the dual `(ğ’, ğ’)^{op}_{â†“}` presentation.
   - Implement natural isomorphisms witnessing that these functors compose to the identity on both sides, with oracle traces logging every component map so low-level reviewers can verify the quasi-inverse property objectwise and arrowwise.
   - Include regression checks ensuring that stretching/self-duality commute with the equivalence functors, as predicted by the paperâ€™s discussion of categorical symmetry.
   - âœ… PassÂ 7b added `deriveInteractionLawLeftCommaEquivalence`, rebuilding the uncurried pairing `Ï†_X : F(X) Ã— G(X) â†’ âŠ™`, logging reconstruction/naturality failures, and extending the regression suite to confirm the quasi-inverse diagnostics on the two-object kernel.
3. **Universal-object witnesses.**
   - Materialise the initial/final objects for the fixed-slice categories explicitly: e.g. for `IL(ğ’)_{-, G}` build the morphisms from `(F, G, Ï†)` into `(G, G, id_G)` and from `(G', G, Îµ^G)` into `(F, G, Ï†)`, providing executable oracles that certify their universal properties via uniqueness up to equality in the comma categories.
   - Add diagnostics that reconstruct the zero-object witnesses appearing in the proof of the final object description, linking them to the degeneracy oracles from PhaseÂ Ib and the final interaction law from PhaseÂ Ic.
   - Update `LAWS.md` (and the interaction-law oracle registry) with entries describing the comma equivalence, the initial/final object formulas, and guidance on invoking the new oracles/tests.

### Status
- âœ… PassÂ 8 introduced `buildFixedRightFinalObject`, packaging the internal-hom functor `G'`, the evaluation pairing `(G', G, Îµ^G)`, and the comparison transformation `Ïƒ : F â‡’ G'` together with fixed-right morphism diagnostics and regression coverage.

### Phase I Completion
- âœ… PhaseÂ I tasks (Modules, degeneracy, SectionÂ 2.3 constructors, categorical products/coproducts, CCC translators, and comma equivalences) are now implemented and tested; revisit this plan before beginning PhaseÂ II per SectionÂ 9.

## 1.R PhaseÂ I Review Outcomes
- **Leverage recorded witnesses aggressively.**  The interaction-law core now emits rich degeneracy traces, CCC tables, and comma-equivalence witnesses; every downstream phase must reuse these caches instead of recomputing Day data.  Future tasks now explicitly call for threading the stored `Î´`, `Ïƒ`, and zero-collapse morphisms into later diagnostics.
- **Surface constructor provenance.**  Many utilities (stretching, products, coproducts) annotate how an interaction law was built.  PhasesÂ II andÂ III have been updated to insist on preserving this provenance so dual/Sweedler helpers and monadâ€“comonad packaging can quote the originating constructors when reporting diagnostics.
- **Tighten oracle scaffolding.**  Proving the PhaseÂ I oracles highlighted recurring structures (universal property samplers, CCC transposes).  Later phases now reference these shared scaffolds directly, reducing bespoke oracle work.
- **Document pass granularity.**  Concrete pass estimates are attached to PhasesÂ II andÂ III below so execution can be scheduled incrementally.

## 2. Phase II â€” Duals and Sweedler Duals (â€œGreatest Interactingâ€ Objects)
### Goals
- Reinterpret `dualChuSpace`, `sweedlerDualFromPrimal`, and `sweedlerDualFromDual` at the interaction-law level to produce the greatest functor/comonad that interacts with a given functor/monad (TheoremsÂ 1â€“2).
- Internalise the SectionÂ 2.5 â€œDual for some constructions on functorsâ€ recipes and their proofs: explicitly realise the coend calculations for the identity functor (`IdÂ° â‰… Id`), the terminal functor (`1Â° â‰… 0`), products (`(F Ã— G)Â° â‰… GÂ° Ã— FÂ°` with the constant-zero collapse when one factor is terminal), initial functors, coproducts, and weighted sums `GÂ°X â‰… âˆ«_Y A Ã— GÂ°Y`.
- Capture the derived examples and canonical natural transformations from the proofs: the exponent-of-identity case `GÂ°X â‰… âˆ«_Y (A â‡’ Y) â‡’ (X Ã— Y) â‰… A Ã— X`, ExampleÂ 4â€™s Day-sum functor (`GY = Yâº â‰… Î£_n (N_{[0,n]} â‡’ Y)`), and the generic â€œlower boundâ€ `âˆ«_Y Gâ‚€(Gâ‚Y) â‡’ (X Ã— Y)` for composite functors, together with the lax-monoidal comparison morphisms `m^{Gâ‚€,Gâ‚}_X : GÂ°â‚€(X) âŠ— GÂ°â‚(X) â†’ (Gâ‚€ â‹… Gâ‚)Â°(X)`.
- Expose ready-made constructors/oracles for these canonical duals so implementers can call the specialised formulas instead of recomputing the generic coend each time, while also cross-checking against the Sweedler dual computations and logging the proof steps (coend evaluation, currying/uncurrying, canonical naturality squares) used in the derivations.
- Ensure every dual/Sweedler constructor reuses the PhaseÂ I caches (Day contributions, CCC tables, comma equivalences, degeneracy traces) so diagnostics explain how each transformation relates back to the original law without recomputation.

### Tasks
1. **Dual interaction law constructor.**
   - Implement `dualInteractionLaw(law)` that swaps primal/dual data via `dualChuSpace`, updates witnesses, and reuses evaluation helpers.
   - Thread in the cached CCC tables, comma presentations, and degeneracy traces recorded in PhaseÂ I so the constructor reports provenance-aware diagnostics rather than recomputing Day fibers.
2. **Explicit dual constructors + proof logging.**
   - Provide dedicated helpers `dualOfIdentity`, `dualOfTerminal`, `dualOfProduct`, `dualOfInitial`, `dualOfCoproduct`, and a generic `dualOfWeightedSum` that mirror the formulas in SectionÂ 2.5: build the required coends explicitly, use the canonical evaluation witnesses (e.g., `GY = Y`, `GY = A Ã— G'Y`), and record the simplifying identifications (`X Ã— 1 â‰… X`, `X Ã— 0 â‰… 0`).
   - Add specialised constructors for the â€œexponent-of-identityâ€ case (`dualOfExponentialIdentity(A)` producing the equivalence `GÂ°X â‰… A Ã— X`) and for ExampleÂ 4â€™s free-monoid functor (`dualOfPositiveList`), replaying the summation/indexing arguments from the proof and storing the intermediate natural transformations `Î¸_n : (N_{[0,n]} â‡’ Y) â‡’ (X Ã— Y)`.
   - Encode the general lower-bound comparison for any functor `G` by constructing `dualLowerBound(G)` that materialises the coend `âˆ«_Y GY â‡’ (X Ã— Y)` alongside the canonical map into `GÂ°X`; document when the bound is an isomorphism (identity, terminal, product, coproduct cases) versus merely a comparison map.
   - Ensure each helper delegates to/validates against `dualInteractionLaw` so the specialised constructors agree with the general Chu-based dual, emitting diagnostics whenever the simplification assumptions (terminal object present, coproduct exists, exponentials available, etc.) are not met in the base category.
   - Thread these helpers into `FunctorInteractionLaw` so callers working with identity/terminal/product/coprod/exponential functors can request the dual directly, and store any constant-zero witnesses that arise when terminal factors collapse the product.
3. **Lax-monoidal comparison morphisms.**
   - Implement utilities `laxMonoidalDualComparison(G0, G1)` that build the canonical transformation `m^{Gâ‚€,Gâ‚}_X : GÂ°â‚€X âŠ— GÂ°â‚X â†’ (Gâ‚€ â‹… Gâ‚)Â°X` described beneath the proof of the composition rule, tracing the proof steps (`Î´`, `Î·`, currying) and recording when it upgrades to a monoidal isomorphism (identity/product cases).
   - Provide diagnostics that flag when `(-)Â° : [ğ’^{op}, ğ’] â†’ [ğ’, ğ’]` only yields a lax-monoidal structure, including counterexamples or witnesses when the canonical comparison fails to be invertible.
4. **Greatest interacting functors/comonads.**
   - Provide `greatestInteractingFunctor(law)` and `greatestInteractingComonad(law)` utilities that package the Sweedler dual evaluations as witnessed (co)functors.
   - Return both the transformed law and the induced natural transformations needed to act within the Day convolution context.
   - Ensure these helpers cite the stored zero-collapse and Î´-table metadata from PhaseÂ I so their diagnostics explain how the Sweedler witnesses interact with previously-detected degeneracies.
5. **Testing & Diagnostics.**
   - Extend the new spec to assert that composing an interaction law with its dual/Sweedler transform realises the evaluation identities promised in the paper (e.g. via sample witnesses, finite carrier enumeration).
   - Add regression cases for each specialised dual constructor (identity, terminal, product, coproduct, exponential identity, positive-list) comparing their outputs to the generic dual and verifying the simplification steps (`X Ã— 0 â†’ 0`, `A Ã— X` equivalence, `Î£_n` decomposition) via explicit witnesses.
   - Include dedicated checks for `laxMonoidalDualComparison` showing when the comparison morphism is invertible and when it merely provides a lower bound, reproducing the proof steps with logged intermediate morphisms and covering the ExampleÂ 5 scenario (`G = Yâº`, canonical `m^{G, G}` and `g^{(a,f)}` components).
   - Ensure diagnostic output highlights when aggregation fails to land inside the dualising object (mirroring `aggregateDayPairing`) and archives proof traces (coend evaluation, currying, diagonal factoring) for future low-level review.
6. **Documentation.**
   - Update `LAWS.md` with a â€œFunctorâ€“Functor Interaction Lawsâ€ section summarising the new helpers and linking to dual/Sweedler constructions.
   - Document the SectionÂ 2.5 identities, ExampleÂ 4, the lax-monoidal comparison, and their oracles/tests, including guidance on when each specialised dual helper is applicable and how it relates to the Sweedler dual story.

### Estimated Passes (â‰ˆ7)
1. Build `dualInteractionLaw` plus Sweedler helpers wired to cached CCC/Day witnesses.
2. Implement identity/terminal/product dual constructors with provenance-aware diagnostics.
3. Add coproduct/initial/weighted-sum dual constructors and align them with degeneracy traces.
4. Deliver exponential-identity and ExampleÂ 4 positive-list duals alongside proof logs.
5. Implement lax-monoidal comparison morphisms and associated oracle coverage.
6. Integrate â€œgreatest interactingâ€ functor/comonad helpers with regression tests.
7. Finalise documentation updates and ensure LAWS/oracle registries reflect the new APIs.

- âœ… PassÂ 1 delivered `dualInteractionLaw`, `deriveInteractionLawSweedlerSummary`, and the associated Sweedler map helpers.
  The implementation reuses cached Chu spaces, CCC tables, and comma-equivalence witnesses when supplied, propagates degeneracy
  metadata into the Sweedler diagnostics, and extends the regression suite with checks that the resulting dual law matches the
  self-dual construction while the Sweedler evaluations agree with the original interaction law.
- âœ… PassÂ 2 introduced the specialised dual constructors (`dualOfIdentity`, `dualOfTerminal`, `dualOfProduct`), wired their
  provenance-aware diagnostics, compared the specialised outputs against the generic dual via swap/comparison helpers, and
  extended both `LAWS.md` and the regression suite with identity/terminal/product coverage.
- âœ… PassÂ 3 added `dualOfInitial`, `dualOfCoproduct`, and `dualOfWeightedSum`, threading degeneracy metadata through each helper,
  reusing the PhaseÂ I initial-object witnesses, and updating `LAWS.md`/tests so coproduct and weighted-sum cases match the
  generic dual while surfacing the recorded collapse summaries.
- âœ… PassÂ 4 introduced `dualOfExponentialIdentity` and `dualOfPositiveList`, reusing PhaseÂ I cardinality caches to tabulate the
  \(GÂ°X â‰… A Ã— X\) counts, capturing ExampleÂ 4â€™s Î¸â‚™ summaries (including sequence previews), propagating degeneracy metadata from
  both the laws and specialised options, and expanding `LAWS.md`/tests so the new proof logs appear alongside the existing
  specialised dual coverage.
- âœ… PassÂ 5 implemented `laxMonoidalDualComparison`, materialised the swap-based comparison map for the dual lax-monoidal structure, logged per-object agreement diagnostics, packaged the bijectivity witness on the value map, added `checkLaxMonoidalDualComparison`, refreshed `LAWS.md`, and extended the regression suite to exercise both the helper and the oracle.
- âœ… PassÂ 6 delivered `greatestInteractingFunctor` and `greatestInteractingComonad`, reusing cached Sweedler/Comma data to package \([G(-), âŠ™]\) and \([F(-), âŠ™]\) as witnessed functors, building the induced Ïƒ-transformations, surfacing degeneracy metadata in the diagnostics, updating `LAWS.md`, and extending the regression suite with evaluation checks for both helpers.
- âœ… PassÂ 7 refreshed the Dayâ€“Chu documentation and oracle registry, adding a Sweedler/dual diagnostics overview to `LAWS.md`, confirming the new helpersâ€™ exports in `oracles/index.ts`, and recording provenance expectations so future phases can cite the shared summary/oracle entry points without further rewrites.
- âœ… PassÂ 8 implemented `dualLowerBound`, packaging the canonical comparison \(âˆ«_Y GY â‡’ (X Ã— Y) â†’ GÂ°X\) with objectwise Day-assignment carriers, iso detection, and propagated degeneracy metadata, extended the regression suite with lower-bound coverage, and documented the helper within the specialised dual catalogue.

## 3. Phase III â€” Monadâ€“Comonad Interaction Laws and Monoid/Comonoid Structure
### Goals
- Internalise SectionÂ 3â€™s definition of a **monadâ€“comonad interaction law**: given a monad `T = (T, Î·, Î¼)` and a comonad `D = (D, Îµ, Î´)` on the same base category, materialise a family of maps
  `Ïˆ_{X,Y} : TX Ã— DY â†’ X Ã— Y` (or, in closed form, `Ïˆ_{X,Y} : TX âŠ— DY â†’ X âŠ— Y`) that is natural in both variables and satisfies the four coherence squares matching Î·/Î¼ with Îµ/Î´ exactly as in the paperâ€™s diagram (unit laws, multiplication/comultiplication compatibility, and the mixed associativity square).
- Treat these interaction laws as **monoid objects** of the functorâ€“functor interaction category under Day convolution, reusing the Chu pairing to encode the multiplication/counit witnesses.
- Extract constructive diagnostics from the proofs: re-run the sequential composition argument (â€œmachine executes a computation and immediately returnsâ€) and the behavioural interpretation (â€œmachine observes a computation while producing outputsâ€), so every Ïˆ-based coherence condition is logged with witnesses.
- Reuse the PhaseÂ I degeneracy traces, CCC tables, and comma-equivalence witnesses when packaging Ïˆ-laws so later diagnostics can cite the existing zero-collapse, Î´, and Ïƒ metadata without recomputing Day fibers.
- Capture ExampleÂ 6â€™s finite case (`T = AY`, `D = A â†’ Y` for fixed `A`) where `Ïˆ` is induced by evaluation and multiplication, showcasing how the definitions collapse to concrete computations.
- Extend coverage to **ExampleÂ 7** (writer monad `TX = B Ã— X`, comonad `DY = B Ã— Y`, interaction `Ïˆ((b, x), (b', y)) = (x, b Â· y)` for a fixed monoid `B`) and **ExampleÂ 8** (update monad `TX = A â‡’ (B Ã— X)`, comonad `DY = A Ã— Y`, interaction `Ïˆ(f, (a, y)) = f(a)` for a fixed `B`-action on `A`), ensuring the plan records their evaluation formulas, naturality proofs, and diagnostic expectations as canonical regression targets.
- Incorporate **ExampleÂ 9** from SectionÂ 3: the free-semigroup monad `TX = Xâº` with the associative binary operation `db : X Ã— X â†’ TX` defined by `db(xâ‚€, xâ‚) = [xâ‚€, xâ‚]`. The plan must spell out how TheoremÂ 3 forces any interacting monad to collapse to the zero monad and capture the induced initial-set witnesses inside the degeneracy tooling.
- Record **ExampleÂ 14**â€™s refinement of ExampleÂ 9: rebuild the quotient presentation `T = Tâ‚€ / âˆ¼` where `Tâ‚€X = X + X Ã— X` is the free monad on `F(X) = X + X Ã— X`, the nonempty-list monad `TX = Xâº` is obtained by imposing the associativity equation for the binary operation `c_X : X Ã— X â†’ Tâ‚€X`, and the Sweedler dual `T^âˆ˜` embeds as the subcomonad of the cofree comonad on `G(Y) = Y + Y Ã— Y` presented by the coequation displayed in ExampleÂ 14. The roadmap must capture both the coequaliser diagram realising the quotient and the subobject inclusion witnessing the Sweedler dual.
- Reify the categorical statement that **monadâ€“comonad interaction laws are monoid objects in `IL(ğ’)`**: plan the quasi-inverse equivalence between `MCIL(ğ’)` and `Mon(IL(ğ’))`, detailing how to extract multiplication/unit from `Ïˆ`, reconstruct `Ïˆ` from monoid structure, and log witnesses on objects/morphisms that certify the equivalence.
- Internalise TheoremÂ 3â€™s **associative binary-operation degeneracy** in full detail: whenever a monad carries a natural family `c_X : TX Ã— TX â†’ TX` satisfying the associativity squares displayed in SectionÂ 3.2, every interaction law `Ïˆ_{X,Y} : TX Ã— DY â†’ X Ã— Y` must satisfy the comparison diagram equating `(Ïˆ_{X,Y} âˆ˜ (c_X Ã— id))` with `(Ïˆ_{X,Y} âˆ˜ (id Ã— D(c_Y)) âˆ˜ (id Ã— Ïˆ_{X,Y}))`. The implementation plan must now also record how the proof decomposes `B Ã— Y` as a coproduct `Y + Y` via distributivity, names the coprojections `Î¹_Y : Y â†’ B Ã— Y` and `Îº_Y : Y â†’ B Ã— Y`, constructs the pulled-back maps `Î¸_{X,Y}` and `Î´_{X,Y}`, and threads those morphisms through the long composite (culminating in the final string of `Ïˆ`, `c`, `Î¼`, and `Î´` arrows) so the eventual oracle can replay the proof step by step. These diagnostics must integrate with the PhaseÂ Ib metadata and surface the constant-zero witnesses whenever the degeneracy forces them.
- Incorporate **TheoremÂ 4â€™s coassociativity â‡’ rectangularity** result for comonads: whenever a comonad `(D, Îµ, Î´)` satisfies the coequation of coassociativity `Î´_Y : DY â†’ DDY` shown in ExampleÂ 14 (with its composite through `DY + (Y + Y)`), the induced maps automatically obey left and right rectangularity. The plan must retain the labelled arrows from the proof (the factored coprojections and the comparison maps into `(Y + Y)`) so diagnostics can replay how the coequation forces the rectangular diagrams to commute.
- Integrate the resulting structure with the stateful runner semantics that appear later in the paper without losing any of the degeneracy metadata gathered in PhaseÂ I.
- Capture SectionÂ 3.3â€™s **structural operations on `MCIL(ğ’)`** explicitly: stretching along monad/comonad morphisms, Day-tensor products `(Tâ‚, Dâ‚, Ïˆâ‚) âŠ— (Tâ‚‚, Dâ‚‚, Ïˆâ‚‚)`, binary products `(Tâ‚€, Dâ‚€, Ïˆâ‚€) Ã— (Tâ‚, Dâ‚, Ïˆâ‚)`, the composite-monoid law for `Tâ‚ âˆ˜ Tâ‚€` subject to the commutation condition `(Î», id)_Y âˆ˜ Ïˆâ‚€,Y = (id_{Tâ‚} Ã— Ïˆâ‚) âˆ˜ (Ïˆâ‚€ Ã— id_{Dâ‚})`, and the **composite interaction law** displayed in the new material: whenever `(Tâ‚€, Dâ‚€, Ïˆâ‚€)` and `(Tâ‚, Dâ‚, Ïˆâ‚)` are interaction laws with compatible distributive laws `Ïˆâ‚€^{Tâ‚}` and `Ïˆâ‚^{Dâ‚€}`, produce a law for the composite monad `Tâ‚ âˆ˜ Tâ‚€` and composite comonad `Dâ‚€ âˆ˜ Dâ‚` whose structure maps satisfy the commutative squares reproduced from the figure (the outer square involving `Tâ‚ Tâ‚€ X Ã— Dâ‚€ Dâ‚ Y` and the inner ones tracking the distributive-law comparisons). Each construction needs explicit diagnostics that replay the proof squares and verify the required morphism equalities.
- Plan for the **free monadâ€“comonad interaction law** described after the figure: when `ğ’` admits the initial algebras/final coalgebras that generate the free monad `F*`, the cofree comonad `Gâ€ `, and the auxiliary parameterised command `D(Y, W)` whose fibres decompose as the coproduct depicted (`FZ Ã— GY` alongside `F(Y Ã— W)`), reconstruct the natural transformation `Ïˆ'_{X,Y,Z,W}` built from the indicated components (`id Ã— fst`, `id Ã— snd`, coproduct inclusions, and the base interaction law `Ïˆ`). The roadmap must capture how restricting along a fixed monad (resp. comonad) yields an initial object in the slice category `MCIL(T, -)` (resp. final object in `MCIL(-, D)`), with explicit witnesses for the comparison morphisms into/out of the free law that enforce the universal property.
   - âœ… PassÂ 5 (PhaseÂ III) introduced `makeFreeMonadComonadInteractionLaw`, `deriveInitialMonadSliceObject`, and `deriveFinalComonadSliceObject`, capturing the coproduct inclusions and universal comparison arrays while wiring `checkFreeInteractionLaw` and the regression suite to certify the recorded witnesses.

### PhaseÂ IIIa â€” SectionÂ 3.4 Dual/Sweedler Reinterpretation
#### Goals
- Translate every monadâ€“comonad interaction law into the **dual/Sweedler dual** presentations shown in SectionÂ 3.4: given `Ïˆ : D â†’ TÂ°` satisfying the commutation squares labelled `(1)` and `(2)` in the excerpt, provide equivalent data as a natural transformation `Ïˆ : T â†’ DÂ°` and as a monoid map `(DÂ°Îµ, Î¿Îµ, Î´Â°)` from `D` to `TÂ°` inside `[ğ’, ğ’]`.
- Record that `(âˆ’)Â° : [ğ’^{op}, ğ’]^{op} â†’ [ğ’, ğ’]` is **lax monoidal** (sending monoids to comonoids) but not oplax, so the plan must materialise explicit diagnostics whenever the attempted dual fails to preserve comonoid structure; document that `TÂ°` typically lacks a comonad structure even when `T` is a monad.
- Formalise the Sweedler dual perspective: identify the **greatest comonad smaller than `TÂ°`** satisfying conditions `(2)` as the Sweedler (finite) dual of `T`, and add roadmap hooks for constructing it alongside the interaction law derived from `Ïˆ`.
- Restate the Sweedler dual definition exactly as in the text: a comonad `T^âˆ˜ = (T^âˆ˜, Îµ^âˆ˜, Î´^âˆ˜)` equipped with a natural transformation `Î¹ : T â‡’ T^âˆ˜` whose triangles `(3)` commute, and whose universal property guarantees every `Ïˆ : D â†’ TÂ°` factors uniquely through a comonad map `h : D â†’ T^âˆ˜` with `Ïˆ = Î¹ âˆ˜ h`. Plan to capture the equivalence of categories `MCIL(ğ’) â‰… {(T, D, Ïˆ : D â†’ TÂ°)} â‰… {(T, D, h : D â†’ T^âˆ˜)}` as executable translators.
- Document how these duals determine **initial and final objects** in the slice categories `MCIL(ğ’)_{-, D}` and `MCIL(ğ’)_{T, -}` (respectively `(Id, D, â€¦)`/`(D^âˆ˜, D, â€¦)` and `(T, T^âˆ˜, â€¦)`/`(TÂ°, T, â€¦)`), and ensure the plan captures ExampleÂ 10/11â€™s observation that the Sweedler dual comonad generally has a different underlying functor from the raw dual `TÂ°`.

#### Tasks
1. **Dual-characterisation adapters.**
   - Implement translators `interactionLawToDualMap(law)` and `interactionLawFromDualMap(Ï†)` that shuttle between a Ïˆ-family and the natural transformation `Ï† : D â†’ TÂ°` (and symmetrically `Ï†' : T â†’ DÂ°`), explicitly recomputing the commutative squares labelled `(1)` and `(2)` from the paper.
   - Ensure the translators annotate each law with the component morphisms used in the diagrams (the counit `Îµ`, comultiplication `Î´`, unit `Î·`, multiplication `Î¼`, and the evaluation arrows from the dual), logging any failure points as diagnostics compatible with our oracle framework.
2. **Lax-monoidal witnesses.**
   - Provide utilities that compute the lax-monoidal structure maps of `(âˆ’)Â°` on endofunctors (`m_{F,G} : FÂ° âŠ— GÂ° â†’ (F â‹… G)Â°`, `e : I â†’ IdÂ°`) and integrate them into the translators so that verifying a Ïˆ supplied as a dual morphism also checks the lax-monoidal coherence used in the excerptâ€™s string diagrams.
   - Add counterexample hooks that demonstrate why `(âˆ’)Â°` is not oplax in general: store failing composites when attempting to map comonoids to comonoids, along with the proof obligations that break (missing comparison for `m_{T,T}` or lack of `TÂ°` comultiplication).
3. **Sweedler dual constructors.**
   - Expand the planâ€™s dual helper suite with a `sweedlerDualMonad(T)` constructor that produces a witnessed comonad `(T^âˆ˜, Îµ^âˆ˜, Î´^âˆ˜)` together with the structure map `Î¹ : T â‡’ T^âˆ˜`, guaranteeing the triangles `(3)` commute by construction.
   - Schedule an oracle `checkSweedlerDualInteraction(T, T^âˆ˜, Î¹)` that replays the SectionÂ 3.4 argument: verify diagrams `(2)`, confirm maximality by testing any other comonad map `Ï† : D' â†’ TÂ°`, and report the unique factorisation witness `h : D' â†’ T^âˆ˜` with `Ïˆ = Î¹ âˆ˜ h`.
   - Ensure the constructor tracks both the comparison `T^âˆ˜ â‡’ TÂ°` and the evaluation witnesses so diagnostics can highlight how the Sweedler dualâ€™s underlying functor differs from `TÂ°` in examples.
4. **Slice objects, equivalence translators, and worked examples.**
   - Implement translators realising the categorical equivalences `MCIL(ğ’) â‰… {(T, D, Ïˆ : D â†’ TÂ°)}` and `MCIL(ğ’) â‰… {(T, D, h : D â†’ T^âˆ˜)}`, emitting explicit zig-zag witnesses when round-tripping between interaction laws, dual maps, and Sweedler dual factorizations.
   - Provide constructors for the initial/final objects in the slice categoriesâ€”`initialMCILMinusD()`, `finalMCILMinusD()`, `initialMCILTMinus()`, `finalMCILTMinus()`â€”using the Sweedler dual data `(Id, D, â€¦)`, `(D^âˆ˜, D, â€¦)`, `(T, T^âˆ˜, â€¦)`, `(TÂ°, T, â€¦)` spelled out in the excerpt and storing their universal comparison morphisms for oracle use.
   - Extend the plan with targeted regression scenarios for ExampleÂ 10 (free semigroup monad) and ExampleÂ 11 (A-bimodule-based writer-style monad) that compare the raw dual `TÂ°` and the Sweedler dual `(T^âˆ˜, Î¹)`, logging the differing carrier descriptions given in the article (length-indexed evaluations versus evaluation-by-weight records) and ensuring the oracles expose the discrepancy constructively without hard-coding a single carrier presentation.
5. **Documentation/tests integration.**
   - Update PhaseÂ III tests to include at least one interaction law exercised through the dual-characterisation translators and Sweedler dual factorisation, checking equality of the reconstructed Ïˆ with the original and verifying the lax-monoidal comparison maps.
   - Plan additions to `LAWS.md` that explain the dual/Sweedler reinterpretation, the limitations arising from lack of oplaxity, how the Sweedler dual helper recovers the â€œgreatest interacting comonadâ€, and how the new slice-object constructors realise the stated initial/final objects.

### Tasks
1. **Adapters for existing monads/comonads.**
   - Create helpers that map `MonadWithWitness`/`ComonadWithWitness` instances into `FunctorInteractionLaw` values, extracting the underlying functors and Kleisli/coKleisli structure needed to form `Ïˆ`.
   - Encode the â€œjust returningâ€ sequential interpretation explicitly: store the canonical comparison natural transformations `TX Ã— DY â†’ T(X Ã— DY) â†’ X Ã— Y` that arise from the monad multiplication acting after the comonad observation.
   - Materialise the concrete adapters for ExampleÂ 7 (writer monad/comonad pair) and ExampleÂ 8 (update monad/comonad pair), recording their `Ïˆ` formulas, the required monoid action witnesses, and the naturality derivations so they serve as reference implementations for later diagnostics.
2. **Monoid/comonoid packaging and composites.**
   - Implement constructors that equip interaction laws with monoid/comonoid structure data (unit `u : I â†’ law`, multiplication `m : law âŠ— law â†’ law`, counit, comultiplication) expressed via Day convolution transports; ensure the coherence diagrams from SectionÂ 3 commute via explicit witness computations.
   - Provide convenience accessors for stateful runner interpretations (SectionÂ 4) that package `Ïˆ` together with the induced runner maps `run_T^D : TX Ã— DY â†’ Y` and `observe_T^D : TX Ã— DY â†’ X`, reusing the exact string diagrams from DefinitionÂ 4.1 so later phases can compare them with the stand-alone runner axioms.
   - Build the quasi-inverse functors realising the `MCIL(ğ’) â‰… Mon(IL(ğ’))` equivalence: (a) from an interaction law, extract the monoid object (multiplication/unit) within `IL(ğ’)`; (b) from a monoid object, reconstruct `Ïˆ`; (c) verify functoriality on morphisms and provide oracles that certify the zig-zag identities up to equality in the category.
   - Implement the composite interaction-law constructor `composeInteractionLaws((Tâ‚, Dâ‚, Ïˆâ‚), (Tâ‚€, Dâ‚€, Ïˆâ‚€))`, ensuring the compatibility squares from the figure commute. Diagnostics must log the intermediate distributive-law lifts `Ïˆâ‚€^{Tâ‚}` and `Ïˆâ‚^{Dâ‚€}`, verify the canonical comparison maps `Tâ‚Tâ‚€X Ã— Dâ‚€Dâ‚Y â†’ Tâ‚X Ã— Dâ‚Y` and `TX Ã— DY â†’ X Ã— Y`, and store witnesses for each of the labelled sub-squares.
   - Define `freeInteractionLaw(F, G, Ïˆ)` that constructs the free/cofree pair `(F*, Gâ€ , Ïˆ')` by executing the coproduct recipe from the text, recording the injections used (`id Ã— fst`, `id Ã— snd`, etc.), and packaging the universal comparison maps into the resulting law. Expose helper constructors for the slice categories `MCIL(T, -)` and `MCIL(-, D)` that pin a monad or comonad and produce the canonical initial/final objects together with their universal arrows.
   - âœ… PassÂ 5 (PhaseÂ III) introduced `makeFreeMonadComonadInteractionLaw`, `deriveInitialMonadSliceObject`, and `deriveFinalComonadSliceObject`, storing coproduct inclusion metadata alongside the universal comparison arrays and wiring `checkFreeInteractionLaw` plus regression coverage to certify the recorded witnesses.
3. **Ïˆ-law coherence oracles and free objects.**
   - Introduce `checkMonadComonadInteractionLaw(law)` that verifies the four defining diagrams: (i) left unit (`Ïˆ âˆ˜ (Î· Ã— id) = âŸ¨id, ÎµâŸ©`), (ii) right counit, (iii) compatibility with `Î¼`/`Î´`, and (iv) the mixed associativity square; each check must return the concrete morphism witnesses obtained from the Day pairing carriers.
   - Extend `oracles/interaction-laws.ts` with logging of the sequential/behavioural interpretations and integrate ExampleÂ 6 as a canonical passing instance; include counterexample reconstruction when any diagram fails.
   - Add an oracle `checkFreeInteractionLaw` that reconstructs the coproduct-based definition of `Ïˆ'` and verifies that the resulting law is initial in `MCIL(T, -)` and final in `MCIL(-, D)` once the base category supplies initial algebras/final coalgebras. The oracle should expose the canonical morphisms from arbitrary laws into the free one (respectively from the free one into arbitrary laws) and verify the universal property via explicit comparison witnesses.
4. **ExampleÂ 14 quotient/Sweedler instrumentation.**
   - Provide constructors `nonemptyListFreeMonad()` and `nonemptyListQuotient()` that realise the free monad `Tâ‚€` on `F(X) = X + X Ã— X`, package the binary operation `c_X : X Ã— X â†’ Tâ‚€X`, and impose the associativity equation by forming the explicit coequaliser depicted in ExampleÂ 14. Record the universal arrows `q : Tâ‚€ â†’ T` and the witnesses for the generators/relations so diagnostics can recover the quotient presentation.
   - Implement `sweedlerDualNonemptyList()` that embeds the Sweedler dual `T^âˆ˜` into the cofree comonad on `G(Y) = Y + Y Ã— Y`, storing the subcomonad inclusion and the coequation of coassociativity `Î´^âˆ˜` shown in the example (with its iterated coproduct factors). Ensure the helper exposes the evaluation and coevaluation maps needed to compare with the generic Sweedler dual builder from PhaseÂ IIIa.
   - Extend the free/quotient oracle suite with `checkNonemptyListQuotient()` and `checkNonemptyListSweedler()` that replay the ExampleÂ 14 diagrams, verifying that the imposed associativity relation indeed yields the nonempty list monad and that the Sweedler dual inclusion preserves comultiplication/counit. Diagnostics must log the coproduct summands, the `c_X` composites, and the inclusion maps into the cofree comonad.
   - âœ… PassÂ 1 (PhaseÂ III follow-up) introduced `nonemptyListFreeMonad()` and `nonemptyListQuotient()`, materialising the ExampleÂ 14 free monad carriers, substitution-flattening multiplication, quotient map `q : Tâ‚€ â‡’ T`, and list-of-lists multiplication so later Sweedler/oracle work can reuse the recorded witnesses.
   - âœ… PassÂ 2 implemented `sweedlerDualNonemptyList()` together with `checkNonemptyListQuotient()` and `checkNonemptyListSweedler()`, recording the subcomonad inclusion, cofree witnesses, and Sweedler diagnostics needed for the ExampleÂ 14 rectangularity tooling.
5. **Associative binary-operation degeneracy tooling.**
   - Implement an oracle `checkAssociativeBinaryDegeneracy` that takes a monad operation `c_X : TX Ã— TX â†’ TX` and an interaction law `Ïˆ` and verifies TheoremÂ 3â€™s diagram by replaying the proofâ€™s three-stage composite: (i) build the distributivity square that turns `B Ã— Y` into the coproduct `Y + Y` with coprojections `Î¹_Y`, `Îº_Y`, (ii) pull `Î¸_{X,Y}` and `Î´_{X,Y}` back along those coprojections to obtain the intermediate morphisms `h_Y`, `k'_Y`, `k_Y`, and (iii) chase the big associativity diagram that compares `Ïˆ_{X,Y} âˆ˜ (c_X Ã— id)` to `Ïˆ_{X,Y} âˆ˜ (id Ã— D(c_Y)) âˆ˜ (id Ã— Ïˆ_{X,Y})` by enumerating the labelled arrows from the proof (the `Î¸`, `Î´`, `Î¼`, `Ïˆ`, and diagonal maps shown in the scanned figures).
   - Ensure the oracle logs each stage explicitly: report the reconstructed coproduct/pullback witnesses, list every intermediate morphism (`h_Y`, `k'_Y`, `k_Y`, the two maps out of `X Ã— X Ã— PY`), and capture the final calculation that chains `Ïˆ`, `c`, `Î¼`, and `Î´` so counterexamples point to the precise arrow where equality fails. Tie these diagnostics into PhaseÂ Ibâ€™s degeneracy metadata so constant-zero collapses are reported when the diagram forces them.
6. **TheoremÂ 4 rectangularity diagnostics.**
   - Implement a helper `coassociativityCoequation(D)` that materialises the coequation `DY \xrightarrow{Î´_Y} DDY â‡‰ D(Y + Y)` featured in TheoremÂ 4, *together with the pullback data used in the proof*: compute the pullbacks of `c_Y âˆ˜ Î´_Y` along the coproduct coprojections `inl_Y, inr_Y`, record the resulting objects `P_Y`, `Q_Y`, and store the induced inclusions `i_Y : P_Y â†’ DY`, `j_Y : Q_Y â†’ DY` plus the comparison maps `cÎ´_Y`, `cÎµ_Y` back into `DY + DY`. The helper must also register the distributivity map `DY â†’ D(Y + Y)`, the iterated coproduct legs (`DY â†’ DY + DY`, `(Y + Y) â†’ Y + Y + Y + Y`), and the coequaliser witness `g_Y` that identifies the two triangles highlighted in the scanned proof.
   - Add an oracle `checkRectangularityFromCoequation(D, data)` that verifies the left and right rectangular diagrams commute whenever the coassociativity coequation holds. The oracle should explicitly replay both proof steps: (i) use extensivity to show `(DY, i_Y, j_Y)` is the coproduct of `P_Y` and `Q_Y`, logging the stability-of-coproducts reasoning, and (ii) compare the two morphisms `(cÎµ_Y + Î´_Y) âˆ˜ cÎ´_Y` and `(Y + inr_Y) âˆ˜ cÎµ_Y` (respectively the dual pair for left rectangularity) by chasing them through the common coequaliser `g_Y`. Diagnostics must emit witnesses for each of the labelled arrows (`i_Y`, `j_Y`, `cÎ´_Y`, `cÎµ_Y`, `g_Y`, the pullback projections) and record the concluding equality `(Îµ_Y + id_Y) âˆ˜ cÎ´_Y = (id_Y + Îµ_Y) âˆ˜ cÎ´_Y` that realises right rectangularity.
   - Integrate this oracle with the Sweedler dual helpers so that when `T^âˆ˜` is constructed via ExampleÂ 14 the rectangularity diagnostics automatically certify the coassociativity constraints inherited from the cofree comonad, and ensure the log mentions how the same pullback argument delivers the left corectangularity equality.
   - âœ… PassÂ 6 derived `deriveNonemptyListCoequation()` for ExampleÂ 14, capturing the `P_Y`/`Q_Y` partitions, inclusions, and comparison maps `cÎ´_Y`, `cÎµ_Y`, together with the oracle `checkRectangularityFromCoequation` that confirms each Sweedler element lies in the recorded rectangular subcomonad. The regression suite now executes the oracle to certify the coequation/inclusion agreement.
   - âœ… PassÂ 7 introduced `deriveMonadComonadRunnerTranslation`, packaging Î¸, costate, and Sweedler-coalgebra translators with Î´-table diagnostics so runner construction can reuse the cached Day/Sweedler data. The regression suite verifies that ExampleÂ 6 reports consistent Î¸ tables and that sampling bounds surface in the recorded diagnostics.
7. **Structural operations for `MCIL(ğ’)`.**
   - Implement **stretching** for monadâ€“comonad interaction laws: given a monad morphism `f : (T, Î·, Î¼) â†’ (T', Î·', Î¼')` and a comonad morphism `g : (D, Îµ, Î´) â†’ (D', Îµ', Î´')`, construct `(T', D', Ïˆ')` with `Ïˆ' = (id Ã— g) âˆ˜ Ïˆ âˆ˜ (f Ã— id)` and verify the four Ïˆ-coherence diagrams using the morphism compatibility conditions.
   - Realise the **Day convolution product** of interaction laws by reusing the functor-level tensor from PhaseÂ I: build `(Tâ‚€ âŠ— Tâ‚, Dâ‚€ âŠ— Dâ‚, Ïˆâ‚€ âŠ— Ïˆâ‚)` with evaluation witnesses that project to each factor, and add oracles that check the resulting law satisfies the monad/comonad coherence squares.
   - Implement the **binary product** `((Tâ‚€, Dâ‚€, Ïˆâ‚€) Ã— (Tâ‚, Dâ‚, Ïˆâ‚))` using categorical products of monads/comonads when available, explicitly documenting the projection interaction laws and verifying their universal property via diagnostics.
   - Add constructors/oracles for **composite monad interaction laws**: given `Tâ‚€`, `Tâ‚`, a monadâ€“comonad law `(Tâ‚€, D, Ïˆâ‚€)`, and a monad interaction law `(Tâ‚, D, Ïˆâ‚)` satisfying the SectionÂ 3.3 commutation condition, produce `(Tâ‚ âˆ˜ Tâ‚€, D, Ïˆ)` and log the verification that the defining square commutes.
   - Extend testing to cover ExampleÂ 9â€™s collapse, the Day product, and the composite-monoid law, ensuring diagnostics expose any failure to meet the compatibility condition `(Î», id) âˆ˜ Ïˆâ‚€ = (id_{Tâ‚} Ã— Ïˆâ‚) âˆ˜ (Ïˆâ‚€ Ã— id_{Dâ‚})` highlighted in the raw material.
   - Add helper constructors that automatically supply `c_X` for associative monads encountered in the examples (e.g., writer/update monads) and record when the degeneracy condition collapses the interaction law to a trivial runner, storing the coproduct witnesses (`Î¹_Y`, `Îº_Y`) alongside the resulting zero maps for reuse in oracle output.
8. **Testing.**
   - Add `test/interaction-laws.spec.ts` covering (a) ExampleÂ 6, (b) a finite toy monad/comonad pair from existing infrastructure, and (c) a negative test where one coherence square is intentionally violated to ensure diagnostics surface the failing component.
   - Reuse degeneracy metadata from PhaseÂ Ib within the tests so nullary/binary collapses trigger construction of the final interaction law automatically when applicable.
   - Extend the spec suite with concrete runs of ExampleÂ 7, ExampleÂ 8, and an associative-operation scenario to ensure TheoremÂ 3â€™s oracle surfaces the expected behaviour and to validate the `MCIL(ğ’) â†” Mon(IL(ğ’))` translators.
   - Add regression coverage for `composeInteractionLaws` (checking each labelled sub-square and the overall composite square) and for `freeInteractionLaw`, including explicit verification of the initial/final universal properties in the slice categories `MCIL(T, -)` and `MCIL(-, D)` via constructed comparison morphisms.
9. **Documentation and LAWS.md integration.**
   - Expand `LAWS.md` with a dedicated â€œMonadâ€“Comonad Interaction Lawsâ€ entry summarising the Ïˆ definition, the four coherence diagrams, ExampleÂ 6, and the associated oracle/test suite.
   - Document how the monoid/comonoid packaging aligns with Hasegawaâ€™s glueing, the `MCIL(ğ’) â‰… Mon(IL(ğ’))` equivalence (including diagnostic hooks), the associative binary-operation degeneracy oracle, and note the entry points for stateful runners so future phases can wire in residual extensions.

## 4. Phase IV â€” Stateful Runners and Residual Interaction Laws
### Goals
- Internalise **DefinitionÂ 2.2** (Runners for a signature): for each algebraic signature `Î£ = {op}` with parameter object `A_op` and result object `B_op`, a runner consists of a carrier set `|â„›|` together with co-operations `op_â„› : A_op Ã— |â„›| â†’ B_op Ã— |â„›|` (equivalently, curried maps `A_op â†’ |â„›| â†’ B_op Ã— |â„›|`) that determine how the runtime configuration evolves when an operation `op(a, k)` reaches the top level. Record explicitly that, given configuration `c âˆˆ |â„›|`, the co-operation returns a pair `(b, c')` with the updated configuration `c'`, and the continuation proceeds in state `c'`. Note that runners for full theories `ğ’¯` arise when the co-operations also satisfy the equational theory `Eq_ğ’¯`â€”useful later for homomorphic interaction-law definitions even if the current phase focuses on signaturesâ€”and that DefinitionÂ 2.2 packages these co-operations into the monad morphism `Ï_T : Tree_Î£ â‡’ St_{|â„›|}` granted by the universal property of the free `Î£`-monad. **PropositionÂ 3** then states that monad morphisms `Tree_Î£ â‡’ T` are in one-to-one correspondence with `T`-runners for `Î£`; ensure the roadmap requires us to construct both directions explicitly (co-operations from a monad map and the monad map from co-operations) and to cache the family `Ï_{T,X}` arising from structural recursion on computation trees.
- Internalise **DefinitionÂ 4.1**: a stateful runner of a monad `T = (T, Î·, Î¼)` is an object `Y` equipped with a family of morphisms `Î¸^X_Y : TX Ã— Y â†’ X Ã— Y`, natural in `X`, satisfying the two runner axioms from the paper (unit compatibility `(Î·_X Ã— id_Y); Î¸^X_Y = âŸ¨id_X, id_YâŸ©` and multiplication compatibility `(Î¼_X Ã— id_Y); Î¸^X_Y = (TX Ã— Î¸^X_Y); Î¸^{TX}_Y`).
- Inline SectionÂ 2.1â€™s **algebraic effects and handlers** vocabulary so the runner workstreams have concrete data to manipulate: an algebraic signature `Î£_T = (A_{op}, B_{op})` listing operation arities together with the tree-forming constructors `op : Tree_Î£(X)^A_op â†’ Tree_Î£(X)^B_op`, an `S`-structure `(M, âŸ¨m_opâŸ©)` interpreting each operation `op` as a map `A_op Ã— M^{B_op} â†’ M`, and the induced algebraic theory `(Î£_T, E_T)` whose equations capture substitution compatibility. Ensure ExampleÂ 1â€™s state signature with operations `getenv : 1 â‡€ C` and `setenv : C â‡€ 1` (and the displayed equations that return the current state or overwrite it) is recorded verbatim so later phases can reuse the concrete terms and laws without consulting the source paper.
- Integrate **SectionÂ 3.1â€™s user/kernel split**: describe kernels as monads generated by a stateful signature extending `{getenv, setenv}` with any external-effect signature `Î£` so that their runners satisfy the three desiderata spelled out in the excerptâ€”(1) resource management and controlled finalisation, (2) ability to invoke further external resources, and (3) a failure channel for unavoidable errors. Encode the additional operations precisely as in the text: adjoin **exceptions** `raise : E â†’ 1` via coproduct with the state theory, add **signals** `kill : S â†’ 0` via the tensor with state, and record the displayed equations `getenv(Î»c. kill_s(c)) = kill_s` and `setenv(c, kill_s) = kill_s` showing that signals discard state entirely. Summarise the resulting kernel theory `K_{Î£,E,S,C}` as containing the `Î£`-operations, the state operations from ExampleÂ 1, the exception nullaries, and the signal nullaries. Ensure the plan records that the same Î£-operations may be reused by outer layers of runners and that user code interacts with these kernel monads through supervised access rather than direct state manipulation.
- Capture the complementary **user theory** `U_{Î£,E,X}` chosen in the excerpt: user code calls operations from `Î£`, relies on supervised access to the kernel state, can raise and catch the kernelâ€™s recoverable exceptions, but only observes fatal signals as runtime termination. Require the roadmap to retain the induced user monad (free algebra on `U_{Î£,E,X}`) together with the comparison morphisms into the kernel monad so later phases can model supervised effect boundaries directly.
- Reproduce the **Î»_{coop} calculus** used in *Runners in Action*: model operation signatures, effect resources, and the syntactic forms `with open`, `try â€¦ finally â€¦`, and `handle t with k` so the roadmap can tie categorical runners to the operational intuition of the paperâ€™s introduction. Capture the promise of linear resource management (every opened handle is closed) and make space for effect-polymorphic handlers that dispatch on operations like `open`, `read`, and `close`.
- Inline **SectionÂ 4.2â€™s â€œValues and computationsâ€** presentation so the roadmap keeps the concrete syntax in scope without consulting the source: values are variables, ground constants, `()` for unit, pairs `(V, W)`, injections `inl_X V`/`inr_X V`, user abstractions `fun (x : X) â†¦ M`, kernel abstractions `funK (x : X) â†¦ K`, and runner literals `{ (op x â†¦ K_{op})_{op âˆˆ Î£} }^C` whose annotation `C` pins down the kernel state type that the bound computations `K_{op}` expect. Record that user computations `M, N` and kernel computations `K, L` share the usual pure terms and function application, but differ in their operation-call annotations: user calls are written `op_X^C(V; Îº)` with result type `X`, whereas kernel calls carry both result and state annotations `op_X^C(V; Îº)` plus explicit kernel-continuation types. Preserve the textâ€™s note that annotations can be dropped when unambiguous, and that the binding form `let_{X,E} x = M in N` abbreviates a user `try` that routes the return case to `N` and each exception `e âˆˆ E` to `raise_X e`, with a dual kernel abbreviation.
- Inline the **type grammar from FigureÂ 1** of the calculus: ground types built from base types (`unit`, `empty`, sums, products), value types including runner/function types (`X â†¦ Y`, `X â†¦ Y | u`, `X â†¦ Y | k`), and kernel computation types `X ! {Îº | Î£, E, S, C}` that record available co-operations, signals, and state components. Ensure the roadmap requires constructors for constant signatures `f : (A_1, â€¦, A_n) â†¦ B`, operation signatures `op : Î£` with their arity objects, and signal sets `S_op` so later passes can perform type-directed resource analysis.
- Restate **SectionÂ 4.3â€™s typing judgement vocabulary** so it is self-contained: contexts `Î“ = x_1 : X_1, â€¦, x_n : X_n`, value judgements `Î“ âŠ¢ V : X`, user computation judgements `Î“ âŠ¢ M : X ! (Î£, E, S, C)`, and kernel computation judgements `Î“ âŠ¢ K : Y ! (Î£, E, S, C)` with explicit annotations for implemented operations `Î£`, recoverable exceptions `E`, signals `S`, and state object `C`.
- Record the **subtyping rules of FigureÂ 3** verbatim to guide implementation: `Sub-Ground` (any ground type `A âˆˆ ğ”„` satisfies `Î“ âŠ¢ A â‰¤ A`), `Sub-Runner` (widening runner capabilities requires supersets of implemented operations/state, i.e. `(Î£ âŠ† Î£', S âŠ† S', C âŠ‘ C') â‡’ Î“ âŠ¢ runner(Î£, S, C) â‰¤ runner(Î£', S', C')`), and `Sub-Kernel` (kernel computation types may only widen when both their runner annotations and failure metadata are extended appropriately). Emphasise that these are the only subtyping axioms; all other comparisons must be derived from them.
- Capture the **typing rules from FigureÂ 3** explicitly so they can be encoded without reconsulting the paper: `TyUser-Op` for user operation invocations (requiring the continuation runner to implement the operation), `TyKernel-Op` for kernel operation calls with explicit state transitions, `TyUser-Try` for `try`/`raise` blocks with per-exception branches, `TyUser-Run` enforcing that supplied runners implement every operation mentioned in the ambient signature block `F`, and the cross-mode rules `TyUser-Kernel`/`TyKernel-User` that shuttle computations between user and kernel layers while preserving annotations. Note that each rule carries an explicit `Î£`, `E`, `S`, `C`, and (for `TyUser-Run`) a success continuation `M` plus handler bundle `(raise e â†¦ N_e)_{eâˆˆE}`â€”all of which must be stored for diagnostics.
- Restate **SectionÂ 4.4â€™s equational theory** verbatim so the roadmap no longer depends on the source: specify three equality judgements `Î“ âŠ¢ V = V' : X` (values), `Î“ âŠ¢ M = N : X ! K` (user computations), and `Î“ âŠ¢ K = L : X ! K` (kernel computations). Record the runner-facing equations, including `run (return V) finally F = return V`, `run (raise^C_E e) finally F = raise^C_E e`, `run (kill^C_S s) finally F = kill^C_S s`, `run (op_X^C(V; Îº)) finally F = K_{op}[V/x, Îº'/k]` with kernel continuations wrapped in kernel mode, and `run (with K) finally F = with (run K finally F)` so that finalisation blocks commute with kernel execution. Capture the kernel-mode rules mirrored in the textâ€”for the bundle `{return x â†¦ K, (op z â†¦ K_{op})_{opâˆˆÎ£}}^C`, execution of `op_X^C(V; Îº)` produces `K_{op}[V/x, Îº/k]`, `return` threads the continuation through the finaliser, and `kill` discards itâ€”alongside the Î²/Î· laws for exceptions, reconstruction rules for `try`/`with`, and the `let_{X,E}` abbreviation. These equations will anchor the interpreterâ€™s rewrite system and the diagnostics required later in this phase.
- Contrast runners with **handlers** exactly as described beneath equationÂ (7): a handler is a multiplication algebra `(Z, Î±)` with `Î± : TZ â†’ Z` obeying `Î± âˆ˜ Î·_Z = id_Z` and `Î± âˆ˜ Î¼_Z = Î± âˆ˜ TÎ±`. The plan must retain these equations verbatim so the implementation can reconstruct diagramÂ (7) and verify that every runner induces a handler via `Î¸^Z_Y` when `Y` is terminal, and conversely detect when a handler extends to a runner via the state monad construction.
- Treat runner morphisms explicitly: a runner map `f : (Y, Î¸) â†’ (Y', Î¸')` must satisfy `(id_X Ã— f) âˆ˜ Î¸^X_Y = Î¸'^X_{Y'} âˆ˜ (id_{TX} Ã— f)` for every `X`, and these maps form the morphisms of the **`Run(T)`** category.
- Capture the **coalgebraic reformulation** supplied in the new material: runner maps are coalgebra maps between the induced `TÂ°`-coalgebras `(Y, Î³)` and `(Y', Î³')`, so the plan must store the natural transformation `Î³_X : TY Ã— X â†’ X Ã— Y` associated with each runner and reconstruct the commutative square labelled `(4)` even though `TÂ°` is only lax-comonadic (its multiplication `m_{TÂ°}` is typically non-invertible).
- Record the **costate comonad** viewpoint verbatim: for every object `Y`, `Cost^Y(Z) = (Y â‡’ Z) Ã— Y` with counit `Îµ^Y(f, y) = f(y)` and comultiplication `Î´^Y(f, y) = (f, y)`. The plan must require runners to be equivalent to natural transformations `Î³ : Cost^Y â‡’ T` that satisfy the diagram `(5)` from the excerpt and treat these `Î³`â€™s as first-class witnesses alongside `Î¸`.
- Summarise the isomorphic categories enumerated beneath equation `(5)`â€”runners of `T`, natural maps from `T` to `St^Y`, `TÂ°`-coalgebras obeying `(4)`, natural transformations `Cost^Y â‡’ T` obeying `(5)`, comonad coalgebras of `Cost^T`, and coalgebras of the Sweedler dual `T^âˆ˜`â€”and ensure the implementation roadmap provides concrete translators and diagnostics for each equivalence.
- Relate runners to interaction laws and Sweedler duals: reproduce the bijection between stateful runners, monadâ€“comonad interaction laws `(T, D, Ïˆ)`, and coalgebraic runner specs as described in SectionÂ 4.2, including the explicit formulas turning a `Ïˆ` into a runner and back (restricting along the cofree coalgebra and Day convolution fibres).
- Re-state the concluding observation that the **handler-induced runner map** and the **state runner map** both collapse to the evaluation morphism `ev_Y : TÂ°Y Ã— Y â†’ Y`; ensure the roadmap requires explicit witnesses that `Î¸^X_Y` factors through this evaluation when translated via the `TÂ°`-coalgebra/Costate equivalences.
- Encode **ExampleÂ 12** in detail: update lenses `(hp : Y â†’ A, upd : Y Ã— B â†’ Y)` give rise to runners of the update monad `TX = A â‡’ (B Ã— X)`; plan reusable constructors/oracles that witness the bijection between update lenses, runners, `Cost^Y`-transformations, and coalgebras.
- Extend the planâ€™s residual-law preparation so machines that only realise a subset of effects are modelled via partial runners, keeping compatibility with the nullary/binary degeneracy metadata gathered in PhasesÂ Ibâ€“III.

### Tasks
0. **Algebraic signatures, theories, and ExampleÂ 1.**
   - Create a shared module (e.g., `algebraic-effects.ts`) that encodes algebraic signatures `Î£ = {op}` with parameter objects `A_op`, continuation result sets `B_op`, and the induced computation tree functor `Tree_Î£`. Provide constructors that store both the operation metadata and the tree-forming constructors mentioned in the excerpt so substitution and Kleisli reasoning can reference them directly.
- Extend the signature module with explicit runner co-operations: for every runner carrier `|â„›|`, represent the structure maps `op_â„› : A_op Ã— |â„›| â†’ B_op Ã— |â„›|`, cache their curried forms `A_op â†’ |â„›| â†’ B_op Ã— |â„›|`, and supply utilities that, given an operation `op(a, k)` and configuration `c`, compute the updated configuration `(b, c')` and resume the continuation `k(b)` in state `c'`. Ensure diagnostics record both the uncurried and curried witnesses so later phases can compare them against the DefinitionÂ 4.1 `Î¸`-maps, and reconstruct the associated free-monad morphism component `Ï_{T,X} : Tree_Î£(X) â†’ St_{|â„›|}(X)` by structural recursion on trees (return nodes, operation nodes) to honour the universal property captured in the excerpt.
- Provide explicit translators promised by **PropositionÂ 3**: implement `runnerToMonadMap` and `monadMapToRunner` so that, for every signature `Î£` and monad `T`, we can toggle between a `T`-runner and a monad morphism `Tree_Î£ â‡’ T`; equip the translators with diagnostics proving they are mutual inverses by replaying the recursive clauses on generators (return, operation) spelled out in the proof.
   - Define `S`-structures `(M, âŸ¨m_opâŸ©)` as records assigning to each operation a morphism `m_op : A_op Ã— M^{B_op} â†’ M`, bundle the associated algebraic theory `(Î£, E)` equations, and expose helpers that translate these structures into monads/handlers used elsewhere in the roadmap.
   - Materialise ExampleÂ 1â€™s theory of `C`-valued state explicitly: implement operations `getenv : 1 â†’ C` and `setenv : C â†’ 1` together with the three equations spelled out in the excerptâ€”reading immediately after a `setenv` returns the continuation unchanged, consecutive `setenv` calls collapse to the most recent update, and `setenv` overwrites the stored state. Provide diagnostics that replay each law using the algebraic-structure helpers so the plan carries runnable witnesses of the state theory.
- Extend the module with **ExampleÂ 2â€™s exceptions theory** by introducing nullary operations `raise_e` for each `e âˆˆ E`, constructing the term algebra `Tree_{Î£_T}(X)` of well-founded computation trees, and quotienting by the congruence `â‰ˆ` generated by `Eq_T` to obtain `Free_T(X)`. Implement the Kleisli extension `f^â€ ` exactly as in the excerpt, ensure the `return`/`op` rewrite rules are stored alongside diagnostics, and build helpers that realise handlers as the unique `T`-homomorphisms `Free_T(X) â†’ M` given a model `(M, âŸ¨m_opâŸ©)`. Add regression targets that compare the induced monad with the textbook exceptions monad `Exc_E(X) â‰… X + E` and replay the state example `St_C(X) â‰… (C Ã— X)^C` for contrast.
- Build on the preceding theory module to materialise the **kernel monad** `K_{Î£,E,S,C}` by first forming the coproduct of the state theory with the exception theory (adding operations `raise_e`) and then tensoring with the signal theory (operations `kill_s`). Record the displayed equations `getenv(Î»c. kill_s(c)) = kill_s` and `setenv(c, kill_s) = kill_s`, and provide constructors that assemble the free algebra on this combined theory into the monad used for kernel code. Cache the canonical inclusions of `Î£`, state, exception, and signal operations so diagnostics can report how each component contributes to a runner.
- Define the **user monad** `U_{Î£,E,X}` as the free algebra on the user theory `U_{Î£,E,X}` described aboveâ€”operations from `Î£`, access to recoverable exceptions, but no direct state manipulationâ€”and expose comparison morphisms into the kernel monad (e.g., `Î¹_user : U_{Î£,E,X} â‡’ K_{Î£,E,S,C}`) that witness supervised execution. Require regression artefacts that replay the motivating examples (user/kernel, browser/web page, OS/hardware) and log how user computations invoke kernel operations solely through these morphisms.

1. **Î»_{coop} front end and examples.**
   - **Type system core.** Implement the FigureÂ 3 subtyping relation (`Sub-Ground`, `Sub-Runner`, `Sub-Kernel`) as first-class data structures with proof witnesses, and add diagnostics that refuse invalid widening attempts when operation/state annotations shrink.
   - **Typing derivations.** Encode each FigureÂ 3 typing rule as a constructor that consumes proofs of its premises and emits a structured derivation object. Provide helper functions such as `deriveUserOp`, `deriveKernelOp`, `deriveUserRun`, and `deriveUserTry` that mirror the rule names, log the annotations they consume (`Î£`, `E`, `S`, `C`, runner block `F`, success continuation), and store traces of the resulting judgement for later oracle replay.
   - Introduce a syntactic layer `lambda-coop.ts` that codifies the basic forms described in the paperâ€™s introduction: resource declarations, command sequencing, the `using` block that ensures finalisation, and handler definitions with operation clauses `op x k â†¦ body`. Ensure the syntax supports the examples `with open "hello.txt" in â€¦ finally close` and the nondeterministic handler shown in the excerpt.
   - Provide an operational semantics driver that interprets Î»_{coop} phrases into monad computations guarded by runner maps: mimic the evaluation order that opens a file, writes to it, and guarantees the finaliser executes even when handlers branch nondeterministically.
   - Add regression examples that replay the â€œvirtual machineâ€ intuition from the introduction: a runner that exposes a restricted subset of operations (`{open, write, close}`), a computation that interleaves them, and diagnostics confirming the finaliser runs exactly once per acquired resource.
   - Extend the AST with the SectionÂ 3.2 syntactic categoriesâ€”distinguish user computations (`M, N`), kernel computations (`K, L`), and values (`V, W`)â€”so type checkers and interpreters can enforce the separation at compile time.
   - Implement the SectionÂ 4.2 value forms verbatim: variables, ground constants, unit `()`, pairs `(V, W)`, injections `inl_X V`/`inr_X V`, user abstractions `fun (x : X) â†¦ M`, kernel abstractions `funK (x : X) â†¦ K`, and runner literals `{ (op x â†¦ K_{op})_{op âˆˆ Î£} }^C`. Track the runner annotation `C` in the AST so later phases know which kernel state object each co-operation expects.
   - Implement the FigureÂ 1 type grammar: add constructors for base types (`unit`, `empty`), sum/product types, signature types `f : (A_1, â€¦, A_n) â†¦ B`, operation signatures `op : Î£`, signal sets `S_op`, user/kernelfunction types (`X â†’ Y`, `X â‡€ Y`, `X â‡’ Y` with runner annotations), and kernel computation types `X ! {Îº | Î£, E, S, C}` that bundle the available co-operations, exception family, signal family, and state object. Equip the type checker with resource-accounting metadata (which signatures, signals, and state components a term depends on) to prepare for the supervised-type analysis promised later in the paper.
   - Encode the user/kernel computation forms highlighted in SectionÂ 4.2: pure return `return_X V`, application `M V`/`K V`, exception raising `raise_X e`, user `try`/kernel `try` with per-exception branches, and operation invocations that carry explicit annotations (user: `op_X^C(V; Îº)`, kernel: `op_X^{C,S}(V; Îº)` with the state update type). Ensure kernel operation nodes record both the result type `X` and the kernel state type `C`, while user operation nodes remember the supervised continuation type.
   - Encode the Bentonâ€“Kennedy style exceptional syntax from SectionÂ 3.2: supply constructors for user-level `try M with { return x â†¦ N_return, raise e â†¦ N_raise(e) }` and kernel-level `try K with { return x â†¦ L_return, raise e â†¦ L_raise(e) }`, threading both the return continuation and the per-exception handlers through the AST.
   - Add explicit support for the `let_{X,E} x = M in N` abbreviation (and its kernel analogue): implement desugaring routines that translate the notation into the corresponding `try`/`raise` forms, and surface diagnostics reminding callers that annotations may be omitted when type inference can recover them.
   - Update the small-step semantics so user `try` blocks delegate to kernel handlers as described: raising within user code triggers the kernel branch, while kernel raises propagate through the supervised environment. Log diagnostics that show the return branch performs the promised resource finalisation exactly once.

2. **Runner data types and helpers.**
   - Introduce `StatefulRunner<T>` storing the carrier object `Y`, the natural family `Î¸^X_Y`, the associated `TÂ°`-coalgebra structure `Î³_Y : Y â†’ TÂ°Y`, and cached witnesses that the DefinitionÂ 4.1 diagrams commute; add helper constructors that derive `Î¸` from a monadâ€“comonad interaction law `Ïˆ` via `Î¸^X_Y := Ïˆ_{X,Y}` specialised to the machine comonad states.
   - Provide utilities `runnerUnitDiagram` and `runnerMultiplicationDiagram` that rebuild the two axioms for diagnostics, logging each morphism in the string diagrams shown in the excerpt, together with a `runnerCoalgebraDiagram` checker that verifies equation `(4)` by comparing `TÂ°(f)` against `Î³' âˆ˜ f` and explicitly recovering the evaluation morphism `ev_Y` when `Î¸^X_Y` is post-composed with the canonical projection `TX Ã— DY â†’ TÂ°Y Ã— Y`.
3. **Handler comparison and state monad maps.**
   - Model handlers explicitly as multiplication algebras `(Z, Î±)` with `Î± : TZ â†’ Z` satisfying equationÂ (7); supply constructors `makeHandler(Z, Î±)` that store witnesses for the unit and associativity equalities `Î± âˆ˜ Î·_Z = id_Z` and `Î± âˆ˜ Î¼_Z = Î± âˆ˜ TÎ±`.
   - Implement translators between handlers and runners when `Y` is terminal: given `Î¸`, construct the induced handler `Î± := Ï€_1 âˆ˜ Î¸^Z_Y âˆ˜ âŸ¨Î·_Z, !âŸ©`; conversely, given a handler, detect whether there exists `Y` and `Ï‘ : T â‡’ St^Y` extending it to a runner, replaying the ExampleÂ 2 universal-property equations `h^â€ [return x] = h(x)` and `h^â€ [op(a, k)] = m_op(a, Î»x. h^â€ (k(x)))` when building the associated `T`-homomorphism.
   - Recreate the **runner-as-monad-map** diagram from the â€œRunners vs. handlersâ€ section: verify that a natural transformation `Ï‘ : T â‡’ St^Y` satisfies `(St^Y Î¼_X) âˆ˜ Ï‘_{TX} = (St^Y Ï‘_X) âˆ˜ Ï‘_{St^Y X} âˆ˜ TÏ‘_X` and `(St^Y Î·_X) âˆ˜ Ï‘_X = Î·^{St^Y}_X`, logging each component of the diagram displayed beneath equationÂ (7). Diagnostics must record counterexamples whenever the monad-map equalities fail.
   - Provide an oracle `compareHandlerAndRunner` that, given `Î¸` and `Î±`, checks whether they correspond under the above translations and highlights missing state data when a handler cannot be lifted to a runner.
4. **Category `Run(T)`.**
   - Implement runner morphisms `makeRunnerMap(f, Î¸, Î¸')` and an equality checker that validates `(id_X Ã— f) âˆ˜ Î¸^X_Y = Î¸'^X_{Y'} âˆ˜ (id_{TX} Ã— f)` objectwise while simultaneously confirming the coalgebra condition `(TÂ° f) âˆ˜ Î³ = Î³' âˆ˜ f`; expose `identityRunnerMap` and `composeRunnerMaps` to show `StatefulRunner<T>` objects with these morphisms form a category.
   - Add an oracle `checkRunnerCategory` that enumerates representative objects/arrows, confirming associativity/unitality of composition, reporting counterexamples with the offending `X`, and logging whether any coalgebra square fails.
5. **Costate comonad translators.**
   - Implement constructors `costateComonad(Y)` and utilities `runnerToCostateTransformation`/`costateTransformationToRunner` that encode natural transformations `Î³ : Cost^Y â‡’ T` obeying diagram `(5)`; include diagnostics that reconstruct `(5)` explicitly using the evaluation map `Îµ^Y` and the diagonal `Î´^Y`.
   - Provide a `checkCostateCondition` oracle that replays equation `(5)` and reports the exact component morphisms when it fails.
6. **Equivalences with interaction laws and dual coalgebras.**
   - Define translators `runnerFromInteractionLaw(T, D, Ïˆ)` and `interactionLawFromRunner(T, Î¸)` that materialise the equivalence between `Ïˆ`-families and runners, reusing the Sweedler dual adapters from PhaseÂ IIIa to express the same data as coalgebras `Î³ : Y â†’ TÂ°Y` and logging how the induced `Î¸^X_Y` factors through the shared evaluation map `ev_Y`.
   - Supply inverse translators and structured diagnostics proving the zig-zag equalities, including the factorisation `DY â‰… TÂ°Y` promised in the excerpt and the remark that runners of `T` correspond to coalgebras of the comonad `Cost^T`.
7. **Category-level isomorphisms.**
   - Build explicit quasi-inverse functors demonstrating the six-way equivalence highlighted under the new material: `Run(T)`, the category of natural maps `T â‡’ St^Y`, the subcategory of `TÂ°`-coalgebras satisfying `(4)`, the category of costate transformations `(Cost^Y â‡’ T)` satisfying `(5)`, comonad coalgebras of `Cost^T`, and coalgebras of the Sweedler dual `T^âˆ˜`.
   - Attach oracles that confirm each functor preserves identities/composition and emits witness data (e.g., the natural transformation components `Î¸`, `Î³`, costate morphisms) when the verification succeeds.
8. **ExampleÂ 12 toolkit.**
   - Package update-lens data `(hp, upd)` into a concrete runner via the formula `Î¸^X_Y(f, y) = let (b, x) = f(hp(y)); (x, upd(y, b))`, verify the runner axioms, reconstruct the corresponding costate transformation and `TÂ°`-coalgebra, and expose conversions back to update lenses and comonad coalgebras as described in the text.
   - Add regression tasks ensuring the bijection between runners of the update monad, costate transformations, and coalgebras of `DM = A Ã— (B â‡’ -)` is executable and yields the promised isomorphism of categories.
9. **Residual interaction hooks.**
   - Extend `FunctorInteractionLaw`/`StatefulRunner` records with residual-evaluator slots that store partial effect handlers (when `Î¸` is defined only on a subobject of `TX Ã— Y`), plus diagnostics that note which effects are unsupported.
   - Implement `makeResidualInteractionLaw`/`attachRunner` constructors that now return structured TODO diagnostics summarising the missing witnesses (instead of empty placeholders), referencing SectionsÂ 4â€“5 to guide future work.
10. **Oracles and documentation.**
   - Create `checkStatefulRunner` returning detailed pass/fail information for the DefinitionÂ 4.1 diagrams, the runner-map equation, the coalgebraic diagrams `(4)`/`(5)`, and the evaluation collapse `Î¸^X_Y = ev_Y âˆ˜ âŸ¨Î³_Y, id_YâŸ©`; integrate it with `checkMonadComonadInteractionLaw` so interaction laws automatically surface their associated runners.
   - Update `LAWS.md` with a â€œStateful Runnersâ€ entry outlining the definition, the `Run(T)` category, the six-way categorical equivalence, ExampleÂ 12â€™s update lens correspondence, and pointers to the new translators/oracles.
   - Add planning tests that cover at least one successful runner (ExampleÂ 12) and one failing morphism, ensuring diagnostics identify whether the failure comes from DefinitionÂ 4.1, equation `(4)`, or equation `(5)`.

### PhaseÂ IVb â€” R-residual Stateful Runners (SectionÂ 5.3)
#### Goals
- Restate SectionÂ 5.3â€™s generalisation verbatim: fix a **residual monad** `R = (R, Î·^R, Î¼^R)` on `ğ’`. An **`R`-residual runner** of a monad `T = (T, Î·, Î¼)` is an object `Y` equipped with a natural family of arrows
  
  `Î¸^X_Y : TX Ã— Y â†’ R(X Ã— Y)`
  
  satisfying the runner axioms lifted through `R`:
  - **Unit compatibility:** `(Î·_X Ã— id_Y); Î¸^X_Y = Î·^R_{X Ã— Y} âˆ˜ âŸ¨id_X, id_YâŸ©`.
  - **Multiplication compatibility:** `(Î¼_X Ã— id_Y); Î¸^X_Y = (TX Ã— Î¸^X_Y); Î¸^{TX}_Y` followed by the residual monadâ€™s multiplication `Î¼^R_{X Ã— Y}` (as shown in the excerptâ€™s displayed equation).
- Capture the morphism condition verbatim: a map of `R`-residual runners `f : (Y, Î¸) â†’ (Y', Î¸')` must satisfy
  
  `(id_{TX} Ã— f); Î¸'^X_{Y'} = Î¸^X_Y; R(id_X Ã— f)`
  
  for every `X`, i.e. the square with top arrow `Î¸^X_Y`, bottom arrow `Î¸'^X_{Y'}`, left leg `id_{TX} Ã— f`, and right leg `R(id_X Ã— f)` commutes.
- Record that these structures form the category **`Run_R(T)`**, whose objects are residual runners and whose morphisms are the maps described above.
- Internalise the stated isomorphism of categories: `Run_R(T)` is equivalent to the category of objects `Y` endowed with a monad map `Ï‘ : T â‡’ S^{t,Y}_R`, where `S^{t,Y}_R(X) = R(X Ã— Y)` is the **`R`-transformed state monad**. The plan must capture the bijection between the natural transformations `Î¸^X_Y` and the monad-map components `Ï‘_X : TX â†’ R(X Ã— Y)` (with their commutative triangles).
- Prepare to extend the residual/stateful bridge: ensure later residual interaction laws (PhaseÂ V) can restrict to `R`-residual runners via the same `Î¸/Ï‘` data and that diagnostics retain Kleisli-pure annotations introduced earlier.

#### Tasks
1. **Residual runner data types.**
   - Define `ResidualStatefulRunner<T, R>` storing `Y`, the family `Î¸^X_Y`, and cached witnesses for the two `R`-lifted diagrams (unit/multiplication with `Î·^R`/`Î¼^R`).
   - Provide constructors that derive `Î¸` from monad maps `Ï‘ : T â‡’ S^{t,Y}_R`, reusing the residual law infrastructure to ensure the components align with `Î¸^X_Y` after precomposition with the canonical pairing `TX Ã— Y â†’ TX Ã— Y`.
   - Extend the earlier `StatefulRunner` helpers so choosing `R = Id` recovers the ordinary runners (unit/multiplication diagrams reduce to those in DefinitionÂ 4.1).
2. **Morphisms and category structure.**
   - Implement `makeResidualRunnerMap(f)` that verifies the commutative square `(id_{TX} Ã— f); Î¸'^X_{Y'} = Î¸^X_Y; R(id_X Ã— f)` for representative `X`, logging the `R`-application morphisms `R(id_X Ã— f)` as part of the diagnostics.
   - Supply `identityResidualRunnerMap`, `composeResidualRunnerMaps`, and a `checkResidualRunnerCategory` oracle confirming `Run_R(T)`â€™s categorical laws (composition respects the residual condition, associativity/unitality hold, and counterexamples report the failing `X`).
3. **Equivalence with monad maps.**
   - Build translators `residualRunnerToMonadMap` and `monadMapToResidualRunner` that implement the bijection with monad maps into `S^{t,Y}_R`, explicitly reconstructing the triangles involving `Î·`, `Î·^R`, `Î¼`, and `Î¼^R` that certify `Ï‘` is a monad morphism.
   - Add diagnostics mirroring the excerptâ€™s note about natural transformations `Î¸_{X,Y}`: log the component morphisms `Î¸^X_Y` and `Ï‘_X`, verify naturality in `X`, and retain witnesses for the equality `Ï‘_X = Î¸^X_Y âˆ˜ âŸ¨id_{TX}, id_YâŸ©`.
4. **Integration with residual interaction laws.**
   - Update the PhaseÂ V preparation hooks so a residual interaction law `(F, G, Ï)` can induce `R`-residual runners by specialising to a fixed machine object `Y`, with diagnostics that compare the induced `Î¸` against the `Ï` components via the evaluation map `GY â†’ Y`.
   - Ensure Kleisli-pure annotations propagate: when a residual runner is obtained from a law that only satisfies the second diagram on pure arrows, store this metadata on the runner so subsequent checks can enforce the same restriction.
5. **Documentation and testing.**
   - Extend the planned `LAWS.md` update with an â€œ`R`-residual runnersâ€ subsection quoting the precise formulas for `Î¸`, the morphism square, and the equivalence with monad maps `Ï‘`.
   - Add regression tasks for a toy residual monad (e.g., `R X = X + E`) demonstrating an `R`-residual runner, its associated monad map, and a morphism that fails the `R(id_X Ã— f)` condition, emitting the detailed diagnostics captured above.

## 5. Phase V â€” Residual Interaction Laws (SectionÂ 5)
### Goals
- Restate SectionÂ 5â€™s **residual interaction** setup verbatim: fix an endofunctor `R` on the base category and a family of natural maps `Ï_{X,Y} : FX Ã— GY â†’ R(X Ã— Y)` that witnesses how much of the computation is handled by the machine versus deferred to `R`.
- Transcribe the two commutative diagrams that define an `R`-residual functorâ€“functor interaction law exactly as shown in the excerptâ€”one comparing `Ï_{X,Y}` with the canonical map `FX Ã— GY â†’ F(X Ã— Y) â†’ R(X Ã— Y)` (the â€œfirst conditionâ€ diagram with arrows labelled `Ï†_{X,Y}`, `Rm^F_{X,Y}`, `Rm^G_{X,Y}`, and the Day-tensor comparison) and the other comparing `Ï_{X,Y}` with the factorisation through `RX Ã— GY`â€”so that they can be executed as oracle checks, complete with the composites `h_Y`, `k'_Y`, and `k_Y` that appear in the proof sketch.
- Note explicitly that the paper proves the first condition implies the second when the right-hand morphism factors through the Kleisli inclusion `J : ğ’ â†’ Kl(R)` (so `â„“ = Jg = Î·_Y âˆ˜ g`); ensure the roadmap captures this â€œpure mapâ€ relaxation so diagnostics can surface when the second diagram is only demanded on Kleisli-pure arrows.
- Capture that such laws form a monoidal category `IL_R(ğ’)` whose monoid objects are precisely the `R`-residual monadâ€“comonad interaction laws; record the isomorphism `MCIL_R(ğ’) â‰… Mon(IL_R(ğ’))` and ExampleÂ 13â€™s â€œexceptions monadâ€ witness (`RX = X + E`, `DY = Î” Ã— Y`) as canonical regression material.
- Document the Kleisli-category perspective from SectionÂ 5.2: characterise when an ordinary interaction law on `Kl(R)` comes from an `R`-residual law on `ğ’`, including the requirement that the lifted functor `FÌ„` is **strongly monoidal** via natural transformations `m^R_{X,Y} : F X Ã— F Y â†’ R(F(X Ã— Y))` that agree with both the product monoidality in `ğ’` and the monad structure of `R`.
- Extend the runner narrative so that stateful machines can leave behind residual behaviour governed by `R`, matching the discussion that â€œnot all of the effect of a computation is servicedâ€ and bridging to the residual runner subsections that follow in the paper.

### Tasks
1. **Residual law data structures.**
   - Define `ResidualInteractionLaw<R>` packaging the base functors `(F, G)`, the residual endofunctor `R`, the natural family `Ï_{X,Y}`, and cached witnesses for the two defining diagrams; ensure constructors accept both raw natural transformations and Day-derived evaluations.
   - Provide adapters that lift an ordinary interaction law `(F, G, Ï†)` into a residual one by choosing `R = Id` and converting `Ï†` into `Ï`, confirming the diagrams degenerate to identities.
   - Encode ExampleÂ 13â€™s â€œexceptions monadâ€ instance (`R X = X + E`, `D Y = Î” Ã— Y`, `Ïˆ(f, (a, y)) = caseÂ a of inlÂ x â†¦ f(x, y) | inrÂ e â†¦ inrÂ e`) as a ready-to-run constructor plus oracle fixture.
2. **Diagram transcription and oracles.**
   - Reconstruct the two SectionÂ 5.1 diagrams in executable form: supply helpers `residualLawCompatibilityWithF` and `residualLawCompatibilityWithG` that reproduce the exact composite maps from the figure (include the canonical morphisms `FX Ã— GY â†’ F(X Ã— Y)`, the comparison arrows `Rm^F_{X,Y}`, `Rm^G_{X,Y}`, and `FX Ã— GY â†’ RX Ã— GY â†’ R(X Ã— Y)`), record every intermediate arrowâ€”including the proof-stage morphisms `h_Y`, `k'_Y`, `k_Y`â€”and assert equality via structured diagnostics.
   - Implement `checkResidualInteractionLaw(law)` that runs both diagram checks, logs failures with the underlying morphism data, and replays the â€œfirst condition implies the second for pure mapsâ€ argument (`â„“ = Jg = Î·_Y âˆ˜ g`) so diagnostics can flag whether the second diagram has only been verified on Kleisli-pure arrows. Tag whether the residual component collapses to zero (linking back to PhaseÂ Ib degeneracy metadata when `R` factors through the zero functor).
3. **Residual monadâ€“comonad integration.**
   - Define `ResidualMonadComonadInteraction` objects featuring monad `T`, comonad `D`, residual `R`, and the natural transformations mirroring the paperâ€™s diagram (to be transcribed once the subsequent material is processed). Ensure they reduce to ordinary interaction laws when `R = Id` and store the comparison squares relating `Ïˆ` and `Ï`.
   - Formalise the monoidal lift: implement helpers that treat `Ï` as the multiplication of a monoid object in `IL_R(ğ’)` and verifyâ€”via structured diagnosticsâ€”that every residual monadâ€“comonad interaction law corresponds to a monoid object (and conversely) in line with the stated isomorphism `MCIL_R(ğ’) â‰… Mon(IL_R(ğ’))`.
   - Extend the existing `checkMonadComonadInteractionLaw` oracle so it can call into the residual checker when `R` metadata is present, replaying both the original Ïˆ-diagrams and the new residual ones while reporting the monoid-structure witnesses.
4. **Categorical structure and Dayâ€“Chu alignment.**
   - Plan quasi-inverse functors demonstrating `IL_R(ğ’)` embeds into the Day convolution/Chu machinery by treating `Ï` as a morphism into the Day tensor followed by `R`; detail how morphisms in `IL_R(ğ’)` should transport `Ï` while respecting the residual diagrams.
   - Record the Kleisli comparison: implement translators that lift a residual law `(F, G, Ï)` on `ğ’` to an ordinary interaction law `(FÌ„, GÌ„, Ï†)` on `Kl(R)` and back, while checking the necessary and sufficient monoidality condition on `F` (availability of `m^R_{X,Y}` compatible with both the Cartesian product in `ğ’` and the monad multiplication of `R`). Log explicit diagnostics for the two naturality squares shown in the excerptâ€”distinguishing the arrows forced by the strong-monoidal structure from those lying in the image of `J`â€”so discrepancies between the `Ï†` and `Ï` conditions are surfaced immediately and the weaker â€œpure mapâ€ requirement is visibly tracked.
   - Capture the morphisms of `MCIL_R(ğ’)` explicitly, including how runner maps must preserve residual structure (`(id Ã— f)`/`(R(f) Ã— id)` compatibilities), and prepare adapters so that residual runners can be obtained from residual interaction laws once SectionÂ 5.2â€™s text is incorporated.
5. **Runner alignment and residual hooks.**
   - Update the PhaseÂ IV runner tasks to reference the residual infrastructure: allow `StatefulRunner<T>` to optionally point at an `R` and record leftover behaviour, and ensure the planned `makeResidualInteractionLaw`/`attachRunner` helpers now cite the formal definition captured here.
   - Schedule documentation updates for `LAWS.md` and the roadmap narrative to include a â€œResidual Interaction Lawsâ€ entry summarising `Ï`, the two diagrams, the categories `IL_R(ğ’)`/`MCIL_R(ğ’)`, and how they specialise to the ordinary case when `R = Id`.

## 6. Phase VI â€” Monoidâ€“Comonoid Interaction and Hasegawaâ€™s Glueing (SectionÂ 6)
### Goals
- Promote the Day-convolution category of interaction laws into the **monoidal/duoidal setting** described in SectionÂ 6.1: explicitly model the duoidal data `(â„±, âŠ—, âŠ™, I, J, Î¶, Î´, Î¼)` where `âŠ—` is composition, `âŠ™` is Day convolution, `I` is the identity functor, and `J` is the Day unit. Encode the interchange transformations `Î¶`, `Î´`, and `Î¼` exactly as displayed so later phases can reuse them when transporting witnesses between the two monoidal structures.
- Recover the ordinary functorâ€“functor and monadâ€“comonad interaction laws by specialising this duoidal structure: record that the paper chooses `(F, G, Jk, Î·k)` and the Day pairing from FigureÂ (6) to obtain the evaluation morphisms. The plan must therefore preserve the comparison maps from diagramÂ (6)â€”the top composite `F^{op} âŠ™ G â†’ (F âˆ˜ G)^{op}` and the bottom composite landing in `F âˆ˜ G`â€”and log the conjugate symmetry `F^{op} âŠ™ G â‰… G âŠ™ F^{op}` coming from the symmetric Day tensor.
- Translate the paperâ€™s assertion that **monoid objects in `IL(ğ’)` are monadâ€“comonad interaction laws** into executable quasi-inverses: given a monoid `(F, G, Ï†, m, u)` in the interaction-law monoidal category, reconstruct the corresponding Ïˆ-family and conversely encode Ïˆ as monoid structure using the Day tensor and unit.
- Note explicitly that the functor `J` highlighted in SectionÂ 6.1 is **opmonoidal but not lax monoidal**. The roadmap must capture diagnostics that reconstruct the two triangles in diagramÂ (7), showing where the attempt to obtain a natural isomorphism between `(Comon(â„±))^{op}` and `Mon(â„±)` breaks down and where the opmonoidal comparison maps remain invertible.
- Encode the Sweedler dual functor `(-)^Â° : (Mon(â„±))^{op} â†’ Comon(â„±)` introduced beneath diagramÂ (8), including the proof obligation that it is only lax monoidal. Plan to log the two composites from diagramÂ (8)â€”one using the Day tensor comparison `m^{F,G}` and the other using the opmonoidal structure of `J`â€”so we can pinpoint precisely why the oplax structure fails while still obtaining the lax-monoidal Sweedler dual.
- Internalise SectionÂ 6.3â€™s **Sweedler dual computations for monoids built from free constructions**: restate that for any endofunctor `F` the Sweedler dual of the free monoid `F*` coincides with the free comonoid on the dual functor (`(F*)Â° â‰… (FÂ°)*`), and that imposing equations via a coequaliser `E* â‡‰ F* â†’ T` yields a dual computed by the corresponding equaliser on Sweedler duals (diagram with `EÂ°* â‡‰ FÂ°* â†’ TÂ°`). Record the comparison maps `Î¹_* : FÂ° â†’ (F*)Â°`, `e^F_{UD}` from the proof, and ensure the plan captures how they witness the universal property.
- Internalise **Hasegawaâ€™s glueing construction** (SectionÂ 6.2) as a concrete workflow: starting from a monoidal category `ğ’` with finite products and pullbacks, build the interaction-law Chu space `I = (F^I, G^I, Ï†^I)` whose primal/dual components `(F^I_*, F^I^â€ )` and `(G^I_*, G^I^â€ )` are assembled from the glueing index objects `(I, I)` together with the canonical comparison maps `F^I_X` and `G^I_Y`. Ensure the roadmap captures the isomorphism between the glueing category `Gl(ğ’)` and the Hasegawa interaction laws via explicit diagnostics.
- Record the **closure properties** highlighted in the excerpt: if `F` and `G` are closed under pullbacks, then the induced glueing interaction law `(F âŠ— G, Ïˆ^{FâŠ—G})` is again closed, and if the base category admits the Day tensor product of promonoidal functors, the resulting interaction law inherits associativity/unitality witnesses compatible with the previously planned monadâ€“comonad constructions.
- Prepare executable examples that replay the paperâ€™s constructions, including the glueing of the identity functor (yielding the R-residual runner recovered from SectionÂ 5) and at least one nontrivial monoidal functor pair where the glueing tensor exhibits the stated `m^{G, F}` evaluation formula.

### Tasks
1. **Monoidal/duoidal structure materialisation.**
   - Extend the PhaseÂ I interaction-law module with explicit representations of both monoidal structures: composition `âŠ—` with unit `I`, Day convolution `âŠ™` with unit `J`, and the interchange maps `Î¶`, `Î´`, `Î¼` as spelled out in SectionÂ 6.1. Store the coend witnesses, associators, and unitors for each structure, together with the symmetry `Ïƒ : F^{op} âŠ™ G â†’ G âŠ™ F^{op}` extracted from diagramÂ (6).
   - Implement diagnostics `checkInteractionLawMonoidal(law)` that verify the Day tensor respects the evaluation pairing (naturality squares, associativity pentagon, unital triangles) and emit detailed traces showing how the Chu-space evaluation agrees with the Day pairing. Add a complementary `checkInteractionLawComposition` diagnostic that logs how the composition monoidal structure interacts with the Day tensor through the interchange transformations.
2. **Monoid-object â†” Ïˆ equivalence.**
   - Provide translators `monoidObjectToInteractionLaw` and `interactionLawToMonoidObject` that realise the SectionÂ 6.1 equivalence. The forward direction must reconstruct Ïˆ by currying the monoid multiplication through the Day tensor, while the backward direction must build multiplication/unit from Ïˆ via the canonical `m^{F,G}` and `u` maps. Diagnostics should log the coend representatives and the comparison morphisms `F(X Ã— Y)`, `G(X Ã— Y)` used in the derivation.
   - Integrate these translators with the existing `MCIL(ğ’) â‰… Mon(IL(ğ’))` adapters from PhaseÂ III, confirming they agree on overlap and adding checks that the multiplication reconstructed from Ïˆ matches the monoid multiplication supplied.
3. **Opmonoidal unit and Sweedler dual functor.**
   - Encode the opmonoidal structure of `J` exactly as in the excerpt (the natural transformations `JX âŠ™ JY â†’ J(X âŠ— Y)` and `I â†’ J`), and provide diagnostics that replay the two triangles from diagramÂ (7) to show where lax-monoidal structure fails. Capture counterexamples demonstrating that `J` does not supply a lax-monoidal unit by default.
   - Implement the Sweedler dual functor `(-)^Â° : (Mon(â„±))^{op} â†’ Comon(â„±)` by composing the Day-dual construction with the opmonoidal structure of `J`. Ensure the builder stores the lax-monoidal comparison maps from diagramÂ (8), records where oplaxity fails, and links back to the PhaseÂ III Sweedler dual constructors so both viewpoints share diagnostics and witnesses.
   - Add specialised calculators for SectionÂ 6.3: a helper `sweedlerDualOfFreeMonoid(F)` that materialises the isomorphism `(F*)Â° â‰… (FÂ°)*` by composing the comparison `Î¹_* : FÂ° â†’ (F*)Â°` with the universal arrow from the free monoid, and an oracle that verifies both directions of the bijection `Comon(FÂ°, UD) â‰… Mon(F, UD)` shown in the text. Extend the tooling with `sweedlerDualOfMonoidQuotient(equations)` that rebuilds the equaliser diagram from the paper (`EÂ°* â‡‰ FÂ°* â†’ TÂ°`) and logs the induced maps `f_*Â°, g_*Â°`, `f'_*Â°, g'_*Â°`, together with the pullback along `e^F_{UD}` used to detect when a quotient monoid shares its Sweedler dual with the generating functor.
4. **Hasegawa glueing implementation.**
   - Create a `constructGlueingInteractionLaw(data)` helper that accepts the pullback-stable subcategories `F`, `G`, the Day convolution kernel, and the glueing span `I â† R â†’ I` (mirroring the excerptâ€™s notation). The helper must build the Chu pairing `Ï†_{X,Y}` via the glueing evaluation map `F^e_{X,Y}`, attach the induced Day tensor/unitor witnesses, and record the universal property of the glueing category (`Gl(ğ’)` initial among objects equipped with spans into `F` and `G`).
   - Implement an oracle `checkGlueingInteractionLaw` that verifies the pullback conditions, naturality of the glueing evaluation, and the isomorphism with the `R`-residual construction when the glueing object factors through `R` (recovering the SectionÂ 5 setup). Include diagnostics that trace the comparison map `m^{GâŠ—F}` as described in the text (factoring through `g^F` and `m^{GâŠ—F}` via `R`).
5. **Example suite and documentation.**
   - Add regression plans for (a) the identity functor glueing (showing it agrees with the residual runner/unit interaction law), (b) a finite monoidal example where glueing produces a nontrivial tensor, and (c) a counterexample illustrating the need for pullback stability. Each example must capture the evaluation maps `Ï†`, the comparison morphisms `g^{F,G}`, and the Day tensor witnesses.
   - Schedule `LAWS.md` updates introducing a â€œGlueing Interaction Lawâ€ entry that references the SectionÂ 6 construction, the new oracle, and the relationship to monoid/comonoid interaction laws.
6. **Integration hooks.**
   - Ensure the new monoidal/glueing infrastructure feeds back into earlier phases: PhaseÂ IIIâ€™s monoid/comonoid packaging should reuse the SectionÂ 6 tensor/unit data, and PhaseÂ IVâ€™s runner conversions should note when glueing recovers the same Ïˆ as a stateful runner. Update the plan to revisit these connections once SectionÂ 6.3â€“6.4 material is reviewed.
7. **User/kernel monad stack.**
   - Build kernel monad constructors (e.g., `makeKernelMonad(Î£, C)`) that adjoin the `getenv`/`setenv` state operations to an external-effect signature `Î£`, package the resulting algebraic theory, and expose runners that guarantee the three desiderata (resource finalisation hooks, delegated external calls, and failure signalling). Store diagnostics that confirm the induced runners close resources exactly once and propagate failure via the dedicated channel.
   - Define complementary user monads `User_Î£` that consume the supervised effects exposed by the kernel runners, together with adapters that translate a kernel runner into the user-side monad morphism described in the excerpt. Require regression plans that replay the motivating examples (user/kernel, browser/web page, OS/hardware) and log the mediated access patterns.
   - Extend the roadmapâ€™s Î»_{coop} examples so user programs run atop the constructed kernel monads, exercising the explicit co-operation maps for `Î£` as well as the state operations, and validate through diagnostics that composing runners along the kernel boundary preserves the promised resource discipline and failure semantics.
8. **Runner calculus primitives.**
   - Restate the programming rule `run V { return x â†¦ M; (op z â†¦ N_op)_opâˆˆÎ£ }`, the handling clause for the kernel computation `(op z â†¦ N_op)` (including the optional `run` continuation and the finalisation block), and require the Î»_{coop} AST and interpreter tasks to materialise these constructs exactly as presented before SectionÂ 3.2.
   - Record the dual co-operation signature where each kernel operation returns both a value and a continuation `(A_op â†’ T B_op)` as in equationÂ (3): `{return x â†¦ (return x, x); (op z â†¦ K_op)} with K_op : A_op Ã— S â†’ B_op Ã— E_op`. Plan diagnostics that validate the induced co-operation map respects the projected components (user-visible result, kernel state update, optional signal), and surface counterexamples when any branch omits finalisation.
   - Add ExampleÂ 4 to the regression backlog: implement the file-handle scenario with `open`, `write`, and `close` operations, ensure the finalisation clause reclaims the handle even on signals, and log resource-usage traces that demonstrate the â€œclose after each write unless signalâ€ discipline highlighted in the text. Mark the cheat noted in the footnote (open must move outside `run`) and require the interpreter to reject such misplacements or automatically hoist them to value positions.
   - Implement **SectionÂ 4.4â€™s rewrite system**: encode the three equality judgements, add interpreter-level reductions that enforce the runner equations and their kernel counterparts, and build diagnostics that log which rule fires, how finalisation continuations are wrapped, and when signals or raises bypass the finaliser. Ensure the equality engine knows the Î²/Î· rules for handlers, exception blocks, and the `let_{X,E}` abbreviation so later proofs can cite these rewrites directly.

### Estimated Passes (â‰ˆ12)
1. Package Ïˆ-based monadâ€“comonad interaction records using existing degeneracy/CCC caches.
2. Implement Ïˆ coherence oracles and integrate ExampleÂ 6 evaluation witnesses.
- âœ… PassÂ 2 added `checkMonadComonadInteractionLaw`, packaged the ExampleÂ 6 writer/reader interaction via `makeExample6MonadComonadInteractionLaw`, and wired regression coverage through the new oracle, confirming all four Ïˆ-diagrams hold on the finite two-point instance.
- âœ… PassÂ 3 introduced `makeExample7MonadComonadInteractionLaw`, implementing the SectionÂ 3 writer/comonad example, capturing the `Ïˆ((b, x), (b', y)) = (x, b â‹… y)` action, reusing cached Day/CCC/Sweedler data, and extending the regression suite with a Ïˆ-coherence check to confirm the helper satisfies all four diagrams.
- âœ… PassÂ 4 added `makeExample8MonadComonadInteractionLaw`, realising the SectionÂ 3 update monad/comonad example (`TX = A â‡’ (B Ã— X)`, `DY = A Ã— Y`) with explicit state/action combinators, flattened multiplication witnesses, and regression coverage via `checkMonadComonadInteractionLaw`.
- âœ… PassÂ 5 introduced `analyzeExample9FreeSemigroupDegeneracy`, packaging ExampleÂ 9â€™s free-semigroup binary operation with commutative metadata, running the degeneracy analyzer to surface the constant-zero collapse, and extending the regression suite with the corresponding coproduct/pullback witness assertions.
4. Reproduce TheoremÂ 3 degeneracy tooling with logged coproduct/pullback witnesses.
   - âœ… PassÂ 6 added `checkAssociativeBinaryDegeneracy`, threading the commutative-binary degeneracy data through the Ïˆ fibers, logging the distributivity injections and the witnesses `h_Y`, `Î´'_Y`, `k'_Y`, and `k_Y`, and extending the ExampleÂ 7 regression with a TheoremÂ 3 detail assertion.
5. Implement ExampleÂ 9 zero-monad collapse and ExampleÂ 14 quotient/Sweedler embeddings.
6. Build `MCIL(ğ’) â†” Mon(IL(ğ’))` translators leveraging PhaseÂ I comma data.
   - âœ… PassÂ 8 introduced `monadComonadInteractionLawToMonoid` and the inverse `interactionLawMonoidToMonadComonadLaw`, reusing packaged currying/comma/Sweedler caches to derive Day-monoid multiplication/unit composites, logging sampled diagnostics, updating `LAWS.md`, and extending the regression suite with a round-trip test on the two-object kernel.
7. Deliver greatest-interaction Sweedler utilities for monads/comonads with regression checks.
   - âœ… PassÂ 7 introduced `deriveGreatestInteractingFunctorForMonadComonadLaw` and `deriveGreatestInteractingComonadForMonadComonadLaw`, reusing packaged Sweedler/comma caches to expose the greatest interacting functor and comonad, propagating provenance metadata, and extending the regression suite with ExampleÂ 6 coverage demonstrating cache reuse.
8. Implement structural operations (stretching, Day tensor, composition) and tests.
   - âœ… PassÂ 8 added `stretchMonadComonadInteractionLaw`, `tensorMonadComonadInteractionLaws`, and `composeMonadComonadInteractionLaws`, reusing the functor-level stretch/product helpers to build new packaged laws, logging provenance-aware diagnostics, updating `LAWS.md`, and extending the regression suite with identity/tensor/composite coverage on the two-object kernel.
9. Build runner translators (Î¸, costate, coalgebra) and align them with stored Î´ tables.
10. Implement Î»_{coop} AST/typing infrastructure with provenance-aware diagnostics.
   - âœ… PassÂ 9 introduced `lambda-coop.ts`, defining the Î»_{coop} value/user/kernel syntactic categories, resource annotations, and summary helpers.  The pass also added `test/lambda-coop.spec.ts` to exercise the resource collectors on a supervised file-runner scenario and exported the module via `allTS.ts`.
11. Encode the Î»_{coop} rewrite system and resource-tracking interpreters.
12. Finalise documentation/oracle registry updates capturing all PhaseÂ III capabilities.

- âœ… PassÂ 1 introduced `makeMonadComonadInteractionLaw`, bundling monad/comonad
  data with a functor interaction law while reusing supplied degeneracy
  analyses, CCC currying tables, comma presentations, and Sweedler summaries.
  Diagnostics record which caches were reused, and the packaged law exposes the
  `Ïˆ` fiber map for downstream coherence checks.

## 7. Phase VII â€” Session-Type Alignment and Future Directions
### Goals
- Record SectionÂ 8â€™s **session-type grammar** verbatim: types are generated from a distinguished base type `A`, a session channel variable `Y`, the constants `1` and `0`, binary product `A Ã— B`, linear function space `A â‡’ B`, and the constructors arising from the functor/comonad actions (`Gâ‚€A`, `Gâ‚€^{âˆ˜}A`, etc.). Ensure the roadmap tracks every constructor mentioned in the text so later passes can supply precise categorical semantics.
- Capture the recursively defined **dual operator** `(-)Â°` on session types (swapping `1`/`0`, reversing products/functions, and threading through the `Gâ‚€`-generated connectives) and state explicitly that this syntactic dual aligns with the semantic dual obtained from interaction laws and Sweedler duals.
- Integrate session types with the interaction-law infrastructure by planning interpreters that map each constructor to the corresponding functor/comonad operations (`send`, `receive`, Day convolution fibres) and ensure the dual operator is realised by the previously planned `dualInteractionLaw` helpers.
- Reflect the paperâ€™s observation that discrepancies arise between syntactic and semantic duals in linear settings, and prepare diagnostics that surface such mismatches when the base category is Cartesian closed versus intuitionistic linear.
- Document the **open problems** from SectionÂ 8â€™s conclusion: computing Sweedler duals in general, reconciling duality with cooperation coequations, determining whether the Sweedler dual persists in intuitionistic linear settings, and extending the interaction-law calculus to session typing.

### Tasks
1. **Session-type encoding.**
   - Design a `SessionType` algebraic data type mirroring the grammar above, including constructors for the `Gâ‚€`/`Gâ‚€^âˆ˜` actions; provide parsers/pretty-printers so examples from the paper can be instantiated exactly.
   - Specify semantic interpreters `interpretSessionTypePrimal`/`interpretSessionTypeDual` that send each constructor to the corresponding functor or comonad used in earlier phases (e.g., `send`/`receive` functors, Day tensor units), ensuring the dual interpreter composes the semantic duals computed in PhaseÂ II.
2. **Duality alignment diagnostics.**
   - Implement an oracle `checkSessionTypeDuality` that compares the syntactic dual `AÂ°` with the semantic dual delivered by `dualInteractionLaw`, reporting counterexamples when linear contexts break the equivalence noted in the conclusion.
   - Add regression plans covering the base cases (`1`, `0`, `Y`), composite cases (`A Ã— B`, `A â‡’ B`), and the `Gâ‚€`-derived constructors, ensuring all align with the evaluation-based runner semantics when interpreted.
3. **Session-type runners.**
   - Extend PhaseÂ IVâ€™s runner infrastructure with helpers that generate runners from session-type specifications (e.g., interpreting `A â‡’ B` as a handler map `Î¸`), verifying that the resulting evaluation map still matches `ev_Y`.
   - Provide documentation tasks linking session-type runners back to ExampleÂ 12â€™s update lenses and to the costate comonad translators.
4. **Future-work registry.**
   - Create a `docs/day-chu-future-work.md` tracker listing the unresolved questions from the conclusion (general Sweedler dual computation, cooperation semantics, linear-session duality, intuitionistic adaptations) together with proposed experiments or literature to consult.
   - Schedule revisit triggers after implementing PhasesÂ IVâ€“VI to assess how close the current infrastructure is to answering each question.

## 8. Cross-cutting Concerns
- **Oracle-first mindset:** every phase should surface structured diagnostics, witnesses, and tie into the projectâ€™s oracle registries.
- **Integration readiness:** maintain compatibility with existing promonoidal kernels, Day tensor/unit helpers, and Chu space utilities; prefer composition over bespoke constructions.
- **Iterative refinement:** this plan is meant to evolve with further low-level readingâ€”each revisit should update sections rather than appending ad hoc notes.
- **Testing discipline:** expand the automated suite alongside each capability, ensuring deterministic coverage aligned with `AI_MATHEMATICAL_IMPL_GUIDELINES.md`.

## 9. Next Review Triggers
- âœ… Postâ€“PhaseÂ I review incorporated on this pass; the next structured review is scheduled immediately after PhaseÂ II implementation to reassess dual/Sweedler scope and confirm the pass estimates remain accurate.
- Re-read the remaining subsections of SectionÂ 5 (residual running, residual runners) and SectionÂ 6 (duoidal structure) before executing PhaseÂ V and beyond so any additional operational hooks are folded into the roadmap rather than appended later.

## References
- Shin-ya Katsumata, Eduardo Rivas, and Tarmo Uustalu. *Interaction Laws of Monads and Comonads*. arXiv:1912.13477, 2019.
- Andrej Bauer and Matija Pretnar. *Runners in Action*. In *European Symposium on Programming*, 2019.
