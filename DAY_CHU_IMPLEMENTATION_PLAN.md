# Day–Chu Interaction Law Implementation Plan

## 0. Context and Objectives
- Leverage the existing Day convolution + Chu space infrastructure to model the interaction-law story outlined by Katsumata–Rivas–Uustalu (2019).
- Provide first-class runtime objects for functor–functor interaction laws, expose dual/Sweedler constructions, lift the setup to monad–comonad interaction laws (monoid/comonoid objects under Day convolution), and prepare for residual/stateful generalisations.
- Maintain oracle-driven verification and integration with the current category-theory toolkit; every new abstraction must surface diagnostics, witnesses, and LAWS.md/Oracle integration points.

### 0.1 Literature and Related-Work Alignment
- Track the neighbouring formalisms cited in Section 6’s “Related work” so implementation steps can import constructive insights when necessary. The key comparison points are:
  - Power–Shkaravska on comodels and Bauer’s tutorial on runners/handlers, which motivate explicit comodel-oracle hooks when translating interaction laws into operational semantics.
  - Plotkin–Power’s tensors of models/comodels and Hancock–Hyvernat’s interaction structures, which supply alternate universal properties for Day convolution pairings that may inform oracle design.
  - Uustalu’s runners (2006) and the Katsumata–Uustalu–Rivas references that introduced stateful runners; these anchor the runner sections of the roadmap.
- **Tasks**
  1. Create a lightweight “related work” registry (e.g., `docs/day-chu-related-work.md`) summarising each cited source with actionable checklists (what structures/oracles might be borrowed, which diagrams must be compared). Link this registry from the main plan once drafted.
  2. When implementing each phase, perform a gap analysis against the corresponding references (e.g., ensure Phase III’s monoid/comonoid translators cover Plotkin–Power’s tensor perspectives, Phase IV’s runner adapters capture Hancock–Hyvernat lenses). Record the outcomes in the registry so future revisions know whether further literature study is required.
  3. Flag open research questions discovered during implementation (for example, whether comodel-based semantics expose additional degeneracy witnesses) and feed them back into the roadmap as optional enhancements.

## 1. Phase I — First-class Functor–Functor Interaction Laws
### Goals
- Wrap `buildDayPairingData` outputs into dedicated interaction-law values that mirror the paper’s definitions.
- Preserve indexed carriers, contribution collectors, and Chu aggregators so no information is lost compared to today’s lower-level API.

### Tasks
1. **Module creation (`functor-interaction-law.ts`).**
   - Define a `FunctorInteractionLaw` record that packages: promonoidal kernel reference, left/right witnesses, `DayConvolutionResult`, indexed carriers, contribution aggregator, and the induced `ChuSpace`.
   - Provide constructors for common kernels (strict monoidal, finite toy kernels) that internally invoke existing promonoidal helpers.
   - Ensure the record exposes evaluation helpers (e.g. `evaluate(primalWitness, dualWitness)`) that internally reuse the collected Day contributions.
2. **Public surface integration.**
   - Export constructors from the main barrel (`allTS.ts`) and document provisional usage.
   - Introduce module-level JSDoc describing how the object realises the interaction-law diagram (functor pairs, evaluation to the dualising object) shown in the paper’s Section 3 figure.
3. **Testing.**
   - Add regression coverage (extend `test/chu-space.spec.ts` or introduce `test/functor-interaction-law.spec.ts`) that instantiates a known promonoidal kernel, constructs a law, and checks the evaluation against the raw Chu pairing.
   - Include a check mirroring the interaction-law composition square to ensure the evaluation is natural with respect to the underlying functor morphisms.

## 1.5 Phase Ib — Degeneracy Results and Operation Interfaces (Theorems 1–2)
### Goals
- Encode Section 2’s **comment-on-operations** viewpoint explicitly: an `n`-ary operation on a monad is a natural transformation `αⁿ_X : T(Xⁿ) → TX` whose components commute with substitution (Plotkin–Power format), arise from Kleisli composition (`T` applied to coproduct injections), and can be reinterpreted as morphisms of Lawvere theories `μₙ : L → L ⊗ n`.
- Dualise the description for comonads/cooperations where each `βⁿ_X : TX → T(Xⁿ)` is natural and respects the drop/duplication structure (`TX → T(1)` compatibility).
- Record and operationalise the **degeneracy theorems** supplied in Section 2:
  - **Theorem 1 (nullary collapse).** If a functor (or monad viewed as its underlying functor) carries a nullary operation `c_X : 1 → FX` natural in `X`, then every functor interacting with `F` is forced to be the constant-zero functor `G ≅ 0`. The plan must surface checks that detect nullary operations and witness the induced zero object comparisons.
  - **Theorem 2 (commutative binary collapse).** If `F` admits a commutative binary operation `c_X : X × X → FX` (natural in `X` and symmetric under the swap map), then any interacting `G` again degenerates to the constant-zero functor. We need executable counterparts for both proof parts: (1) the pullback/diagonal argument that collapses coproduct components, and (2) the uniqueness factorisation through the zero object.
- Capture these degeneracy results (including both parts of Theorem 2’s proof) as executable checks/oracles ensuring that operations factoring through `T` coincide with canonical monad/comonad structure maps once transported along the Lawvere-theory comparison functor, while also surfacing the constant-zero witnesses guaranteed by the theorems.

### Tasks
1. **Operation type definitions.**
   - Introduce `MonadOperation`/`ComonadCooperation` types representing natural transformations of the form `αⁿ_X : T(Xⁿ) → TX` and `βⁿ_X : TX → T(Xⁿ)`.
   - ✅ Added reusable constructors (`makeNullaryMonadOperation`, `makeCommutativeBinaryMonadOperation`, and comonad counterparts) that package nullary/commutative-binary data together with optional Kleisli/Day/Lawvere witnesses so interaction laws can record Section 2 operations directly from monad/comonad structure.
   - Store for each operation: its arity `n`, the induced Kleisli morphism on generic elements (`T` applied to coproduct injections from `X` into `Xⁿ`), Lawvere-theory witness (`μₙ`), Day-convolution indices so interaction laws can reuse the same carriers, and—for nullary/binary cases—the specific nullary element `c_X : 1 → TX` or commutative operation `c_X : X × X → TX` itself.
   - Provide constructors that derive these operations from existing monad/comonad structure (unit/multiplication or counit/comultiplication), reify higher arities via iterated substitution, and expose the generic element map `η_X : X → TX`/`ε_X : TX → X` needed in Theorem 2’s proof steps.
2. **Degeneracy checkers.**
   - Implement structural oracles (e.g., `checkNullaryDegeneracy`) that replay Theorem 1: detect natural nullary operations, compute the induced constant element `c_1 : 1 → T1`, and build the canonical natural transformation exhibiting any interacting functor `G` as constant zero by producing explicit morphisms `GY → 0` and `0 → GY` with zero-object witnesses.
   - ✅ `checkNullaryDegeneracy`, `checkCommutativeBinaryDegeneracy`, and `analyzeFunctorOperationDegeneracy` now reconstruct the zero-object comparison maps for each object, returning explicit `SetCat` homs `GY → 0` and `0 → GY` beside the proof steps so the collapse in Theorems 1–2 has executable witnesses.
   - Add a complementary oracle (`checkCommutativeBinaryDegeneracy`) capturing Theorem 2’s two-part argument for endofunctors: (i) verify the pullback diagram used to form `f_Y` commutes by reconstructing the coproduct stability argument, and (ii) materialise the uniqueness map `k_Y : GY → 0` that factors through the zero object via the coproduct diagonals `δ : PY → 0 + 0` and `δ' : PY → 1 + 1` discussed in the proof.
   - Extend the existing `analyzeFunctorOperationDegeneracy` tooling so it also reports Lawvere morphisms `μₙ`, substitution comparison maps `κⁿ_X : T(Xⁿ) → (TX)ⁿ`, and any counterexamples returned by recomputing the drop map `TX → T1` used to certify constant-zero behaviour.
3. **Proof-structure tooling.**
   - Encode the reusable components from Theorem 2’s proof: duplication of the generic element via `δⁿ`, application of `η_X`, comparison with the canonical `μₙ`, and the final evaluation through `ε_X`, plus the explicit construction of the maps `f_Y`, `k'_Y`, and `k_Y` appearing in parts (1) and (2).
   - Provide tracing utilities that log each proof step (construct `δⁿ`, lift via `T`, apply `αⁿ`, compare with `μₙ`, evaluate with `ε_X`, and collapse to the zero object) so future low-level reads can refine the reasoning without rebuilding diagnostics.
   - ✅ `checkCommutativeBinaryDegeneracy` now emits detailed traces and artifacts per object, covering `δ_Y`, lifted `α^2_Y`, substitution arrows, Lawvere comparisons, Day-fiber metadata, and explicit zero-factorisation gaps.
4. **Integration with interaction laws.**
   - Extend `FunctorInteractionLaw` records to optionally carry the primary operations/cooperations (including nullary/commutative binary metadata) so later phases (dual/Sweedler, monoid/comonoid lifts) can quote them directly and trigger degeneracy analysis automatically when present.
   - Update Phase I tests to validate that a sample monad exposes its binary operation through the new interface and that the degeneracy oracles report “constant zero” with explicit witnesses when applied to the constructed interaction laws.
   - Add regression checks derived from Theorem 2’s commutative diagrams (swap invariance, pullback stability, diagonal factorisation) to ensure functor-level degeneracy witnesses remain aligned with the interaction-law evaluation.

## 1.75 Phase Ic — Section 2.3 Constructions (Stretching, Self-duality, Final Law)
### Goals
- Incorporate the Section 2.3 toolkit for manufacturing interaction laws directly from existing ones:
  - **Stretching:** given a law `(F, G, φ)` and natural transformations `f : F' ⇒ F`, `g : G ⇒ G'`, produce `(F', G', g ∘ φ ∘ f)` with inherited evaluation witnesses.
  - **Self-duality:** exploit the canonical symmetry `sym_X : X × X → X × X` and the dualising Chu-space involution to obtain `(F^{op}, G^{op}, φ^{op})` together with evaluation comparison maps showing the `((IL(C))^{op})` equivalence described in the text.
  - **Final functor interaction law:** expose the terminal object `(1, 0, φ)` where `φ_{X,Y} : 1 × GY → 0` witnesses the constant-zero collapse highlighted alongside Theorems 1–2.
- Ensure these constructors are first-class on `FunctorInteractionLaw` and interoperable with degeneracy metadata (nullary/binary markers) so the plan keeps all prior detail intact while enabling Section 2.3 workflows.
- Register at least one new entry in `LAWS.md` summarising the “stretching law” and its oracle so that future implementers have a concrete executable law derived from the paper.

### Tasks
1. **Constructor implementations.**
   - Add `stretchInteractionLaw(law, f, g)` that replays Section 2.3’s stretching formula, reusing contribution collectors and ensuring the resulting evaluation equals `g ∘ φ ∘ f` on every coend representative.
   - Implement `selfDualInteractionLaw(law)` that transports the Day pairing along the symmetry `sym` and leverages `dualChuSpace` to return the law over `C^{op}`, emitting the comparison isomorphisms between the original and dual evaluations.
   - Provide `finalInteractionLaw(kernel)` that materialises `(1, 0, φ)` using the zero object of `Set` (or the chosen dualising object) and stores the unique morphisms into the zero functor; hook this into the degeneracy oracles so Theorem 1’s constant-zero witness is now constructed via the final law helper.
2. **Oracle coverage.**
   - Extend the degeneracy checkers to call `finalInteractionLaw` whenever a nullary or commutative binary operation is detected, verifying that stretching along the canonical maps reproduces the same collapse proof as in Theorems 1–2.
   - Add structural oracles validating that stretching preserves interaction-law axioms (naturality squares, compatibility with Day convolution), following the “stretching law” text snippet.
3. **Documentation & tests.**
   - Update the Phase I spec to include targeted tests for stretching/self-duality/final law: construct a toy kernel, stretch along nontrivial `f`/`g`, confirm evaluation equality, and assert that the self-dual law matches the explicit dual Chu space.
   - Record the new law in `LAWS.md`, citing the Section 2.3 formulae and pointing to the accompanying oracle/test harness.

## 1.9 Phase Id — Section 2.4 Categorical (Co)products and (Co)algebra Constructions
### Goals
- Support the categorical operations on interaction laws highlighted after Theorem 2, ensuring the roadmap covers both the product/coproduct of laws and the algebra–coalgebra constructions obtained by currying the evaluation maps.
- Preserve compatibility with the degeneracy metadata from Phase Ib and the constructors from Phase Ic so stretching/self-duality/final-law workflows compose with these new operations.

### Tasks
1. **Binary product & coproduct constructors.**
   - ✅ Implemented `productInteractionLaw(law0, law1)` realising the displayed composite `φ⁰×¹_{X,Y}`: the helper now pairs Day fibers, aggregates witnesses with the underlying oracles, and exposes projection metadata for both functor components and the dualising carrier.
   - ✅ Added `coproductInteractionLaw(law0, law1)` by dualising the product recipe, threading coproduct injections for both witnesses, enforcing summand agreement on Day contributions, and surfacing the resulting injections for primal, dual, and value carriers.
   - Add oracles checking the universal properties: for the product, confirm projections compose back to the original laws; for the coproduct, verify the dual property using the transposed evaluations.
2. **Initial algebra–final coalgebra adapters.**
   - ✅ Added `deriveInteractionLawCurrying(law)` to curry each Day fiber, record the uncurry comparison, and emit discrepancy diagnostics when the reconstructed `φ^X_Y` diverges from the original evaluation.
   - ✅ Currying data surfaces alongside the fiber carriers, enabling oracles to inspect the `θ`/`φ` witnesses objectwise; discrepancies feed into the degeneracy analyzers for replaying Section 2.4 arguments.
3. **Fix-one-side interaction categories.**
   - ✅ Implemented `makeFixedLeftInteractionMorphism` and `makeFixedRightInteractionMorphism` to transport natural transformations on the right/left components into morphisms of `IL(C)_{F,-}` and `IL(C)_{-,G}`, returning comparison tables for evaluation preservation.
   - Provide isomorphism witnesses `IL(C)^op ≅ IL(C^op)` aligned with the Section 2.4 note, leveraging the self-dual constructor and logging the induced equivalence on objects/morphisms.
4. **Initial object accessors.**
   - ✅ Delivered `buildFixedLeftInitialObject` and `buildFixedRightInitialObject`, packaging the constant-zero collapse with canonical maps (or diagnostics when the fixed-right collapse is obstructed) and threading the results into degeneracy reports.
   - ✅ `LAWS.md` documents the currying adapters, fixed-side morphisms, and initial-object helpers together with their regression coverage.
6. **Testing.**
   - Expand the interaction-law test suite with scenarios covering product/coproduct compositions, initial algebra–final coalgebra derivations on toy kernels, and the verification that fixing a functor produces the promised initial objects.
 - Include regression traces demonstrating that the new helpers commute with stretching/self-duality (e.g., stretching a product equals the product of stretched laws).

## 1.95 Phase Ie — Cartesian-Closed Dual Presentation of Interaction Laws
### Goals
- Capture the “dual-of-an-endofunctor” presentation from the Section 2.4 setup: when `𝒞` is Cartesian closed, define the dual of `G` at an object `X` as `G^X(Z) := 𝒞(Z × X, GX)` (using the internal hom/exponential object representing morphisms `Z × X → GX`).
- Rephrase interaction laws via the three equivalent natural-transformation viewpoints spelled out beneath equation (2.16):
  1. `φ^X_Y : FX ⊗ GY → G(X ⊗ Y)` compatible with the symmetry and associativity constraints.
  2. `φ̂^X_Y : G^X(FX ⊗ Y) → G^Y` satisfying the coherence equation `G^X(φ̂^Y_Z) ∘ φ̂^X_{FY,Z} = φ̂^{X⊗Y}_Z`.
  3. `φ̌^X : FX → G^X` where the preceding condition transports to exponential transpose equations.
- Provide executable conversions between these forms and confirm that all three yield the same Day/Chu evaluation data, enabling future phases to depend on the CCC-based dual description.
- Surface diagnostics for the existence of duals: detect when the exponential object `GX ⇒ ?` fails to exist, emit constructive witnesses when it does, and report conservative fallbacks for non-dualisable endofunctors as highlighted in the text.
- Materialise the “final transformation” `δ^X_Y : F^X(X × Y) → GY` obtained by instantiating the interaction law at the dual object, ensuring its computation is recorded alongside the CCC dual metadata.

### Tasks
1. **Cartesian-closed prerequisites.**
   - Extend the categorical infrastructure with detectors/constructors for Cartesian closed categories (CCC) that surface exponential objects, evaluation maps, and currying/uncurrying witnesses.
   - Provide helpers `internalHom(G, X)` or `dualizeEndofunctorCCC(G, X)` that materialise `G^X` along with the evaluation/counit `ev^X : G^X × X → GX` required by the Section 2.4 derivation.
   - Cache diagnostics when an exponential is missing and expose them through the interaction-law planning oracles so callers know when CCC-derived conversions are unavailable.
2. **Equivalence translators.**
   - Implement bidirectional translators between the three presentations: `(φ^X_Y) ↔ (φ̂^X_Y) ↔ (φ̌^X)` using the CCC evaluation/coevaluation maps. Ensure each translator records the composite witnesses listed in the paper (e.g., the composition through `δ^X`, the pullback squares, and the use of `μ_n`).
   - Attach algebraic simplifiers that verify the coherence law `G^X(φ̂^Y_Z) ∘ φ̂^X_{FY,Z} = φ̂^{X⊗Y}_Z`, logging every intermediate morphism so low-level reviews can trace the proof-of-equality path.
3. **Oracles and regression checks.**
   - Add CCC-aware oracles that confirm: (a) `φ^X_Y` agrees with the original Day evaluation when transposed twice, (b) `φ̌^X` coincides with the exponential transpose of `φ̂^X_1`, and (c) stretching/self-duality respect the dual presentation.
   - Provide counterexample tracing that replays the “conservative” argument from the text: when a functor lacks a dual at some `X`, the oracle should emit the obstructing morphism and suggest falling back to the non-CCC formulation.
   - Extend the interaction-law tests to run through a toy CCC (e.g., `FinSet`) and assert the triple equivalence and coherence equation explicitly.
4. **Integration points.**
   - Thread CCC metadata into `FunctorInteractionLaw` so later phases (dual/Sweedler, monoid/comonoid lifts) can preferentially use CCC-based duals when available, while reverting to existing Day/Chu constructions otherwise.
   - Update `LAWS.md` with a Section 2.4 “CCC dual presentation” entry describing the three interchangeable forms and referencing the new oracles/tests.

### Status
- ✅ Pass 6 attached CCC metadata to `deriveInteractionLawCurrying`, introduced the `deriveInteractionLawCCCPresentation` alias, and recorded the `(φ, \hat{φ}, \check{φ})` triple together with evaluation-consistency diagnostics. Final transformations `δ^X_Y` remain flagged in-line for future implementation once explicit `F^X` carriers are available.

## 1.97 Phase If — Category-Level Equivalences and Comma Presentations
### Goals
- Implement the categorical equivalences spelled out after Section 2.4: the category `IL(𝒞)` of functor–functor interaction laws is isomorphic to both comma categories `(𝒞, 𝒞)_{↓}` (objects `(F, G, σ)` with `σ : F ⇒ G'`) and `(𝒞, 𝒞)^{op}_{↓}` (objects `(F, G, τ)` with `τ : G ⇒ F°`, where `(-)'`/`(-)°` denotes the dual functor extracted from the Day/Chu pairing).
- Track the consequences for slice categories such as `IL(𝒞)_{-, G}` and `IL(𝒞)_{F, -}`: identify their initial/final objects explicitly—`(G, G, id_G)` and `(G', G, ε^G)` on the `G`-fixed side, `(F, F, id_F)` and `(F, F°, η^F)` on the `F`-fixed side—and record the comparison maps that witness these universal properties (with `G'`/`F°` supplied by the Day/Chu duals and `ε^G`, `η^F` taken from the evaluation/coevaluation witnesses).
- Ensure these equivalences are executable: provide functors in both directions, prove (via structured diagnostics) that they are quasi-inverse, and surface the induced morphism translations needed for later phases (monoid/comonoid lifts and CCC dual presentations).

### Tasks
1. **Data model for comma presentations.**
   - Introduce TypeScript records for comma objects `(F, G, σ)` and `(F, G, τ)` where `σ : F ⇒ G'` and `τ : G ⇒ F°` are natural transformations into the Day/Chu dual functors.
   - Provide constructors that build `G'`/`F°` using the dualisation helpers already planned in Phases Ic–Ie so the comma models reuse the same witnesses and evaluation data.
   - Store explicit morphism representations (`α : F ⇒ F₁`, `β : G ⇒ G₁`) together with the compatibility squares required in the comma categories, ensuring diagnostics enumerate any failing naturality components.
   - ✅ Pass 7 delivered `deriveInteractionLawLeftCommaPresentation`, materialising the `G'` internal-hom functor, caching `σ` components, and emitting evaluation/naturality diagnostics plus an opposite-functor witness for `(F, G, σ)` objects.
2. **Equivalence functors.**
   - Define functors `IL(𝒞) → (𝒞, 𝒞)_{↓}` and `(𝒞, 𝒞)_{↓} → IL(𝒞)` that send an interaction law `(F, G, φ)` to `(F, G, σ)` with `σ` obtained by currying `φ`, and conversely reconstruct `φ` by uncurrying `σ`; mirror the construction for the dual `(𝒞, 𝒞)^{op}_{↓}` presentation.
   - Implement natural isomorphisms witnessing that these functors compose to the identity on both sides, with oracle traces logging every component map so low-level reviewers can verify the quasi-inverse property objectwise and arrowwise.
   - Include regression checks ensuring that stretching/self-duality commute with the equivalence functors, as predicted by the paper’s discussion of categorical symmetry.
   - ✅ Pass 7b added `deriveInteractionLawLeftCommaEquivalence`, rebuilding the uncurried pairing `φ_X : F(X) × G(X) → ⊙`, logging reconstruction/naturality failures, and extending the regression suite to confirm the quasi-inverse diagnostics on the two-object kernel.
3. **Universal-object witnesses.**
   - Materialise the initial/final objects for the fixed-slice categories explicitly: e.g. for `IL(𝒞)_{-, G}` build the morphisms from `(F, G, φ)` into `(G, G, id_G)` and from `(G', G, ε^G)` into `(F, G, φ)`, providing executable oracles that certify their universal properties via uniqueness up to equality in the comma categories.
   - Add diagnostics that reconstruct the zero-object witnesses appearing in the proof of the final object description, linking them to the degeneracy oracles from Phase Ib and the final interaction law from Phase Ic.
   - Update `LAWS.md` (and the interaction-law oracle registry) with entries describing the comma equivalence, the initial/final object formulas, and guidance on invoking the new oracles/tests.

## 2. Phase II — Duals and Sweedler Duals (“Greatest Interacting” Objects)
### Goals
- Reinterpret `dualChuSpace`, `sweedlerDualFromPrimal`, and `sweedlerDualFromDual` at the interaction-law level to produce the greatest functor/comonad that interacts with a given functor/monad (Theorems 1–2).
- Internalise the Section 2.5 “Dual for some constructions on functors” recipes and their proofs: explicitly realise the coend calculations for the identity functor (`Id° ≅ Id`), the terminal functor (`1° ≅ 0`), products (`(F × G)° ≅ G° × F°` with the constant-zero collapse when one factor is terminal), initial functors, coproducts, and weighted sums `G°X ≅ ∫_Y A × G°Y`.
- Capture the derived examples and canonical natural transformations from the proofs: the exponent-of-identity case `G°X ≅ ∫_Y (A ⇒ Y) ⇒ (X × Y) ≅ A × X`, Example 4’s Day-sum functor (`GY = Y⁺ ≅ Σ_n (N_{[0,n]} ⇒ Y)`), and the generic “lower bound” `∫_Y G₀(G₁Y) ⇒ (X × Y)` for composite functors, together with the lax-monoidal comparison morphisms `m^{G₀,G₁}_X : G°₀(X) ⊗ G°₁(X) → (G₀ ⋅ G₁)°(X)`.
- Expose ready-made constructors/oracles for these canonical duals so implementers can call the specialised formulas instead of recomputing the generic coend each time, while also cross-checking against the Sweedler dual computations and logging the proof steps (coend evaluation, currying/uncurrying, canonical naturality squares) used in the derivations.

### Tasks
1. **Dual interaction law constructor.**
   - Implement `dualInteractionLaw(law)` that swaps primal/dual data via `dualChuSpace`, updates witnesses, and reuses evaluation helpers.
2. **Explicit dual constructors + proof logging.**
   - Provide dedicated helpers `dualOfIdentity`, `dualOfTerminal`, `dualOfProduct`, `dualOfInitial`, `dualOfCoproduct`, and a generic `dualOfWeightedSum` that mirror the formulas in Section 2.5: build the required coends explicitly, use the canonical evaluation witnesses (e.g., `GY = Y`, `GY = A × G'Y`), and record the simplifying identifications (`X × 1 ≅ X`, `X × 0 ≅ 0`).
   - Add specialised constructors for the “exponent-of-identity” case (`dualOfExponentialIdentity(A)` producing the equivalence `G°X ≅ A × X`) and for Example 4’s free-monoid functor (`dualOfPositiveList`), replaying the summation/indexing arguments from the proof and storing the intermediate natural transformations `θ_n : (N_{[0,n]} ⇒ Y) ⇒ (X × Y)`.
   - Encode the general lower-bound comparison for any functor `G` by constructing `dualLowerBound(G)` that materialises the coend `∫_Y GY ⇒ (X × Y)` alongside the canonical map into `G°X`; document when the bound is an isomorphism (identity, terminal, product, coproduct cases) versus merely a comparison map.
   - Ensure each helper delegates to/validates against `dualInteractionLaw` so the specialised constructors agree with the general Chu-based dual, emitting diagnostics whenever the simplification assumptions (terminal object present, coproduct exists, exponentials available, etc.) are not met in the base category.
   - Thread these helpers into `FunctorInteractionLaw` so callers working with identity/terminal/product/coprod/exponential functors can request the dual directly, and store any constant-zero witnesses that arise when terminal factors collapse the product.
3. **Lax-monoidal comparison morphisms.**
   - Implement utilities `laxMonoidalDualComparison(G0, G1)` that build the canonical transformation `m^{G₀,G₁}_X : G°₀X ⊗ G°₁X → (G₀ ⋅ G₁)°X` described beneath the proof of the composition rule, tracing the proof steps (`δ`, `η`, currying) and recording when it upgrades to a monoidal isomorphism (identity/product cases).
   - Provide diagnostics that flag when `(-)° : [𝒞^{op}, 𝒞] → [𝒞, 𝒞]` only yields a lax-monoidal structure, including counterexamples or witnesses when the canonical comparison fails to be invertible.
4. **Greatest interacting functors/comonads.**
   - Provide `greatestInteractingFunctor(law)` and `greatestInteractingComonad(law)` utilities that package the Sweedler dual evaluations as witnessed (co)functors.
   - Return both the transformed law and the induced natural transformations needed to act within the Day convolution context.
5. **Testing & Diagnostics.**
   - Extend the new spec to assert that composing an interaction law with its dual/Sweedler transform realises the evaluation identities promised in the paper (e.g. via sample witnesses, finite carrier enumeration).
   - Add regression cases for each specialised dual constructor (identity, terminal, product, coproduct, exponential identity, positive-list) comparing their outputs to the generic dual and verifying the simplification steps (`X × 0 → 0`, `A × X` equivalence, `Σ_n` decomposition) via explicit witnesses.
   - Include dedicated checks for `laxMonoidalDualComparison` showing when the comparison morphism is invertible and when it merely provides a lower bound, reproducing the proof steps with logged intermediate morphisms and covering the Example 5 scenario (`G = Y⁺`, canonical `m^{G, G}` and `g^{(a,f)}` components).
   - Ensure diagnostic output highlights when aggregation fails to land inside the dualising object (mirroring `aggregateDayPairing`) and archives proof traces (coend evaluation, currying, diagonal factoring) for future low-level review.
6. **Documentation.**
   - Update `LAWS.md` with a “Functor–Functor Interaction Laws” section summarising the new helpers and linking to dual/Sweedler constructions.
   - Document the Section 2.5 identities, Example 4, the lax-monoidal comparison, and their oracles/tests, including guidance on when each specialised dual helper is applicable and how it relates to the Sweedler dual story.

## 3. Phase III — Monad–Comonad Interaction Laws and Monoid/Comonoid Structure
### Goals
- Internalise Section 3’s definition of a **monad–comonad interaction law**: given a monad `T = (T, η, μ)` and a comonad `D = (D, ε, δ)` on the same base category, materialise a family of maps
  `ψ_{X,Y} : TX × DY → X × Y` (or, in closed form, `ψ_{X,Y} : TX ⊗ DY → X ⊗ Y`) that is natural in both variables and satisfies the four coherence squares matching η/μ with ε/δ exactly as in the paper’s diagram (unit laws, multiplication/comultiplication compatibility, and the mixed associativity square).
- Treat these interaction laws as **monoid objects** of the functor–functor interaction category under Day convolution, reusing the Chu pairing to encode the multiplication/counit witnesses.
- Extract constructive diagnostics from the proofs: re-run the sequential composition argument (“machine executes a computation and immediately returns”) and the behavioural interpretation (“machine observes a computation while producing outputs”), so every ψ-based coherence condition is logged with witnesses.
- Capture Example 6’s finite case (`T = AY`, `D = A → Y` for fixed `A`) where `ψ` is induced by evaluation and multiplication, showcasing how the definitions collapse to concrete computations.
- Extend coverage to **Example 7** (writer monad `TX = B × X`, comonad `DY = B × Y`, interaction `ψ((b, x), (b', y)) = (x, b · y)` for a fixed monoid `B`) and **Example 8** (update monad `TX = A ⇒ (B × X)`, comonad `DY = A × Y`, interaction `ψ(f, (a, y)) = f(a)` for a fixed `B`-action on `A`), ensuring the plan records their evaluation formulas, naturality proofs, and diagnostic expectations as canonical regression targets.
- Incorporate **Example 9** from Section 3: the free-semigroup monad `TX = X⁺` with the associative binary operation `db : X × X → TX` defined by `db(x₀, x₁) = [x₀, x₁]`. The plan must spell out how Theorem 3 forces any interacting monad to collapse to the zero monad and capture the induced initial-set witnesses inside the degeneracy tooling.
- Record **Example 14**’s refinement of Example 9: rebuild the quotient presentation `T = T₀ / ∼` where `T₀X = X + X × X` is the free monad on `F(X) = X + X × X`, the nonempty-list monad `TX = X⁺` is obtained by imposing the associativity equation for the binary operation `c_X : X × X → T₀X`, and the Sweedler dual `T^∘` embeds as the subcomonad of the cofree comonad on `G(Y) = Y + Y × Y` presented by the coequation displayed in Example 14. The roadmap must capture both the coequaliser diagram realising the quotient and the subobject inclusion witnessing the Sweedler dual.
- Reify the categorical statement that **monad–comonad interaction laws are monoid objects in `IL(𝒞)`**: plan the quasi-inverse equivalence between `MCIL(𝒞)` and `Mon(IL(𝒞))`, detailing how to extract multiplication/unit from `ψ`, reconstruct `ψ` from monoid structure, and log witnesses on objects/morphisms that certify the equivalence.
- Internalise Theorem 3’s **associative binary-operation degeneracy** in full detail: whenever a monad carries a natural family `c_X : TX × TX → TX` satisfying the associativity squares displayed in Section 3.2, every interaction law `ψ_{X,Y} : TX × DY → X × Y` must satisfy the comparison diagram equating `(ψ_{X,Y} ∘ (c_X × id))` with `(ψ_{X,Y} ∘ (id × D(c_Y)) ∘ (id × ψ_{X,Y}))`. The implementation plan must now also record how the proof decomposes `B × Y` as a coproduct `Y + Y` via distributivity, names the coprojections `ι_Y : Y → B × Y` and `κ_Y : Y → B × Y`, constructs the pulled-back maps `θ_{X,Y}` and `δ_{X,Y}`, and threads those morphisms through the long composite (culminating in the final string of `ψ`, `c`, `μ`, and `δ` arrows) so the eventual oracle can replay the proof step by step. These diagnostics must integrate with the Phase Ib metadata and surface the constant-zero witnesses whenever the degeneracy forces them.
- Incorporate **Theorem 4’s coassociativity ⇒ rectangularity** result for comonads: whenever a comonad `(D, ε, δ)` satisfies the coequation of coassociativity `δ_Y : DY → DDY` shown in Example 14 (with its composite through `DY + (Y + Y)`), the induced maps automatically obey left and right rectangularity. The plan must retain the labelled arrows from the proof (the factored coprojections and the comparison maps into `(Y + Y)`) so diagnostics can replay how the coequation forces the rectangular diagrams to commute.
- Integrate the resulting structure with the stateful runner semantics that appear later in the paper without losing any of the degeneracy metadata gathered in Phase I.
- Capture Section 3.3’s **structural operations on `MCIL(𝒞)`** explicitly: stretching along monad/comonad morphisms, Day-tensor products `(T₁, D₁, ψ₁) ⊗ (T₂, D₂, ψ₂)`, binary products `(T₀, D₀, ψ₀) × (T₁, D₁, ψ₁)`, the composite-monoid law for `T₁ ∘ T₀` subject to the commutation condition `(λ, id)_Y ∘ ψ₀,Y = (id_{T₁} × ψ₁) ∘ (ψ₀ × id_{D₁})`, and the **composite interaction law** displayed in the new material: whenever `(T₀, D₀, ψ₀)` and `(T₁, D₁, ψ₁)` are interaction laws with compatible distributive laws `ψ₀^{T₁}` and `ψ₁^{D₀}`, produce a law for the composite monad `T₁ ∘ T₀` and composite comonad `D₀ ∘ D₁` whose structure maps satisfy the commutative squares reproduced from the figure (the outer square involving `T₁ T₀ X × D₀ D₁ Y` and the inner ones tracking the distributive-law comparisons). Each construction needs explicit diagnostics that replay the proof squares and verify the required morphism equalities.
- Plan for the **free monad–comonad interaction law** described after the figure: when `𝒞` admits the initial algebras/final coalgebras that generate the free monad `F*`, the cofree comonad `G†`, and the auxiliary parameterised command `D(Y, W)` whose fibres decompose as the coproduct depicted (`FZ × GY` alongside `F(Y × W)`), reconstruct the natural transformation `ψ'_{X,Y,Z,W}` built from the indicated components (`id × fst`, `id × snd`, coproduct inclusions, and the base interaction law `ψ`). The roadmap must capture how restricting along a fixed monad (resp. comonad) yields an initial object in the slice category `MCIL(T, -)` (resp. final object in `MCIL(-, D)`), with explicit witnesses for the comparison morphisms into/out of the free law that enforce the universal property.

### Phase IIIa — Section 3.4 Dual/Sweedler Reinterpretation
#### Goals
- Translate every monad–comonad interaction law into the **dual/Sweedler dual** presentations shown in Section 3.4: given `ψ : D → T°` satisfying the commutation squares labelled `(1)` and `(2)` in the excerpt, provide equivalent data as a natural transformation `ψ : T → D°` and as a monoid map `(D°ε, οε, δ°)` from `D` to `T°` inside `[𝒞, 𝒞]`.
- Record that `(−)° : [𝒞^{op}, 𝒞]^{op} → [𝒞, 𝒞]` is **lax monoidal** (sending monoids to comonoids) but not oplax, so the plan must materialise explicit diagnostics whenever the attempted dual fails to preserve comonoid structure; document that `T°` typically lacks a comonad structure even when `T` is a monad.
- Formalise the Sweedler dual perspective: identify the **greatest comonad smaller than `T°`** satisfying conditions `(2)` as the Sweedler (finite) dual of `T`, and add roadmap hooks for constructing it alongside the interaction law derived from `ψ`.
- Restate the Sweedler dual definition exactly as in the text: a comonad `T^∘ = (T^∘, ε^∘, δ^∘)` equipped with a natural transformation `ι : T ⇒ T^∘` whose triangles `(3)` commute, and whose universal property guarantees every `ψ : D → T°` factors uniquely through a comonad map `h : D → T^∘` with `ψ = ι ∘ h`. Plan to capture the equivalence of categories `MCIL(𝒞) ≅ {(T, D, ψ : D → T°)} ≅ {(T, D, h : D → T^∘)}` as executable translators.
- Document how these duals determine **initial and final objects** in the slice categories `MCIL(𝒞)_{-, D}` and `MCIL(𝒞)_{T, -}` (respectively `(Id, D, …)`/`(D^∘, D, …)` and `(T, T^∘, …)`/`(T°, T, …)`), and ensure the plan captures Example 10/11’s observation that the Sweedler dual comonad generally has a different underlying functor from the raw dual `T°`.

#### Tasks
1. **Dual-characterisation adapters.**
   - Implement translators `interactionLawToDualMap(law)` and `interactionLawFromDualMap(φ)` that shuttle between a ψ-family and the natural transformation `φ : D → T°` (and symmetrically `φ' : T → D°`), explicitly recomputing the commutative squares labelled `(1)` and `(2)` from the paper.
   - Ensure the translators annotate each law with the component morphisms used in the diagrams (the counit `ε`, comultiplication `δ`, unit `η`, multiplication `μ`, and the evaluation arrows from the dual), logging any failure points as diagnostics compatible with our oracle framework.
2. **Lax-monoidal witnesses.**
   - Provide utilities that compute the lax-monoidal structure maps of `(−)°` on endofunctors (`m_{F,G} : F° ⊗ G° → (F ⋅ G)°`, `e : I → Id°`) and integrate them into the translators so that verifying a ψ supplied as a dual morphism also checks the lax-monoidal coherence used in the excerpt’s string diagrams.
   - Add counterexample hooks that demonstrate why `(−)°` is not oplax in general: store failing composites when attempting to map comonoids to comonoids, along with the proof obligations that break (missing comparison for `m_{T,T}` or lack of `T°` comultiplication).
3. **Sweedler dual constructors.**
   - Expand the plan’s dual helper suite with a `sweedlerDualMonad(T)` constructor that produces a witnessed comonad `(T^∘, ε^∘, δ^∘)` together with the structure map `ι : T ⇒ T^∘`, guaranteeing the triangles `(3)` commute by construction.
   - Schedule an oracle `checkSweedlerDualInteraction(T, T^∘, ι)` that replays the Section 3.4 argument: verify diagrams `(2)`, confirm maximality by testing any other comonad map `φ : D' → T°`, and report the unique factorisation witness `h : D' → T^∘` with `ψ = ι ∘ h`.
   - Ensure the constructor tracks both the comparison `T^∘ ⇒ T°` and the evaluation witnesses so diagnostics can highlight how the Sweedler dual’s underlying functor differs from `T°` in examples.
4. **Slice objects, equivalence translators, and worked examples.**
   - Implement translators realising the categorical equivalences `MCIL(𝒞) ≅ {(T, D, ψ : D → T°)}` and `MCIL(𝒞) ≅ {(T, D, h : D → T^∘)}`, emitting explicit zig-zag witnesses when round-tripping between interaction laws, dual maps, and Sweedler dual factorizations.
   - Provide constructors for the initial/final objects in the slice categories—`initialMCILMinusD()`, `finalMCILMinusD()`, `initialMCILTMinus()`, `finalMCILTMinus()`—using the Sweedler dual data `(Id, D, …)`, `(D^∘, D, …)`, `(T, T^∘, …)`, `(T°, T, …)` spelled out in the excerpt and storing their universal comparison morphisms for oracle use.
   - Extend the plan with targeted regression scenarios for Example 10 (free semigroup monad) and Example 11 (A-bimodule-based writer-style monad) that compare the raw dual `T°` and the Sweedler dual `(T^∘, ι)`, logging the differing carrier descriptions given in the article (length-indexed evaluations versus evaluation-by-weight records) and ensuring the oracles expose the discrepancy constructively without hard-coding a single carrier presentation.
5. **Documentation/tests integration.**
   - Update Phase III tests to include at least one interaction law exercised through the dual-characterisation translators and Sweedler dual factorisation, checking equality of the reconstructed ψ with the original and verifying the lax-monoidal comparison maps.
   - Plan additions to `LAWS.md` that explain the dual/Sweedler reinterpretation, the limitations arising from lack of oplaxity, how the Sweedler dual helper recovers the “greatest interacting comonad”, and how the new slice-object constructors realise the stated initial/final objects.

### Tasks
1. **Adapters for existing monads/comonads.**
   - Create helpers that map `MonadWithWitness`/`ComonadWithWitness` instances into `FunctorInteractionLaw` values, extracting the underlying functors and Kleisli/coKleisli structure needed to form `ψ`.
   - Encode the “just returning” sequential interpretation explicitly: store the canonical comparison natural transformations `TX × DY → T(X × DY) → X × Y` that arise from the monad multiplication acting after the comonad observation.
   - Materialise the concrete adapters for Example 7 (writer monad/comonad pair) and Example 8 (update monad/comonad pair), recording their `ψ` formulas, the required monoid action witnesses, and the naturality derivations so they serve as reference implementations for later diagnostics.
2. **Monoid/comonoid packaging and composites.**
   - Implement constructors that equip interaction laws with monoid/comonoid structure data (unit `u : I → law`, multiplication `m : law ⊗ law → law`, counit, comultiplication) expressed via Day convolution transports; ensure the coherence diagrams from Section 3 commute via explicit witness computations.
   - Provide convenience accessors for stateful runner interpretations (Section 4) that package `ψ` together with the induced runner maps `run_T^D : TX × DY → Y` and `observe_T^D : TX × DY → X`, reusing the exact string diagrams from Definition 4.1 so later phases can compare them with the stand-alone runner axioms.
   - Build the quasi-inverse functors realising the `MCIL(𝒞) ≅ Mon(IL(𝒞))` equivalence: (a) from an interaction law, extract the monoid object (multiplication/unit) within `IL(𝒞)`; (b) from a monoid object, reconstruct `ψ`; (c) verify functoriality on morphisms and provide oracles that certify the zig-zag identities up to equality in the category.
   - Implement the composite interaction-law constructor `composeInteractionLaws((T₁, D₁, ψ₁), (T₀, D₀, ψ₀))`, ensuring the compatibility squares from the figure commute. Diagnostics must log the intermediate distributive-law lifts `ψ₀^{T₁}` and `ψ₁^{D₀}`, verify the canonical comparison maps `T₁T₀X × D₀D₁Y → T₁X × D₁Y` and `TX × DY → X × Y`, and store witnesses for each of the labelled sub-squares.
   - Define `freeInteractionLaw(F, G, ψ)` that constructs the free/cofree pair `(F*, G†, ψ')` by executing the coproduct recipe from the text, recording the injections used (`id × fst`, `id × snd`, etc.), and packaging the universal comparison maps into the resulting law. Expose helper constructors for the slice categories `MCIL(T, -)` and `MCIL(-, D)` that pin a monad or comonad and produce the canonical initial/final objects together with their universal arrows.
3. **ψ-law coherence oracles and free objects.**
   - Introduce `checkMonadComonadInteractionLaw(law)` that verifies the four defining diagrams: (i) left unit (`ψ ∘ (η × id) = ⟨id, ε⟩`), (ii) right counit, (iii) compatibility with `μ`/`δ`, and (iv) the mixed associativity square; each check must return the concrete morphism witnesses obtained from the Day pairing carriers.
   - Extend `oracles/interaction-laws.ts` with logging of the sequential/behavioural interpretations and integrate Example 6 as a canonical passing instance; include counterexample reconstruction when any diagram fails.
   - Add an oracle `checkFreeInteractionLaw` that reconstructs the coproduct-based definition of `ψ'` and verifies that the resulting law is initial in `MCIL(T, -)` and final in `MCIL(-, D)` once the base category supplies initial algebras/final coalgebras. The oracle should expose the canonical morphisms from arbitrary laws into the free one (respectively from the free one into arbitrary laws) and verify the universal property via explicit comparison witnesses.
4. **Example 14 quotient/Sweedler instrumentation.**
   - Provide constructors `nonemptyListFreeMonad()` and `nonemptyListQuotient()` that realise the free monad `T₀` on `F(X) = X + X × X`, package the binary operation `c_X : X × X → T₀X`, and impose the associativity equation by forming the explicit coequaliser depicted in Example 14. Record the universal arrows `q : T₀ → T` and the witnesses for the generators/relations so diagnostics can recover the quotient presentation.
   - Implement `sweedlerDualNonemptyList()` that embeds the Sweedler dual `T^∘` into the cofree comonad on `G(Y) = Y + Y × Y`, storing the subcomonad inclusion and the coequation of coassociativity `δ^∘` shown in the example (with its iterated coproduct factors). Ensure the helper exposes the evaluation and coevaluation maps needed to compare with the generic Sweedler dual builder from Phase IIIa.
   - Extend the free/quotient oracle suite with `checkNonemptyListQuotient()` and `checkNonemptyListSweedler()` that replay the Example 14 diagrams, verifying that the imposed associativity relation indeed yields the nonempty list monad and that the Sweedler dual inclusion preserves comultiplication/counit. Diagnostics must log the coproduct summands, the `c_X` composites, and the inclusion maps into the cofree comonad.
5. **Associative binary-operation degeneracy tooling.**
   - Implement an oracle `checkAssociativeBinaryDegeneracy` that takes a monad operation `c_X : TX × TX → TX` and an interaction law `ψ` and verifies Theorem 3’s diagram by replaying the proof’s three-stage composite: (i) build the distributivity square that turns `B × Y` into the coproduct `Y + Y` with coprojections `ι_Y`, `κ_Y`, (ii) pull `θ_{X,Y}` and `δ_{X,Y}` back along those coprojections to obtain the intermediate morphisms `h_Y`, `k'_Y`, `k_Y`, and (iii) chase the big associativity diagram that compares `ψ_{X,Y} ∘ (c_X × id)` to `ψ_{X,Y} ∘ (id × D(c_Y)) ∘ (id × ψ_{X,Y})` by enumerating the labelled arrows from the proof (the `θ`, `δ`, `μ`, `ψ`, and diagonal maps shown in the scanned figures).
   - Ensure the oracle logs each stage explicitly: report the reconstructed coproduct/pullback witnesses, list every intermediate morphism (`h_Y`, `k'_Y`, `k_Y`, the two maps out of `X × X × PY`), and capture the final calculation that chains `ψ`, `c`, `μ`, and `δ` so counterexamples point to the precise arrow where equality fails. Tie these diagnostics into Phase Ib’s degeneracy metadata so constant-zero collapses are reported when the diagram forces them.
6. **Theorem 4 rectangularity diagnostics.**
   - Implement a helper `coassociativityCoequation(D)` that materialises the coequation `DY \xrightarrow{δ_Y} DDY ⇉ D(Y + Y)` featured in Theorem 4, *together with the pullback data used in the proof*: compute the pullbacks of `c_Y ∘ δ_Y` along the coproduct coprojections `inl_Y, inr_Y`, record the resulting objects `P_Y`, `Q_Y`, and store the induced inclusions `i_Y : P_Y → DY`, `j_Y : Q_Y → DY` plus the comparison maps `cδ_Y`, `cε_Y` back into `DY + DY`. The helper must also register the distributivity map `DY → D(Y + Y)`, the iterated coproduct legs (`DY → DY + DY`, `(Y + Y) → Y + Y + Y + Y`), and the coequaliser witness `g_Y` that identifies the two triangles highlighted in the scanned proof.
   - Add an oracle `checkRectangularityFromCoequation(D, data)` that verifies the left and right rectangular diagrams commute whenever the coassociativity coequation holds. The oracle should explicitly replay both proof steps: (i) use extensivity to show `(DY, i_Y, j_Y)` is the coproduct of `P_Y` and `Q_Y`, logging the stability-of-coproducts reasoning, and (ii) compare the two morphisms `(cε_Y + δ_Y) ∘ cδ_Y` and `(Y + inr_Y) ∘ cε_Y` (respectively the dual pair for left rectangularity) by chasing them through the common coequaliser `g_Y`. Diagnostics must emit witnesses for each of the labelled arrows (`i_Y`, `j_Y`, `cδ_Y`, `cε_Y`, `g_Y`, the pullback projections) and record the concluding equality `(ε_Y + id_Y) ∘ cδ_Y = (id_Y + ε_Y) ∘ cδ_Y` that realises right rectangularity.
   - Integrate this oracle with the Sweedler dual helpers so that when `T^∘` is constructed via Example 14 the rectangularity diagnostics automatically certify the coassociativity constraints inherited from the cofree comonad, and ensure the log mentions how the same pullback argument delivers the left corectangularity equality.
7. **Structural operations for `MCIL(𝒞)`.**
   - Implement **stretching** for monad–comonad interaction laws: given a monad morphism `f : (T, η, μ) → (T', η', μ')` and a comonad morphism `g : (D, ε, δ) → (D', ε', δ')`, construct `(T', D', ψ')` with `ψ' = (id × g) ∘ ψ ∘ (f × id)` and verify the four ψ-coherence diagrams using the morphism compatibility conditions.
   - Realise the **Day convolution product** of interaction laws by reusing the functor-level tensor from Phase I: build `(T₀ ⊗ T₁, D₀ ⊗ D₁, ψ₀ ⊗ ψ₁)` with evaluation witnesses that project to each factor, and add oracles that check the resulting law satisfies the monad/comonad coherence squares.
   - Implement the **binary product** `((T₀, D₀, ψ₀) × (T₁, D₁, ψ₁))` using categorical products of monads/comonads when available, explicitly documenting the projection interaction laws and verifying their universal property via diagnostics.
   - Add constructors/oracles for **composite monad interaction laws**: given `T₀`, `T₁`, a monad–comonad law `(T₀, D, ψ₀)`, and a monad interaction law `(T₁, D, ψ₁)` satisfying the Section 3.3 commutation condition, produce `(T₁ ∘ T₀, D, ψ)` and log the verification that the defining square commutes.
   - Extend testing to cover Example 9’s collapse, the Day product, and the composite-monoid law, ensuring diagnostics expose any failure to meet the compatibility condition `(λ, id) ∘ ψ₀ = (id_{T₁} × ψ₁) ∘ (ψ₀ × id_{D₁})` highlighted in the raw material.
   - Add helper constructors that automatically supply `c_X` for associative monads encountered in the examples (e.g., writer/update monads) and record when the degeneracy condition collapses the interaction law to a trivial runner, storing the coproduct witnesses (`ι_Y`, `κ_Y`) alongside the resulting zero maps for reuse in oracle output.
8. **Testing.**
   - Add `test/interaction-laws.spec.ts` covering (a) Example 6, (b) a finite toy monad/comonad pair from existing infrastructure, and (c) a negative test where one coherence square is intentionally violated to ensure diagnostics surface the failing component.
   - Reuse degeneracy metadata from Phase Ib within the tests so nullary/binary collapses trigger construction of the final interaction law automatically when applicable.
   - Extend the spec suite with concrete runs of Example 7, Example 8, and an associative-operation scenario to ensure Theorem 3’s oracle surfaces the expected behaviour and to validate the `MCIL(𝒞) ↔ Mon(IL(𝒞))` translators.
   - Add regression coverage for `composeInteractionLaws` (checking each labelled sub-square and the overall composite square) and for `freeInteractionLaw`, including explicit verification of the initial/final universal properties in the slice categories `MCIL(T, -)` and `MCIL(-, D)` via constructed comparison morphisms.
9. **Documentation and LAWS.md integration.**
   - Expand `LAWS.md` with a dedicated “Monad–Comonad Interaction Laws” entry summarising the ψ definition, the four coherence diagrams, Example 6, and the associated oracle/test suite.
   - Document how the monoid/comonoid packaging aligns with Hasegawa’s glueing, the `MCIL(𝒞) ≅ Mon(IL(𝒞))` equivalence (including diagnostic hooks), the associative binary-operation degeneracy oracle, and note the entry points for stateful runners so future phases can wire in residual extensions.

## 4. Phase IV — Stateful Runners and Residual Interaction Laws
### Goals
- Internalise **Definition 2.2** (Runners for a signature): for each algebraic signature `Σ = {op}` with parameter object `A_op` and result object `B_op`, a runner consists of a carrier set `|ℛ|` together with co-operations `op_ℛ : A_op × |ℛ| → B_op × |ℛ|` (equivalently, curried maps `A_op → |ℛ| → B_op × |ℛ|`) that determine how the runtime configuration evolves when an operation `op(a, k)` reaches the top level. Record explicitly that, given configuration `c ∈ |ℛ|`, the co-operation returns a pair `(b, c')` with the updated configuration `c'`, and the continuation proceeds in state `c'`. Note that runners for full theories `𝒯` arise when the co-operations also satisfy the equational theory `Eq_𝒯`—useful later for homomorphic interaction-law definitions even if the current phase focuses on signatures—and that Definition 2.2 packages these co-operations into the monad morphism `ρ_T : Tree_Σ ⇒ St_{|ℛ|}` granted by the universal property of the free `Σ`-monad. **Proposition 3** then states that monad morphisms `Tree_Σ ⇒ T` are in one-to-one correspondence with `T`-runners for `Σ`; ensure the roadmap requires us to construct both directions explicitly (co-operations from a monad map and the monad map from co-operations) and to cache the family `ρ_{T,X}` arising from structural recursion on computation trees.
- Internalise **Definition 4.1**: a stateful runner of a monad `T = (T, η, μ)` is an object `Y` equipped with a family of morphisms `θ^X_Y : TX × Y → X × Y`, natural in `X`, satisfying the two runner axioms from the paper (unit compatibility `(η_X × id_Y); θ^X_Y = ⟨id_X, id_Y⟩` and multiplication compatibility `(μ_X × id_Y); θ^X_Y = (TX × θ^X_Y); θ^{TX}_Y`).
- Inline Section 2.1’s **algebraic effects and handlers** vocabulary so the runner workstreams have concrete data to manipulate: an algebraic signature `Σ_T = (A_{op}, B_{op})` listing operation arities together with the tree-forming constructors `op : Tree_Σ(X)^A_op → Tree_Σ(X)^B_op`, an `S`-structure `(M, ⟨m_op⟩)` interpreting each operation `op` as a map `A_op × M^{B_op} → M`, and the induced algebraic theory `(Σ_T, E_T)` whose equations capture substitution compatibility. Ensure Example 1’s state signature with operations `getenv : 1 ⇀ C` and `setenv : C ⇀ 1` (and the displayed equations that return the current state or overwrite it) is recorded verbatim so later phases can reuse the concrete terms and laws without consulting the source paper.
- Integrate **Section 3.1’s user/kernel split**: describe kernels as monads generated by a stateful signature extending `{getenv, setenv}` with any external-effect signature `Σ` so that their runners satisfy the three desiderata spelled out in the excerpt—(1) resource management and controlled finalisation, (2) ability to invoke further external resources, and (3) a failure channel for unavoidable errors. Encode the additional operations precisely as in the text: adjoin **exceptions** `raise : E → 1` via coproduct with the state theory, add **signals** `kill : S → 0` via the tensor with state, and record the displayed equations `getenv(λc. kill_s(c)) = kill_s` and `setenv(c, kill_s) = kill_s` showing that signals discard state entirely. Summarise the resulting kernel theory `K_{Σ,E,S,C}` as containing the `Σ`-operations, the state operations from Example 1, the exception nullaries, and the signal nullaries. Ensure the plan records that the same Σ-operations may be reused by outer layers of runners and that user code interacts with these kernel monads through supervised access rather than direct state manipulation.
- Capture the complementary **user theory** `U_{Σ,E,X}` chosen in the excerpt: user code calls operations from `Σ`, relies on supervised access to the kernel state, can raise and catch the kernel’s recoverable exceptions, but only observes fatal signals as runtime termination. Require the roadmap to retain the induced user monad (free algebra on `U_{Σ,E,X}`) together with the comparison morphisms into the kernel monad so later phases can model supervised effect boundaries directly.
- Reproduce the **λ_{coop} calculus** used in *Runners in Action*: model operation signatures, effect resources, and the syntactic forms `with open`, `try … finally …`, and `handle t with k` so the roadmap can tie categorical runners to the operational intuition of the paper’s introduction. Capture the promise of linear resource management (every opened handle is closed) and make space for effect-polymorphic handlers that dispatch on operations like `open`, `read`, and `close`.
- Inline **Section 4.2’s “Values and computations”** presentation so the roadmap keeps the concrete syntax in scope without consulting the source: values are variables, ground constants, `()` for unit, pairs `(V, W)`, injections `inl_X V`/`inr_X V`, user abstractions `fun (x : X) ↦ M`, kernel abstractions `funK (x : X) ↦ K`, and runner literals `{ (op x ↦ K_{op})_{op ∈ Σ} }^C` whose annotation `C` pins down the kernel state type that the bound computations `K_{op}` expect. Record that user computations `M, N` and kernel computations `K, L` share the usual pure terms and function application, but differ in their operation-call annotations: user calls are written `op_X^C(V; κ)` with result type `X`, whereas kernel calls carry both result and state annotations `op_X^C(V; κ)` plus explicit kernel-continuation types. Preserve the text’s note that annotations can be dropped when unambiguous, and that the binding form `let_{X,E} x = M in N` abbreviates a user `try` that routes the return case to `N` and each exception `e ∈ E` to `raise_X e`, with a dual kernel abbreviation.
- Inline the **type grammar from Figure 1** of the calculus: ground types built from base types (`unit`, `empty`, sums, products), value types including runner/function types (`X ↦ Y`, `X ↦ Y | u`, `X ↦ Y | k`), and kernel computation types `X ! {κ | Σ, E, S, C}` that record available co-operations, signals, and state components. Ensure the roadmap requires constructors for constant signatures `f : (A_1, …, A_n) ↦ B`, operation signatures `op : Σ` with their arity objects, and signal sets `S_op` so later passes can perform type-directed resource analysis.
- Restate **Section 4.3’s typing judgement vocabulary** so it is self-contained: contexts `Γ = x_1 : X_1, …, x_n : X_n`, value judgements `Γ ⊢ V : X`, user computation judgements `Γ ⊢ M : X ! (Σ, E, S, C)`, and kernel computation judgements `Γ ⊢ K : Y ! (Σ, E, S, C)` with explicit annotations for implemented operations `Σ`, recoverable exceptions `E`, signals `S`, and state object `C`.
- Record the **subtyping rules of Figure 3** verbatim to guide implementation: `Sub-Ground` (any ground type `A ∈ 𝔄` satisfies `Γ ⊢ A ≤ A`), `Sub-Runner` (widening runner capabilities requires supersets of implemented operations/state, i.e. `(Σ ⊆ Σ', S ⊆ S', C ⊑ C') ⇒ Γ ⊢ runner(Σ, S, C) ≤ runner(Σ', S', C')`), and `Sub-Kernel` (kernel computation types may only widen when both their runner annotations and failure metadata are extended appropriately). Emphasise that these are the only subtyping axioms; all other comparisons must be derived from them.
- Capture the **typing rules from Figure 3** explicitly so they can be encoded without reconsulting the paper: `TyUser-Op` for user operation invocations (requiring the continuation runner to implement the operation), `TyKernel-Op` for kernel operation calls with explicit state transitions, `TyUser-Try` for `try`/`raise` blocks with per-exception branches, `TyUser-Run` enforcing that supplied runners implement every operation mentioned in the ambient signature block `F`, and the cross-mode rules `TyUser-Kernel`/`TyKernel-User` that shuttle computations between user and kernel layers while preserving annotations. Note that each rule carries an explicit `Σ`, `E`, `S`, `C`, and (for `TyUser-Run`) a success continuation `M` plus handler bundle `(raise e ↦ N_e)_{e∈E}`—all of which must be stored for diagnostics.
- Restate **Section 4.4’s equational theory** verbatim so the roadmap no longer depends on the source: specify three equality judgements `Γ ⊢ V = V' : X` (values), `Γ ⊢ M = N : X ! K` (user computations), and `Γ ⊢ K = L : X ! K` (kernel computations). Record the runner-facing equations, including `run (return V) finally F = return V`, `run (raise^C_E e) finally F = raise^C_E e`, `run (kill^C_S s) finally F = kill^C_S s`, `run (op_X^C(V; κ)) finally F = K_{op}[V/x, κ'/k]` with kernel continuations wrapped in kernel mode, and `run (with K) finally F = with (run K finally F)` so that finalisation blocks commute with kernel execution. Capture the kernel-mode rules mirrored in the text—for the bundle `{return x ↦ K, (op z ↦ K_{op})_{op∈Σ}}^C`, execution of `op_X^C(V; κ)` produces `K_{op}[V/x, κ/k]`, `return` threads the continuation through the finaliser, and `kill` discards it—alongside the β/η laws for exceptions, reconstruction rules for `try`/`with`, and the `let_{X,E}` abbreviation. These equations will anchor the interpreter’s rewrite system and the diagnostics required later in this phase.
- Contrast runners with **handlers** exactly as described beneath equation (7): a handler is a multiplication algebra `(Z, α)` with `α : TZ → Z` obeying `α ∘ η_Z = id_Z` and `α ∘ μ_Z = α ∘ Tα`. The plan must retain these equations verbatim so the implementation can reconstruct diagram (7) and verify that every runner induces a handler via `θ^Z_Y` when `Y` is terminal, and conversely detect when a handler extends to a runner via the state monad construction.
- Treat runner morphisms explicitly: a runner map `f : (Y, θ) → (Y', θ')` must satisfy `(id_X × f) ∘ θ^X_Y = θ'^X_{Y'} ∘ (id_{TX} × f)` for every `X`, and these maps form the morphisms of the **`Run(T)`** category.
- Capture the **coalgebraic reformulation** supplied in the new material: runner maps are coalgebra maps between the induced `T°`-coalgebras `(Y, γ)` and `(Y', γ')`, so the plan must store the natural transformation `γ_X : TY × X → X × Y` associated with each runner and reconstruct the commutative square labelled `(4)` even though `T°` is only lax-comonadic (its multiplication `m_{T°}` is typically non-invertible).
- Record the **costate comonad** viewpoint verbatim: for every object `Y`, `Cost^Y(Z) = (Y ⇒ Z) × Y` with counit `ε^Y(f, y) = f(y)` and comultiplication `δ^Y(f, y) = (f, y)`. The plan must require runners to be equivalent to natural transformations `γ : Cost^Y ⇒ T` that satisfy the diagram `(5)` from the excerpt and treat these `γ`’s as first-class witnesses alongside `θ`.
- Summarise the isomorphic categories enumerated beneath equation `(5)`—runners of `T`, natural maps from `T` to `St^Y`, `T°`-coalgebras obeying `(4)`, natural transformations `Cost^Y ⇒ T` obeying `(5)`, comonad coalgebras of `Cost^T`, and coalgebras of the Sweedler dual `T^∘`—and ensure the implementation roadmap provides concrete translators and diagnostics for each equivalence.
- Relate runners to interaction laws and Sweedler duals: reproduce the bijection between stateful runners, monad–comonad interaction laws `(T, D, ψ)`, and coalgebraic runner specs as described in Section 4.2, including the explicit formulas turning a `ψ` into a runner and back (restricting along the cofree coalgebra and Day convolution fibres).
- Re-state the concluding observation that the **handler-induced runner map** and the **state runner map** both collapse to the evaluation morphism `ev_Y : T°Y × Y → Y`; ensure the roadmap requires explicit witnesses that `θ^X_Y` factors through this evaluation when translated via the `T°`-coalgebra/Costate equivalences.
- Encode **Example 12** in detail: update lenses `(hp : Y → A, upd : Y × B → Y)` give rise to runners of the update monad `TX = A ⇒ (B × X)`; plan reusable constructors/oracles that witness the bijection between update lenses, runners, `Cost^Y`-transformations, and coalgebras.
- Extend the plan’s residual-law preparation so machines that only realise a subset of effects are modelled via partial runners, keeping compatibility with the nullary/binary degeneracy metadata gathered in Phases Ib–III.

### Tasks
0. **Algebraic signatures, theories, and Example 1.**
   - Create a shared module (e.g., `algebraic-effects.ts`) that encodes algebraic signatures `Σ = {op}` with parameter objects `A_op`, continuation result sets `B_op`, and the induced computation tree functor `Tree_Σ`. Provide constructors that store both the operation metadata and the tree-forming constructors mentioned in the excerpt so substitution and Kleisli reasoning can reference them directly.
- Extend the signature module with explicit runner co-operations: for every runner carrier `|ℛ|`, represent the structure maps `op_ℛ : A_op × |ℛ| → B_op × |ℛ|`, cache their curried forms `A_op → |ℛ| → B_op × |ℛ|`, and supply utilities that, given an operation `op(a, k)` and configuration `c`, compute the updated configuration `(b, c')` and resume the continuation `k(b)` in state `c'`. Ensure diagnostics record both the uncurried and curried witnesses so later phases can compare them against the Definition 4.1 `θ`-maps, and reconstruct the associated free-monad morphism component `ρ_{T,X} : Tree_Σ(X) → St_{|ℛ|}(X)` by structural recursion on trees (return nodes, operation nodes) to honour the universal property captured in the excerpt.
- Provide explicit translators promised by **Proposition 3**: implement `runnerToMonadMap` and `monadMapToRunner` so that, for every signature `Σ` and monad `T`, we can toggle between a `T`-runner and a monad morphism `Tree_Σ ⇒ T`; equip the translators with diagnostics proving they are mutual inverses by replaying the recursive clauses on generators (return, operation) spelled out in the proof.
   - Define `S`-structures `(M, ⟨m_op⟩)` as records assigning to each operation a morphism `m_op : A_op × M^{B_op} → M`, bundle the associated algebraic theory `(Σ, E)` equations, and expose helpers that translate these structures into monads/handlers used elsewhere in the roadmap.
   - Materialise Example 1’s theory of `C`-valued state explicitly: implement operations `getenv : 1 → C` and `setenv : C → 1` together with the three equations spelled out in the excerpt—reading immediately after a `setenv` returns the continuation unchanged, consecutive `setenv` calls collapse to the most recent update, and `setenv` overwrites the stored state. Provide diagnostics that replay each law using the algebraic-structure helpers so the plan carries runnable witnesses of the state theory.
- Extend the module with **Example 2’s exceptions theory** by introducing nullary operations `raise_e` for each `e ∈ E`, constructing the term algebra `Tree_{Σ_T}(X)` of well-founded computation trees, and quotienting by the congruence `≈` generated by `Eq_T` to obtain `Free_T(X)`. Implement the Kleisli extension `f^†` exactly as in the excerpt, ensure the `return`/`op` rewrite rules are stored alongside diagnostics, and build helpers that realise handlers as the unique `T`-homomorphisms `Free_T(X) → M` given a model `(M, ⟨m_op⟩)`. Add regression targets that compare the induced monad with the textbook exceptions monad `Exc_E(X) ≅ X + E` and replay the state example `St_C(X) ≅ (C × X)^C` for contrast.
- Build on the preceding theory module to materialise the **kernel monad** `K_{Σ,E,S,C}` by first forming the coproduct of the state theory with the exception theory (adding operations `raise_e`) and then tensoring with the signal theory (operations `kill_s`). Record the displayed equations `getenv(λc. kill_s(c)) = kill_s` and `setenv(c, kill_s) = kill_s`, and provide constructors that assemble the free algebra on this combined theory into the monad used for kernel code. Cache the canonical inclusions of `Σ`, state, exception, and signal operations so diagnostics can report how each component contributes to a runner.
- Define the **user monad** `U_{Σ,E,X}` as the free algebra on the user theory `U_{Σ,E,X}` described above—operations from `Σ`, access to recoverable exceptions, but no direct state manipulation—and expose comparison morphisms into the kernel monad (e.g., `ι_user : U_{Σ,E,X} ⇒ K_{Σ,E,S,C}`) that witness supervised execution. Require regression artefacts that replay the motivating examples (user/kernel, browser/web page, OS/hardware) and log how user computations invoke kernel operations solely through these morphisms.

1. **λ_{coop} front end and examples.**
   - **Type system core.** Implement the Figure 3 subtyping relation (`Sub-Ground`, `Sub-Runner`, `Sub-Kernel`) as first-class data structures with proof witnesses, and add diagnostics that refuse invalid widening attempts when operation/state annotations shrink.
   - **Typing derivations.** Encode each Figure 3 typing rule as a constructor that consumes proofs of its premises and emits a structured derivation object. Provide helper functions such as `deriveUserOp`, `deriveKernelOp`, `deriveUserRun`, and `deriveUserTry` that mirror the rule names, log the annotations they consume (`Σ`, `E`, `S`, `C`, runner block `F`, success continuation), and store traces of the resulting judgement for later oracle replay.
   - Introduce a syntactic layer `lambda-coop.ts` that codifies the basic forms described in the paper’s introduction: resource declarations, command sequencing, the `using` block that ensures finalisation, and handler definitions with operation clauses `op x k ↦ body`. Ensure the syntax supports the examples `with open "hello.txt" in … finally close` and the nondeterministic handler shown in the excerpt.
   - Provide an operational semantics driver that interprets λ_{coop} phrases into monad computations guarded by runner maps: mimic the evaluation order that opens a file, writes to it, and guarantees the finaliser executes even when handlers branch nondeterministically.
   - Add regression examples that replay the “virtual machine” intuition from the introduction: a runner that exposes a restricted subset of operations (`{open, write, close}`), a computation that interleaves them, and diagnostics confirming the finaliser runs exactly once per acquired resource.
   - Extend the AST with the Section 3.2 syntactic categories—distinguish user computations (`M, N`), kernel computations (`K, L`), and values (`V, W`)—so type checkers and interpreters can enforce the separation at compile time.
   - Implement the Section 4.2 value forms verbatim: variables, ground constants, unit `()`, pairs `(V, W)`, injections `inl_X V`/`inr_X V`, user abstractions `fun (x : X) ↦ M`, kernel abstractions `funK (x : X) ↦ K`, and runner literals `{ (op x ↦ K_{op})_{op ∈ Σ} }^C`. Track the runner annotation `C` in the AST so later phases know which kernel state object each co-operation expects.
   - Implement the Figure 1 type grammar: add constructors for base types (`unit`, `empty`), sum/product types, signature types `f : (A_1, …, A_n) ↦ B`, operation signatures `op : Σ`, signal sets `S_op`, user/kernelfunction types (`X → Y`, `X ⇀ Y`, `X ⇒ Y` with runner annotations), and kernel computation types `X ! {κ | Σ, E, S, C}` that bundle the available co-operations, exception family, signal family, and state object. Equip the type checker with resource-accounting metadata (which signatures, signals, and state components a term depends on) to prepare for the supervised-type analysis promised later in the paper.
   - Encode the user/kernel computation forms highlighted in Section 4.2: pure return `return_X V`, application `M V`/`K V`, exception raising `raise_X e`, user `try`/kernel `try` with per-exception branches, and operation invocations that carry explicit annotations (user: `op_X^C(V; κ)`, kernel: `op_X^{C,S}(V; κ)` with the state update type). Ensure kernel operation nodes record both the result type `X` and the kernel state type `C`, while user operation nodes remember the supervised continuation type.
   - Encode the Benton–Kennedy style exceptional syntax from Section 3.2: supply constructors for user-level `try M with { return x ↦ N_return, raise e ↦ N_raise(e) }` and kernel-level `try K with { return x ↦ L_return, raise e ↦ L_raise(e) }`, threading both the return continuation and the per-exception handlers through the AST.
   - Add explicit support for the `let_{X,E} x = M in N` abbreviation (and its kernel analogue): implement desugaring routines that translate the notation into the corresponding `try`/`raise` forms, and surface diagnostics reminding callers that annotations may be omitted when type inference can recover them.
   - Update the small-step semantics so user `try` blocks delegate to kernel handlers as described: raising within user code triggers the kernel branch, while kernel raises propagate through the supervised environment. Log diagnostics that show the return branch performs the promised resource finalisation exactly once.

2. **Runner data types and helpers.**
   - Introduce `StatefulRunner<T>` storing the carrier object `Y`, the natural family `θ^X_Y`, the associated `T°`-coalgebra structure `γ_Y : Y → T°Y`, and cached witnesses that the Definition 4.1 diagrams commute; add helper constructors that derive `θ` from a monad–comonad interaction law `ψ` via `θ^X_Y := ψ_{X,Y}` specialised to the machine comonad states.
   - Provide utilities `runnerUnitDiagram` and `runnerMultiplicationDiagram` that rebuild the two axioms for diagnostics, logging each morphism in the string diagrams shown in the excerpt, together with a `runnerCoalgebraDiagram` checker that verifies equation `(4)` by comparing `T°(f)` against `γ' ∘ f` and explicitly recovering the evaluation morphism `ev_Y` when `θ^X_Y` is post-composed with the canonical projection `TX × DY → T°Y × Y`.
3. **Handler comparison and state monad maps.**
   - Model handlers explicitly as multiplication algebras `(Z, α)` with `α : TZ → Z` satisfying equation (7); supply constructors `makeHandler(Z, α)` that store witnesses for the unit and associativity equalities `α ∘ η_Z = id_Z` and `α ∘ μ_Z = α ∘ Tα`.
   - Implement translators between handlers and runners when `Y` is terminal: given `θ`, construct the induced handler `α := π_1 ∘ θ^Z_Y ∘ ⟨η_Z, !⟩`; conversely, given a handler, detect whether there exists `Y` and `ϑ : T ⇒ St^Y` extending it to a runner, replaying the Example 2 universal-property equations `h^†[return x] = h(x)` and `h^†[op(a, k)] = m_op(a, λx. h^†(k(x)))` when building the associated `T`-homomorphism.
   - Recreate the **runner-as-monad-map** diagram from the “Runners vs. handlers” section: verify that a natural transformation `ϑ : T ⇒ St^Y` satisfies `(St^Y μ_X) ∘ ϑ_{TX} = (St^Y ϑ_X) ∘ ϑ_{St^Y X} ∘ Tϑ_X` and `(St^Y η_X) ∘ ϑ_X = η^{St^Y}_X`, logging each component of the diagram displayed beneath equation (7). Diagnostics must record counterexamples whenever the monad-map equalities fail.
   - Provide an oracle `compareHandlerAndRunner` that, given `θ` and `α`, checks whether they correspond under the above translations and highlights missing state data when a handler cannot be lifted to a runner.
4. **Category `Run(T)`.**
   - Implement runner morphisms `makeRunnerMap(f, θ, θ')` and an equality checker that validates `(id_X × f) ∘ θ^X_Y = θ'^X_{Y'} ∘ (id_{TX} × f)` objectwise while simultaneously confirming the coalgebra condition `(T° f) ∘ γ = γ' ∘ f`; expose `identityRunnerMap` and `composeRunnerMaps` to show `StatefulRunner<T>` objects with these morphisms form a category.
   - Add an oracle `checkRunnerCategory` that enumerates representative objects/arrows, confirming associativity/unitality of composition, reporting counterexamples with the offending `X`, and logging whether any coalgebra square fails.
5. **Costate comonad translators.**
   - Implement constructors `costateComonad(Y)` and utilities `runnerToCostateTransformation`/`costateTransformationToRunner` that encode natural transformations `γ : Cost^Y ⇒ T` obeying diagram `(5)`; include diagnostics that reconstruct `(5)` explicitly using the evaluation map `ε^Y` and the diagonal `δ^Y`.
   - Provide a `checkCostateCondition` oracle that replays equation `(5)` and reports the exact component morphisms when it fails.
6. **Equivalences with interaction laws and dual coalgebras.**
   - Define translators `runnerFromInteractionLaw(T, D, ψ)` and `interactionLawFromRunner(T, θ)` that materialise the equivalence between `ψ`-families and runners, reusing the Sweedler dual adapters from Phase IIIa to express the same data as coalgebras `γ : Y → T°Y` and logging how the induced `θ^X_Y` factors through the shared evaluation map `ev_Y`.
   - Supply inverse translators and structured diagnostics proving the zig-zag equalities, including the factorisation `DY ≅ T°Y` promised in the excerpt and the remark that runners of `T` correspond to coalgebras of the comonad `Cost^T`.
7. **Category-level isomorphisms.**
   - Build explicit quasi-inverse functors demonstrating the six-way equivalence highlighted under the new material: `Run(T)`, the category of natural maps `T ⇒ St^Y`, the subcategory of `T°`-coalgebras satisfying `(4)`, the category of costate transformations `(Cost^Y ⇒ T)` satisfying `(5)`, comonad coalgebras of `Cost^T`, and coalgebras of the Sweedler dual `T^∘`.
   - Attach oracles that confirm each functor preserves identities/composition and emits witness data (e.g., the natural transformation components `θ`, `γ`, costate morphisms) when the verification succeeds.
8. **Example 12 toolkit.**
   - Package update-lens data `(hp, upd)` into a concrete runner via the formula `θ^X_Y(f, y) = let (b, x) = f(hp(y)); (x, upd(y, b))`, verify the runner axioms, reconstruct the corresponding costate transformation and `T°`-coalgebra, and expose conversions back to update lenses and comonad coalgebras as described in the text.
   - Add regression tasks ensuring the bijection between runners of the update monad, costate transformations, and coalgebras of `DM = A × (B ⇒ -)` is executable and yields the promised isomorphism of categories.
9. **Residual interaction hooks.**
   - Extend `FunctorInteractionLaw`/`StatefulRunner` records with residual-evaluator slots that store partial effect handlers (when `θ` is defined only on a subobject of `TX × Y`), plus diagnostics that note which effects are unsupported.
   - Implement `makeResidualInteractionLaw`/`attachRunner` constructors that now return structured TODO diagnostics summarising the missing witnesses (instead of empty placeholders), referencing Sections 4–5 to guide future work.
10. **Oracles and documentation.**
   - Create `checkStatefulRunner` returning detailed pass/fail information for the Definition 4.1 diagrams, the runner-map equation, the coalgebraic diagrams `(4)`/`(5)`, and the evaluation collapse `θ^X_Y = ev_Y ∘ ⟨γ_Y, id_Y⟩`; integrate it with `checkMonadComonadInteractionLaw` so interaction laws automatically surface their associated runners.
   - Update `LAWS.md` with a “Stateful Runners” entry outlining the definition, the `Run(T)` category, the six-way categorical equivalence, Example 12’s update lens correspondence, and pointers to the new translators/oracles.
   - Add planning tests that cover at least one successful runner (Example 12) and one failing morphism, ensuring diagnostics identify whether the failure comes from Definition 4.1, equation `(4)`, or equation `(5)`.

### Phase IVb — R-residual Stateful Runners (Section 5.3)
#### Goals
- Restate Section 5.3’s generalisation verbatim: fix a **residual monad** `R = (R, η^R, μ^R)` on `𝒞`. An **`R`-residual runner** of a monad `T = (T, η, μ)` is an object `Y` equipped with a natural family of arrows
  
  `θ^X_Y : TX × Y → R(X × Y)`
  
  satisfying the runner axioms lifted through `R`:
  - **Unit compatibility:** `(η_X × id_Y); θ^X_Y = η^R_{X × Y} ∘ ⟨id_X, id_Y⟩`.
  - **Multiplication compatibility:** `(μ_X × id_Y); θ^X_Y = (TX × θ^X_Y); θ^{TX}_Y` followed by the residual monad’s multiplication `μ^R_{X × Y}` (as shown in the excerpt’s displayed equation).
- Capture the morphism condition verbatim: a map of `R`-residual runners `f : (Y, θ) → (Y', θ')` must satisfy
  
  `(id_{TX} × f); θ'^X_{Y'} = θ^X_Y; R(id_X × f)`
  
  for every `X`, i.e. the square with top arrow `θ^X_Y`, bottom arrow `θ'^X_{Y'}`, left leg `id_{TX} × f`, and right leg `R(id_X × f)` commutes.
- Record that these structures form the category **`Run_R(T)`**, whose objects are residual runners and whose morphisms are the maps described above.
- Internalise the stated isomorphism of categories: `Run_R(T)` is equivalent to the category of objects `Y` endowed with a monad map `ϑ : T ⇒ S^{t,Y}_R`, where `S^{t,Y}_R(X) = R(X × Y)` is the **`R`-transformed state monad**. The plan must capture the bijection between the natural transformations `θ^X_Y` and the monad-map components `ϑ_X : TX → R(X × Y)` (with their commutative triangles).
- Prepare to extend the residual/stateful bridge: ensure later residual interaction laws (Phase V) can restrict to `R`-residual runners via the same `θ/ϑ` data and that diagnostics retain Kleisli-pure annotations introduced earlier.

#### Tasks
1. **Residual runner data types.**
   - Define `ResidualStatefulRunner<T, R>` storing `Y`, the family `θ^X_Y`, and cached witnesses for the two `R`-lifted diagrams (unit/multiplication with `η^R`/`μ^R`).
   - Provide constructors that derive `θ` from monad maps `ϑ : T ⇒ S^{t,Y}_R`, reusing the residual law infrastructure to ensure the components align with `θ^X_Y` after precomposition with the canonical pairing `TX × Y → TX × Y`.
   - Extend the earlier `StatefulRunner` helpers so choosing `R = Id` recovers the ordinary runners (unit/multiplication diagrams reduce to those in Definition 4.1).
2. **Morphisms and category structure.**
   - Implement `makeResidualRunnerMap(f)` that verifies the commutative square `(id_{TX} × f); θ'^X_{Y'} = θ^X_Y; R(id_X × f)` for representative `X`, logging the `R`-application morphisms `R(id_X × f)` as part of the diagnostics.
   - Supply `identityResidualRunnerMap`, `composeResidualRunnerMaps`, and a `checkResidualRunnerCategory` oracle confirming `Run_R(T)`’s categorical laws (composition respects the residual condition, associativity/unitality hold, and counterexamples report the failing `X`).
3. **Equivalence with monad maps.**
   - Build translators `residualRunnerToMonadMap` and `monadMapToResidualRunner` that implement the bijection with monad maps into `S^{t,Y}_R`, explicitly reconstructing the triangles involving `η`, `η^R`, `μ`, and `μ^R` that certify `ϑ` is a monad morphism.
   - Add diagnostics mirroring the excerpt’s note about natural transformations `θ_{X,Y}`: log the component morphisms `θ^X_Y` and `ϑ_X`, verify naturality in `X`, and retain witnesses for the equality `ϑ_X = θ^X_Y ∘ ⟨id_{TX}, id_Y⟩`.
4. **Integration with residual interaction laws.**
   - Update the Phase V preparation hooks so a residual interaction law `(F, G, ρ)` can induce `R`-residual runners by specialising to a fixed machine object `Y`, with diagnostics that compare the induced `θ` against the `ρ` components via the evaluation map `GY → Y`.
   - Ensure Kleisli-pure annotations propagate: when a residual runner is obtained from a law that only satisfies the second diagram on pure arrows, store this metadata on the runner so subsequent checks can enforce the same restriction.
5. **Documentation and testing.**
   - Extend the planned `LAWS.md` update with an “`R`-residual runners” subsection quoting the precise formulas for `θ`, the morphism square, and the equivalence with monad maps `ϑ`.
   - Add regression tasks for a toy residual monad (e.g., `R X = X + E`) demonstrating an `R`-residual runner, its associated monad map, and a morphism that fails the `R(id_X × f)` condition, emitting the detailed diagnostics captured above.

## 5. Phase V — Residual Interaction Laws (Section 5)
### Goals
- Restate Section 5’s **residual interaction** setup verbatim: fix an endofunctor `R` on the base category and a family of natural maps `ρ_{X,Y} : FX × GY → R(X × Y)` that witnesses how much of the computation is handled by the machine versus deferred to `R`.
- Transcribe the two commutative diagrams that define an `R`-residual functor–functor interaction law exactly as shown in the excerpt—one comparing `ρ_{X,Y}` with the canonical map `FX × GY → F(X × Y) → R(X × Y)` (the “first condition” diagram with arrows labelled `φ_{X,Y}`, `Rm^F_{X,Y}`, `Rm^G_{X,Y}`, and the Day-tensor comparison) and the other comparing `ρ_{X,Y}` with the factorisation through `RX × GY`—so that they can be executed as oracle checks, complete with the composites `h_Y`, `k'_Y`, and `k_Y` that appear in the proof sketch.
- Note explicitly that the paper proves the first condition implies the second when the right-hand morphism factors through the Kleisli inclusion `J : 𝒞 → Kl(R)` (so `ℓ = Jg = η_Y ∘ g`); ensure the roadmap captures this “pure map” relaxation so diagnostics can surface when the second diagram is only demanded on Kleisli-pure arrows.
- Capture that such laws form a monoidal category `IL_R(𝒞)` whose monoid objects are precisely the `R`-residual monad–comonad interaction laws; record the isomorphism `MCIL_R(𝒞) ≅ Mon(IL_R(𝒞))` and Example 13’s “exceptions monad” witness (`RX = X + E`, `DY = Δ × Y`) as canonical regression material.
- Document the Kleisli-category perspective from Section 5.2: characterise when an ordinary interaction law on `Kl(R)` comes from an `R`-residual law on `𝒞`, including the requirement that the lifted functor `F̄` is **strongly monoidal** via natural transformations `m^R_{X,Y} : F X × F Y → R(F(X × Y))` that agree with both the product monoidality in `𝒞` and the monad structure of `R`.
- Extend the runner narrative so that stateful machines can leave behind residual behaviour governed by `R`, matching the discussion that “not all of the effect of a computation is serviced” and bridging to the residual runner subsections that follow in the paper.

### Tasks
1. **Residual law data structures.**
   - Define `ResidualInteractionLaw<R>` packaging the base functors `(F, G)`, the residual endofunctor `R`, the natural family `ρ_{X,Y}`, and cached witnesses for the two defining diagrams; ensure constructors accept both raw natural transformations and Day-derived evaluations.
   - Provide adapters that lift an ordinary interaction law `(F, G, φ)` into a residual one by choosing `R = Id` and converting `φ` into `ρ`, confirming the diagrams degenerate to identities.
   - Encode Example 13’s “exceptions monad” instance (`R X = X + E`, `D Y = Δ × Y`, `ψ(f, (a, y)) = case a of inl x ↦ f(x, y) | inr e ↦ inr e`) as a ready-to-run constructor plus oracle fixture.
2. **Diagram transcription and oracles.**
   - Reconstruct the two Section 5.1 diagrams in executable form: supply helpers `residualLawCompatibilityWithF` and `residualLawCompatibilityWithG` that reproduce the exact composite maps from the figure (include the canonical morphisms `FX × GY → F(X × Y)`, the comparison arrows `Rm^F_{X,Y}`, `Rm^G_{X,Y}`, and `FX × GY → RX × GY → R(X × Y)`), record every intermediate arrow—including the proof-stage morphisms `h_Y`, `k'_Y`, `k_Y`—and assert equality via structured diagnostics.
   - Implement `checkResidualInteractionLaw(law)` that runs both diagram checks, logs failures with the underlying morphism data, and replays the “first condition implies the second for pure maps” argument (`ℓ = Jg = η_Y ∘ g`) so diagnostics can flag whether the second diagram has only been verified on Kleisli-pure arrows. Tag whether the residual component collapses to zero (linking back to Phase Ib degeneracy metadata when `R` factors through the zero functor).
3. **Residual monad–comonad integration.**
   - Define `ResidualMonadComonadInteraction` objects featuring monad `T`, comonad `D`, residual `R`, and the natural transformations mirroring the paper’s diagram (to be transcribed once the subsequent material is processed). Ensure they reduce to ordinary interaction laws when `R = Id` and store the comparison squares relating `ψ` and `ρ`.
   - Formalise the monoidal lift: implement helpers that treat `ρ` as the multiplication of a monoid object in `IL_R(𝒞)` and verify—via structured diagnostics—that every residual monad–comonad interaction law corresponds to a monoid object (and conversely) in line with the stated isomorphism `MCIL_R(𝒞) ≅ Mon(IL_R(𝒞))`.
   - Extend the existing `checkMonadComonadInteractionLaw` oracle so it can call into the residual checker when `R` metadata is present, replaying both the original ψ-diagrams and the new residual ones while reporting the monoid-structure witnesses.
4. **Categorical structure and Day–Chu alignment.**
   - Plan quasi-inverse functors demonstrating `IL_R(𝒞)` embeds into the Day convolution/Chu machinery by treating `ρ` as a morphism into the Day tensor followed by `R`; detail how morphisms in `IL_R(𝒞)` should transport `ρ` while respecting the residual diagrams.
   - Record the Kleisli comparison: implement translators that lift a residual law `(F, G, ρ)` on `𝒞` to an ordinary interaction law `(F̄, Ḡ, φ)` on `Kl(R)` and back, while checking the necessary and sufficient monoidality condition on `F` (availability of `m^R_{X,Y}` compatible with both the Cartesian product in `𝒞` and the monad multiplication of `R`). Log explicit diagnostics for the two naturality squares shown in the excerpt—distinguishing the arrows forced by the strong-monoidal structure from those lying in the image of `J`—so discrepancies between the `φ` and `ρ` conditions are surfaced immediately and the weaker “pure map” requirement is visibly tracked.
   - Capture the morphisms of `MCIL_R(𝒞)` explicitly, including how runner maps must preserve residual structure (`(id × f)`/`(R(f) × id)` compatibilities), and prepare adapters so that residual runners can be obtained from residual interaction laws once Section 5.2’s text is incorporated.
5. **Runner alignment and residual hooks.**
   - Update the Phase IV runner tasks to reference the residual infrastructure: allow `StatefulRunner<T>` to optionally point at an `R` and record leftover behaviour, and ensure the planned `makeResidualInteractionLaw`/`attachRunner` helpers now cite the formal definition captured here.
   - Schedule documentation updates for `LAWS.md` and the roadmap narrative to include a “Residual Interaction Laws” entry summarising `ρ`, the two diagrams, the categories `IL_R(𝒞)`/`MCIL_R(𝒞)`, and how they specialise to the ordinary case when `R = Id`.

## 6. Phase VI — Monoid–Comonoid Interaction and Hasegawa’s Glueing (Section 6)
### Goals
- Promote the Day-convolution category of interaction laws into the **monoidal/duoidal setting** described in Section 6.1: explicitly model the duoidal data `(ℱ, ⊗, ⊙, I, J, ζ, δ, μ)` where `⊗` is composition, `⊙` is Day convolution, `I` is the identity functor, and `J` is the Day unit. Encode the interchange transformations `ζ`, `δ`, and `μ` exactly as displayed so later phases can reuse them when transporting witnesses between the two monoidal structures.
- Recover the ordinary functor–functor and monad–comonad interaction laws by specialising this duoidal structure: record that the paper chooses `(F, G, Jk, ηk)` and the Day pairing from Figure (6) to obtain the evaluation morphisms. The plan must therefore preserve the comparison maps from diagram (6)—the top composite `F^{op} ⊙ G → (F ∘ G)^{op}` and the bottom composite landing in `F ∘ G`—and log the conjugate symmetry `F^{op} ⊙ G ≅ G ⊙ F^{op}` coming from the symmetric Day tensor.
- Translate the paper’s assertion that **monoid objects in `IL(𝒞)` are monad–comonad interaction laws** into executable quasi-inverses: given a monoid `(F, G, φ, m, u)` in the interaction-law monoidal category, reconstruct the corresponding ψ-family and conversely encode ψ as monoid structure using the Day tensor and unit.
- Note explicitly that the functor `J` highlighted in Section 6.1 is **opmonoidal but not lax monoidal**. The roadmap must capture diagnostics that reconstruct the two triangles in diagram (7), showing where the attempt to obtain a natural isomorphism between `(Comon(ℱ))^{op}` and `Mon(ℱ)` breaks down and where the opmonoidal comparison maps remain invertible.
- Encode the Sweedler dual functor `(-)^° : (Mon(ℱ))^{op} → Comon(ℱ)` introduced beneath diagram (8), including the proof obligation that it is only lax monoidal. Plan to log the two composites from diagram (8)—one using the Day tensor comparison `m^{F,G}` and the other using the opmonoidal structure of `J`—so we can pinpoint precisely why the oplax structure fails while still obtaining the lax-monoidal Sweedler dual.
- Internalise Section 6.3’s **Sweedler dual computations for monoids built from free constructions**: restate that for any endofunctor `F` the Sweedler dual of the free monoid `F*` coincides with the free comonoid on the dual functor (`(F*)° ≅ (F°)*`), and that imposing equations via a coequaliser `E* ⇉ F* → T` yields a dual computed by the corresponding equaliser on Sweedler duals (diagram with `E°* ⇉ F°* → T°`). Record the comparison maps `ι_* : F° → (F*)°`, `e^F_{UD}` from the proof, and ensure the plan captures how they witness the universal property.
- Internalise **Hasegawa’s glueing construction** (Section 6.2) as a concrete workflow: starting from a monoidal category `𝒞` with finite products and pullbacks, build the interaction-law Chu space `I = (F^I, G^I, φ^I)` whose primal/dual components `(F^I_*, F^I^†)` and `(G^I_*, G^I^†)` are assembled from the glueing index objects `(I, I)` together with the canonical comparison maps `F^I_X` and `G^I_Y`. Ensure the roadmap captures the isomorphism between the glueing category `Gl(𝒞)` and the Hasegawa interaction laws via explicit diagnostics.
- Record the **closure properties** highlighted in the excerpt: if `F` and `G` are closed under pullbacks, then the induced glueing interaction law `(F ⊗ G, ψ^{F⊗G})` is again closed, and if the base category admits the Day tensor product of promonoidal functors, the resulting interaction law inherits associativity/unitality witnesses compatible with the previously planned monad–comonad constructions.
- Prepare executable examples that replay the paper’s constructions, including the glueing of the identity functor (yielding the R-residual runner recovered from Section 5) and at least one nontrivial monoidal functor pair where the glueing tensor exhibits the stated `m^{G, F}` evaluation formula.

### Tasks
1. **Monoidal/duoidal structure materialisation.**
   - Extend the Phase I interaction-law module with explicit representations of both monoidal structures: composition `⊗` with unit `I`, Day convolution `⊙` with unit `J`, and the interchange maps `ζ`, `δ`, `μ` as spelled out in Section 6.1. Store the coend witnesses, associators, and unitors for each structure, together with the symmetry `σ : F^{op} ⊙ G → G ⊙ F^{op}` extracted from diagram (6).
   - Implement diagnostics `checkInteractionLawMonoidal(law)` that verify the Day tensor respects the evaluation pairing (naturality squares, associativity pentagon, unital triangles) and emit detailed traces showing how the Chu-space evaluation agrees with the Day pairing. Add a complementary `checkInteractionLawComposition` diagnostic that logs how the composition monoidal structure interacts with the Day tensor through the interchange transformations.
2. **Monoid-object ↔ ψ equivalence.**
   - Provide translators `monoidObjectToInteractionLaw` and `interactionLawToMonoidObject` that realise the Section 6.1 equivalence. The forward direction must reconstruct ψ by currying the monoid multiplication through the Day tensor, while the backward direction must build multiplication/unit from ψ via the canonical `m^{F,G}` and `u` maps. Diagnostics should log the coend representatives and the comparison morphisms `F(X × Y)`, `G(X × Y)` used in the derivation.
   - Integrate these translators with the existing `MCIL(𝒞) ≅ Mon(IL(𝒞))` adapters from Phase III, confirming they agree on overlap and adding checks that the multiplication reconstructed from ψ matches the monoid multiplication supplied.
3. **Opmonoidal unit and Sweedler dual functor.**
   - Encode the opmonoidal structure of `J` exactly as in the excerpt (the natural transformations `JX ⊙ JY → J(X ⊗ Y)` and `I → J`), and provide diagnostics that replay the two triangles from diagram (7) to show where lax-monoidal structure fails. Capture counterexamples demonstrating that `J` does not supply a lax-monoidal unit by default.
   - Implement the Sweedler dual functor `(-)^° : (Mon(ℱ))^{op} → Comon(ℱ)` by composing the Day-dual construction with the opmonoidal structure of `J`. Ensure the builder stores the lax-monoidal comparison maps from diagram (8), records where oplaxity fails, and links back to the Phase III Sweedler dual constructors so both viewpoints share diagnostics and witnesses.
   - Add specialised calculators for Section 6.3: a helper `sweedlerDualOfFreeMonoid(F)` that materialises the isomorphism `(F*)° ≅ (F°)*` by composing the comparison `ι_* : F° → (F*)°` with the universal arrow from the free monoid, and an oracle that verifies both directions of the bijection `Comon(F°, UD) ≅ Mon(F, UD)` shown in the text. Extend the tooling with `sweedlerDualOfMonoidQuotient(equations)` that rebuilds the equaliser diagram from the paper (`E°* ⇉ F°* → T°`) and logs the induced maps `f_*°, g_*°`, `f'_*°, g'_*°`, together with the pullback along `e^F_{UD}` used to detect when a quotient monoid shares its Sweedler dual with the generating functor.
4. **Hasegawa glueing implementation.**
   - Create a `constructGlueingInteractionLaw(data)` helper that accepts the pullback-stable subcategories `F`, `G`, the Day convolution kernel, and the glueing span `I ← R → I` (mirroring the excerpt’s notation). The helper must build the Chu pairing `φ_{X,Y}` via the glueing evaluation map `F^e_{X,Y}`, attach the induced Day tensor/unitor witnesses, and record the universal property of the glueing category (`Gl(𝒞)` initial among objects equipped with spans into `F` and `G`).
   - Implement an oracle `checkGlueingInteractionLaw` that verifies the pullback conditions, naturality of the glueing evaluation, and the isomorphism with the `R`-residual construction when the glueing object factors through `R` (recovering the Section 5 setup). Include diagnostics that trace the comparison map `m^{G⊗F}` as described in the text (factoring through `g^F` and `m^{G⊗F}` via `R`).
5. **Example suite and documentation.**
   - Add regression plans for (a) the identity functor glueing (showing it agrees with the residual runner/unit interaction law), (b) a finite monoidal example where glueing produces a nontrivial tensor, and (c) a counterexample illustrating the need for pullback stability. Each example must capture the evaluation maps `φ`, the comparison morphisms `g^{F,G}`, and the Day tensor witnesses.
   - Schedule `LAWS.md` updates introducing a “Glueing Interaction Law” entry that references the Section 6 construction, the new oracle, and the relationship to monoid/comonoid interaction laws.
6. **Integration hooks.**
   - Ensure the new monoidal/glueing infrastructure feeds back into earlier phases: Phase III’s monoid/comonoid packaging should reuse the Section 6 tensor/unit data, and Phase IV’s runner conversions should note when glueing recovers the same ψ as a stateful runner. Update the plan to revisit these connections once Section 6.3–6.4 material is reviewed.
7. **User/kernel monad stack.**
   - Build kernel monad constructors (e.g., `makeKernelMonad(Σ, C)`) that adjoin the `getenv`/`setenv` state operations to an external-effect signature `Σ`, package the resulting algebraic theory, and expose runners that guarantee the three desiderata (resource finalisation hooks, delegated external calls, and failure signalling). Store diagnostics that confirm the induced runners close resources exactly once and propagate failure via the dedicated channel.
   - Define complementary user monads `User_Σ` that consume the supervised effects exposed by the kernel runners, together with adapters that translate a kernel runner into the user-side monad morphism described in the excerpt. Require regression plans that replay the motivating examples (user/kernel, browser/web page, OS/hardware) and log the mediated access patterns.
   - Extend the roadmap’s λ_{coop} examples so user programs run atop the constructed kernel monads, exercising the explicit co-operation maps for `Σ` as well as the state operations, and validate through diagnostics that composing runners along the kernel boundary preserves the promised resource discipline and failure semantics.
8. **Runner calculus primitives.**
   - Restate the programming rule `run V { return x ↦ M; (op z ↦ N_op)_op∈Σ }`, the handling clause for the kernel computation `(op z ↦ N_op)` (including the optional `run` continuation and the finalisation block), and require the λ_{coop} AST and interpreter tasks to materialise these constructs exactly as presented before Section 3.2.
   - Record the dual co-operation signature where each kernel operation returns both a value and a continuation `(A_op → T B_op)` as in equation (3): `{return x ↦ (return x, x); (op z ↦ K_op)} with K_op : A_op × S → B_op × E_op`. Plan diagnostics that validate the induced co-operation map respects the projected components (user-visible result, kernel state update, optional signal), and surface counterexamples when any branch omits finalisation.
   - Add Example 4 to the regression backlog: implement the file-handle scenario with `open`, `write`, and `close` operations, ensure the finalisation clause reclaims the handle even on signals, and log resource-usage traces that demonstrate the “close after each write unless signal” discipline highlighted in the text. Mark the cheat noted in the footnote (open must move outside `run`) and require the interpreter to reject such misplacements or automatically hoist them to value positions.
   - Implement **Section 4.4’s rewrite system**: encode the three equality judgements, add interpreter-level reductions that enforce the runner equations and their kernel counterparts, and build diagnostics that log which rule fires, how finalisation continuations are wrapped, and when signals or raises bypass the finaliser. Ensure the equality engine knows the β/η rules for handlers, exception blocks, and the `let_{X,E}` abbreviation so later proofs can cite these rewrites directly.

## 7. Phase VII — Session-Type Alignment and Future Directions
### Goals
- Record Section 8’s **session-type grammar** verbatim: types are generated from a distinguished base type `A`, a session channel variable `Y`, the constants `1` and `0`, binary product `A × B`, linear function space `A ⇒ B`, and the constructors arising from the functor/comonad actions (`G₀A`, `G₀^{∘}A`, etc.). Ensure the roadmap tracks every constructor mentioned in the text so later passes can supply precise categorical semantics.
- Capture the recursively defined **dual operator** `(-)°` on session types (swapping `1`/`0`, reversing products/functions, and threading through the `G₀`-generated connectives) and state explicitly that this syntactic dual aligns with the semantic dual obtained from interaction laws and Sweedler duals.
- Integrate session types with the interaction-law infrastructure by planning interpreters that map each constructor to the corresponding functor/comonad operations (`send`, `receive`, Day convolution fibres) and ensure the dual operator is realised by the previously planned `dualInteractionLaw` helpers.
- Reflect the paper’s observation that discrepancies arise between syntactic and semantic duals in linear settings, and prepare diagnostics that surface such mismatches when the base category is Cartesian closed versus intuitionistic linear.
- Document the **open problems** from Section 8’s conclusion: computing Sweedler duals in general, reconciling duality with cooperation coequations, determining whether the Sweedler dual persists in intuitionistic linear settings, and extending the interaction-law calculus to session typing.

### Tasks
1. **Session-type encoding.**
   - Design a `SessionType` algebraic data type mirroring the grammar above, including constructors for the `G₀`/`G₀^∘` actions; provide parsers/pretty-printers so examples from the paper can be instantiated exactly.
   - Specify semantic interpreters `interpretSessionTypePrimal`/`interpretSessionTypeDual` that send each constructor to the corresponding functor or comonad used in earlier phases (e.g., `send`/`receive` functors, Day tensor units), ensuring the dual interpreter composes the semantic duals computed in Phase II.
2. **Duality alignment diagnostics.**
   - Implement an oracle `checkSessionTypeDuality` that compares the syntactic dual `A°` with the semantic dual delivered by `dualInteractionLaw`, reporting counterexamples when linear contexts break the equivalence noted in the conclusion.
   - Add regression plans covering the base cases (`1`, `0`, `Y`), composite cases (`A × B`, `A ⇒ B`), and the `G₀`-derived constructors, ensuring all align with the evaluation-based runner semantics when interpreted.
3. **Session-type runners.**
   - Extend Phase IV’s runner infrastructure with helpers that generate runners from session-type specifications (e.g., interpreting `A ⇒ B` as a handler map `θ`), verifying that the resulting evaluation map still matches `ev_Y`.
   - Provide documentation tasks linking session-type runners back to Example 12’s update lenses and to the costate comonad translators.
4. **Future-work registry.**
   - Create a `docs/day-chu-future-work.md` tracker listing the unresolved questions from the conclusion (general Sweedler dual computation, cooperation semantics, linear-session duality, intuitionistic adaptations) together with proposed experiments or literature to consult.
   - Schedule revisit triggers after implementing Phases IV–VI to assess how close the current infrastructure is to answering each question.

## 8. Cross-cutting Concerns
- **Oracle-first mindset:** every phase should surface structured diagnostics, witnesses, and tie into the project’s oracle registries.
- **Integration readiness:** maintain compatibility with existing promonoidal kernels, Day tensor/unit helpers, and Chu space utilities; prefer composition over bespoke constructions.
- **Iterative refinement:** this plan is meant to evolve with further low-level reading—each revisit should update sections rather than appending ad hoc notes.
- **Testing discipline:** expand the automated suite alongside each capability, ensuring deterministic coverage aligned with `AI_MATHEMATICAL_IMPL_GUIDELINES.md`.

## 9. Next Review Triggers
- Revisit the plan after implementing Phase I to incorporate insights from working with explicit interaction-law objects.
- Re-read the remaining subsections of Section 5 (residual running, residual runners) and Section 6 (duoidal structure) before executing Phase V and beyond so any additional operational hooks are folded into the roadmap rather than appended later.

## References
- Shin-ya Katsumata, Eduardo Rivas, and Tarmo Uustalu. *Interaction Laws of Monads and Comonads*. arXiv:1912.13477, 2019.
- Andrej Bauer and Matija Pretnar. *Runners in Action*. In *European Symposium on Programming*, 2019.
