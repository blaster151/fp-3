#!/usr/bin/env node
/**
 * Aggregated Street Roll-up Adapter Generator
 * ===========================================
 *
 * This generator consumes the JSON export emitted by
 * `npm run validate-relative-monads -- --aggregated-json <file>` and produces a
 * TypeScript module that captures the aggregated Street roll-up verdict. The
 * emitted module surfaces pending-aware guards so enriched adapters can gate
 * emission on the recorded analyzer status without rerunning the Street
 * harness.
 */

import fs from 'node:fs/promises'
import path from 'node:path'
import process from 'node:process'

const ANALYZER_LABELS = [
  ['Yoneda', 'yoneda'],
  ['Yoneda distributor', 'yonedaDistributor'],
  ['Eilenberg–Moore', 'eilenbergMoore'],
  ['Kleisli inclusion', 'kleisli'],
  ['V-Cat', 'vcat'],
]

const DEFAULT_OUTPUT_FILENAME = 'relative-aggregated-street-adapters.generated.ts'

const isObject = (value) => typeof value === 'object' && value !== null

const formatAnalyzerReport = (label, report) => {
  if (!isObject(report)) {
    return `✘ ${label} (missing report metadata)`
  }
  const pending = report.pending ? 'yes' : 'no'
  const status = report.holds ? '✔' : report.pending ? '⧗' : '✘'
  return `${status} ${label} (pending: ${pending})`
}

export const buildAggregatedStreetRollupPlan = (aggregated) => {
  const pending = Boolean(aggregated?.pending)
  const holds = Boolean(aggregated?.holds)
  const status = pending ? 'pending' : holds ? 'ready' : 'blocked'
  const details = typeof aggregated?.details === 'string' ? aggregated.details : 'No details provided.'
  const issues = Array.isArray(aggregated?.issues) ? aggregated.issues : []

  let analyzerSummaries = []
  const reports = aggregated?.artifacts?.reports
  if (isObject(reports)) {
    analyzerSummaries = ANALYZER_LABELS.map(([label, key]) =>
      formatAnalyzerReport(label, reports[key]),
    )
  }

  const streetRollups = aggregated?.artifacts?.streetRollups
  const guardSuggestion = pending
    ? 'Emit enriched adapters behind a pending Street roll-up guard.'
    : holds
      ? 'Adapters can be emitted without additional Street roll-up guards.'
      : 'Block adapter emission until Street roll-ups hold.'

  const steps = [
    'Load aggregated Street roll-up JSON from the oracle enumeration output.',
    'Derive guard conditions from { holds, pending }.',
    'Thread analyzer verdicts into generator templates for enriched adapters.',
    'Persist streetRollups artifacts alongside emitted modules to avoid recomputation.',
  ]

  return {
    status,
    details,
    pending,
    holds,
    issues,
    guardSuggestion,
    analyzerSummaries,
    streetRollups: isObject(streetRollups)
      ? {
          pending: Boolean(streetRollups.pending),
          holds: Boolean(streetRollups.holds),
          extensions: Array.isArray(streetRollups.extensions)
            ? streetRollups.extensions.length
            : 0,
          kleisli: Array.isArray(streetRollups.kleisli) ? streetRollups.kleisli.length : 0,
        }
      : undefined,
    steps,
  }
}

const usage = () => {
  console.log(
    'Usage: node scripts/generate-aggregated-street-rollup-scaffold.mjs <aggregated-json> [--out <ts-file>]'
  )
  console.log('The JSON file should contain the result of RelativeMonadOracles.polynomialStreetRollupAggregation.')
  console.log(`If --out is omitted the module is written to ./${DEFAULT_OUTPUT_FILENAME}.`)
}

const resolveInputPath = (relativePath) =>
  path.isAbsolute(relativePath) ? relativePath : path.join(process.cwd(), relativePath)

const resolveOutputPath = (filePath) =>
  path.isAbsolute(filePath) ? filePath : path.join(process.cwd(), filePath)

const ensureParentDirectory = async (filePath) => {
  const directory = path.dirname(filePath)
  await fs.mkdir(directory, { recursive: true })
}

const buildAdapterModuleSource = (aggregated) => {
  const serialized = JSON.stringify(aggregated, null, 2)
  const analyzerKeysLiteral = ANALYZER_LABELS.map(([label, key]) =>
    `  [${JSON.stringify(label)}, ${JSON.stringify(key)}] as const`,
  ).join(',\n')

  return `// This file was generated by scripts/generate-aggregated-street-rollup-scaffold.mjs.
// Do not edit manually.

export const aggregatedStreetRollup = ${serialized} as const;

export type AggregatedStreetRollup = typeof aggregatedStreetRollup;

export type AggregatedStreetRollupVerdict =
  | 'ready'
  | 'pending'
  | 'blocked';

export const aggregatedStreetRollupVerdict: AggregatedStreetRollupVerdict =
  aggregatedStreetRollup.pending
    ? 'pending'
    : aggregatedStreetRollup.holds
      ? 'ready'
      : 'blocked';

export function describeAggregatedStreetRollupSummary(): string {
  return aggregatedStreetRollup.details ?? 'Aggregated Street roll-up summary unavailable.';
}

export function listAggregatedStreetRollupIssues(): ReadonlyArray<string> {
  return aggregatedStreetRollup.issues ?? [];
}

type AnalyzerKey =
  | 'yoneda'
  | 'yonedaDistributor'
  | 'eilenbergMoore'
  | 'kleisli'
  | 'vcat';

const ANALYZER_ORDER: ReadonlyArray<readonly [string, AnalyzerKey]> = [
${analyzerKeysLiteral}
];
const formatAnalyzerStatus = (label: string, report: unknown): string => {
  if (!report || typeof report !== 'object') {
    return `✘ ${label} (missing report metadata)`
  }
  const typed = report as { readonly holds?: boolean; readonly pending?: boolean }
  const pending = typed.pending ? 'yes' : 'no'
  const status = typed.holds ? '✔' : typed.pending ? '⧗' : '✘'
  return `${status} ${label} (pending: ${pending})`
}

export function summarizeAggregatedStreetRollupAnalyzers(): ReadonlyArray<string> {
  const reports = aggregatedStreetRollup.artifacts?.reports as
    | Readonly<Record<AnalyzerKey, unknown>>
    | undefined
  if (!reports) {
    return []
  }
  return ANALYZER_ORDER.map(([label, key]) => formatAnalyzerStatus(label, reports[key]))
}

export function describeAggregatedStreetRollupPayload(): {
  readonly pending: boolean
  readonly holds: boolean
  readonly extensions: number
  readonly kleisli: number
} | undefined {
  const payload = aggregatedStreetRollup.artifacts?.streetRollups as
    | {
        readonly pending?: boolean
        readonly holds?: boolean
        readonly extensions?: ReadonlyArray<unknown>
        readonly kleisli?: ReadonlyArray<unknown>
      }
    | undefined
  if (!payload) {
    return undefined
  }
  return {
    pending: Boolean(payload.pending),
    holds: Boolean(payload.holds),
    extensions: Array.isArray(payload.extensions) ? payload.extensions.length : 0,
    kleisli: Array.isArray(payload.kleisli) ? payload.kleisli.length : 0,
  }
}

export function assertAggregatedStreetRollupReady(): void {
  const summary = describeAggregatedStreetRollupSummary()
  if (!aggregatedStreetRollup.holds) {
    throw new Error(`Aggregated Street roll-up blocked: ${summary}`)
  }
  if (aggregatedStreetRollup.pending) {
    throw new Error(`Aggregated Street roll-up pending: ${summary}`)
  }
}

export function selectAggregatedStreetAdapters<T>(options: {
  readonly onReady: (aggregated: AggregatedStreetRollup) => T
  readonly onPending?: (aggregated: AggregatedStreetRollup) => T
  readonly onBlocked?: (aggregated: AggregatedStreetRollup) => T
}): T {
  const verdict = aggregatedStreetRollupVerdict
  if (verdict === 'ready') {
    return options.onReady(aggregatedStreetRollup)
  }
  if (verdict === 'pending' && options.onPending) {
    return options.onPending(aggregatedStreetRollup)
  }
  if (verdict === 'blocked' && options.onBlocked) {
    return options.onBlocked(aggregatedStreetRollup)
  }
  const summary = describeAggregatedStreetRollupSummary()
  throw new Error(`Aggregated Street roll-up ${verdict} without handler: ${summary}`)
}
`
}
const parseArgs = (argv) => {
  let inputPath
  let outputPath
  for (let index = 0; index < argv.length; index += 1) {
    const arg = argv[index]
    if (!arg) {
      continue
    }
    if (arg === '--help' || arg === '-h') {
      return { ok: false, exitCode: 0, message: undefined }
    }
    if (arg === '--out') {
      const next = argv[index + 1]
      if (!next) {
        return {
          ok: false,
          exitCode: 1,
          message: '--out flag requires a file path argument.',
        }
      }
      outputPath = next
      index += 1
      continue
    }
    if (!inputPath) {
      inputPath = arg
      continue
    }
    return {
      ok: false,
      exitCode: 1,
      message: `Unknown argument: ${arg}`,
    }
  }

  if (!inputPath) {
    return {
      ok: false,
      exitCode: 1,
      message: 'Missing aggregated Street roll-up JSON path.',
    }
  }

  return { ok: true, inputPath, outputPath }
}

async function main() {
  const parsed = parseArgs(process.argv.slice(2))
  if (!parsed.ok) {
    if (parsed.message) {
      console.log(parsed.message)
      if (parsed.exitCode !== 0) {
        console.log('')
        usage()
      }
    } else {
      usage()
    }
    process.exitCode = parsed.exitCode
    return
  }

  const inputPath = resolveInputPath(parsed.inputPath)
  const outputPath = resolveOutputPath(parsed.outputPath ?? DEFAULT_OUTPUT_FILENAME)

  const raw = await fs.readFile(inputPath, 'utf8')
  const aggregated = JSON.parse(raw)
  const plan = buildAggregatedStreetRollupPlan(aggregated)

  console.log('🛠️ Aggregated Street roll-up adapter generation')
  console.log(`Status: ${plan.status}`)
  console.log(`Summary: ${plan.details}`)
  console.log(`Guard: ${plan.guardSuggestion}`)
  if (plan.issues.length > 0) {
    console.log('Reported issues:')
    for (const issue of plan.issues) {
      console.log(`  - ${issue}`)
    }
  }
  if (plan.analyzerSummaries.length > 0) {
    console.log('\nAnalyzer verdicts:')
    for (const summary of plan.analyzerSummaries) {
      console.log(`  ${summary}`)
    }
  }
  if (plan.streetRollups) {
    console.log('\nStreet roll-up payload:')
    console.log(`  pending: ${plan.streetRollups.pending ? 'yes' : 'no'}`)
    console.log(`  holds: ${plan.streetRollups.holds ? 'yes' : 'no'}`)
    console.log(`  extensions captured: ${plan.streetRollups.extensions}`)
    console.log(`  kleisli captured: ${plan.streetRollups.kleisli}`)
  }
  console.log('\nDocumented steps:')
  for (const [index, step] of plan.steps.entries()) {
    console.log(`  ${index + 1}. ${step}`)
  }

  const moduleSource = buildAdapterModuleSource(aggregated)
  await ensureParentDirectory(outputPath)
  await fs.writeFile(outputPath, `${moduleSource}\n`, 'utf8')
  console.log(`\n✅ Wrote aggregated Street adapter module to ${outputPath}`)
}

main().catch((error) => {
  console.error('Aggregated Street roll-up scaffold failed:', error)
  process.exitCode = 1
})
