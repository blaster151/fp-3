# Runnable Example Concepts Outline

A ranked catalogue of the runnable examples currently described in `run-examples-simple.ts` and `examples.ts`. Each entry names the logical goal of the example suite so the code can be rebuilt later in a principled order. The rebuild effort begins in `examples/runnable/`, where numerically prefixed modules (e.g. `001-…`, `002-…`) mirror this outline and can be executed via `run-runnable-examples.ts`.

1. **Option, Result, and Validation primitives** – Parsing numbers, guarded division, and basic validation accumulation illustrate the fundamental success/failure container semantics. (examples.ts)
2. **Do-notation for synchronous and asynchronous Results** – Sequencing Result and TaskResult computations with builder combinators to emphasize structured monadic control flow. (examples.ts)
3. **State, Reader, and Task composition patterns** – Pure state ticks, dependency-injected Readers, Task-based concurrency, and combined StateReaderTask programs demonstrate effect combination. (examples.ts)
4. **ReaderTaskOption and Reader-Writer-State-Task generators** – Generator-based composition for optional, logging, and stateful async workflows over shared environments. (examples.ts)
5. **Partitioning and sequencing containers** – Partitioning sets by predicate or Result, and sequencing Validation/Result collections into accumulated success or error summaries. (examples.ts)
6. **Partial functions with filterMap/collect across data structures** – Using predicates as partial functions to filter or transform arrays, maps, and sets consistently. (run-examples-simple.ts)
7. **JSON streaming folds and fused hylo pipelines** – Event-driven JSON folds and deforested range/tree pipelines compute aggregates, pretty prints, and combined statistics without intermediate structures. (examples.ts)
8. **Reader applicative evaluators for expression ASTs** – Evaluating arithmetic expressions under environments, Reader<Result> error handling, and comparing Reader semantics. (run-examples-simple.ts)
9. **Stack machine compilation of expressions** – Compiling high-level expressions to a stack-based program and running them through a Result-producing virtual machine. (run-examples-simple.ts)
10. **Expression algebras for size, depth, and products** – Catamorphisms compute structural metrics and product algebras gather multiple invariants in a single traversal. (run-examples-simple.ts)
11. **Safe AST evolution with negation and N-ary operators** – Demonstrates how recursion schemes enforce handling of new constructors, normalize binary chains, and support variable binding and typed division. (examples.ts & run-examples-simple.ts)
12. **Symbolic algebra, substitution, and differentiation** – Expression simplifiers, capture-avoiding substitution, and symbolic derivatives verify rewrite correctness. (run-examples-simple.ts)
13. **Canonicalization and extended EJSON policies** – Canonical form generation with configurable policies, canonical EJSON encoding/decoding, and product algebras for combined JSON analytics. (run-examples-simple.ts)
14. **Canonical equality, hashing, and structural utilities** – Hash-consing, canonical key construction, equality checks, and consistency validations for JSON-like structures. (run-examples-simple.ts)
15. **Canonical containers, multimaps, and grouping analytics** – Canonical map/set/multimap operations, top-k extraction, distinctness tracking, and canonical sorting pipelines. (run-examples-simple.ts)
16. **Streaming analytics over canonical groups** – Online reducers compute canonical minima/maxima, counts, sums, and filtered streams without full materialization. (run-examples-simple.ts)
17. **JSON zipper navigation and path editing** – Bidirectional traversals, focus replacement, and path-based modification over JSON trees. (run-examples-simple.ts)
18. **Kleisli arrow pipelines for Reader, Task, and ReaderTaskResult** – Building, composing, and testing Kleisli arrows with error handling and asynchronous effects. (run-examples-simple.ts)
19. **Arrow IR core and ArrowApply extensions** – Function-arrow IR with composition, products, fanout, ArrowApply operations, and derived helpers across Reader, Task, ReaderTask, and ReaderTaskResult contexts. (run-examples-simple.ts)
20. **Arrow IR normalization and semantics preservation** – Normalizing arrow plans while proving denotational equivalence and functorial preservation. (run-examples-simple.ts)
21. **HKT-based expression builders and refactoring safety** – Higher-kinded typed expression constructors, pretty printers, evaluators, and automated refactor demonstrations that ensure exhaustive handling. (run-examples-simple.ts)
22. **JSONF enhancements and extended variants** – Additional JSON constructors (dates, decimals, binaries, regexes, sets) plus combined size/depth/string aggregations. (run-examples-simple.ts)
23. **Policy threading with improved product algebras** – Comparing canonicalization policies, threading configuration through transformations, and pairing custom algebras in a single fold. (run-examples-simple.ts)
24. **Sum/Product endofunctor drills** – Mapping, case analysis, and strength calculations for Option ⊕ Result and Option ⊗ Result endofunctors to solidify binary constructor intuition before natural transformations. (examples-sum-product.ts)
25. **Natural transformations and Kleisli/Writer/Array structures** – Option↔Result natural transformations, Task→ReaderTask lifting, Kleisli composition, Writer/WriterT logging, and Array monad traversals. (run-examples-simple.ts)
26. **Advanced functor, traversable, and free-algebra suites** – Execute Sum/Product natural transformations (identity, branch-specific), distribute Promise/Task traversals, evaluate composite free endofunctor terms, hoist Option→Result transformations, and assemble Promise post-composition lax 2-functors with explicit η witnesses. (examples-advanced-functors.ts)
27. **Monoidal functors and applicative-inspired zipping** – Monoidal functor instances for Option, Result, Reader, ReaderTask, ReaderTaskEither, and Validation enabling zipped combination of effects. (run-examples-simple.ts)
28. **Monoidal functor law harness** – Property-based verification of functor identity/composition and lax monoidal unit, associativity, and naturality across Option, Result<string>, Reader<number>, ReaderTask<number>, and ReaderTaskEither<number, string>. (laws.monoidal.ts)
29. **Comonads, cofree constructions, and Store lenses** – Store, Env, Traced, Cofree, and StoreLens demonstrations including zipper navigation and DoCoBind programs. (run-examples-simple.ts)
30. **Store–lens time-series smoothing walkthrough** – Build Stores over nested telemetry records, focus them with lenses to apply moving averages, compare lens-powered smoothing against manual reconstruction, and preserve metadata structure. (examples-store-lens.ts)
31. **Mixed distributive laws for monad×comonad pairs** – Result×Store validation, Task×Store async contexts, and lifting monads to coalgebras or comonads to algebras through mixed distributive scaffolds. (examples-mixed-distributive.ts)
32. **2-functor and oplax strength demonstrations** – Composition of endofunctors, post-composition lax 2-functors, and environment-strengthened oplax 2-functors with explicit η and μ checks. (run-examples-simple.ts)
33. **Relative monad diagnostics** – Registry reporting for relative monads, algebras, and opalgebras to ensure coverage of oracle registrations. (run-examples-simple.ts)
34. **Record gluing and descent workflows** – Basic gluing, configuration reconciliation, microservice aggregation, and parallel computation consistency checks illustrating sheaf-like descent intuition. (examples-gluing.ts)
35. **Semicartesian initial-unit oracles** – Derive global-element structure from initial tensor units, validate canonical arrows, and report counterexamples for semicartesian compatibility checks. (semicartesian-structure.ts)
36. **CRing⊕ semicartesian witnesses** – Instantiate additive/unit-preserving morphisms between commutative rings, construct canonical ℤ→A maps, and certify semicartesian structure within the CRing⊕ category. (cring-plus.ts)
37. **Semicartesian infinite tensor products** – Package projection compatibility and universal property oracles for infinite semicartesian tensor products indexed by finite subsets. (semicartesian-infinite-product.ts)
38. **C*-algebra witness and spectral diagnostics** – Provide complex-number C*-algebra operations with tolerance-aware equality and execute axiom, *-homomorphism, and spectral checks. (cstar-algebra.ts)
39. **Algebra oracle registry and relative monad reporting** – Aggregate semicartesian, causality, C*-algebra, and relative monad law oracles into a unified diagnostics surface. (algebra-oracles.ts)
40. **Comodule, entwining, and entwined module machinery** – Constructing corings, comodules, balanced tensors, entwinings, entwined modules, morphisms, and verifying compatibility laws. (examples.ts)
41. **Category of entwined modules and algebraic utilities** – Building categories of modules, checking morphism composition, and exercising weighted automata, HMMs, regex compilation, and graph algorithms. (examples.ts)
42. **Triangulated categories and homological algebra** – Constructing cones, verifying distinguished triangles, Smith normal form computations, and exactness checks in chain complexes. (examples.ts)
43. **Rational arithmetic and linear algebra over ℚ** – Field operations, solving linear systems, nullspaces, and random complex generation with exact rational arithmetic. (examples.ts)
44. **Vector space and diagrammatic category utilities** – Finite posets, diagram reindexing, Kan extensions, universal properties, indexed families, category limits, arrow categories, and morphism families. (examples.ts)
45. **Diagram commutativity verification drills** – Triangle associativity, identity neutrality, pasted commuting rectangles, and tweaked commutativity helpers that permit parallel forks while detecting mismatches. (examples/diagram-demo.ts)
46. **Contravariant functor witnesses over Thin₂ and Poset₃** – Realize Set-valued contravariant functors from thin and poset categories, inspect reversed arrow action, and confirm composition reversal and evaluation behaviour. (examples/contra-real.ts)
47. **Virtual equipment companions, conjoints, and adjunctions** – Companion/conjoint availability, oracle summaries, complete adjunction chains (Σ ⊣ u* ⊣ Π), and Kan extensions in Vect. (examples.ts)
48. **Semiring rig registry and entire-check harness** – Centralize probability, boolean, tropical, ghost, and direct-sum rigs with equality, enumeration, and zero-divisor diagnostics for semiring-aware algorithms. (semiring-utils.ts)
49. **Semiring distribution monad constructors** – Build generalized distribution monads over arbitrary numeric semirings with map/bind/product operations and normalization helpers. (semiring-dist.ts)
50. **Log-space Markov kernel composition chains** – Compose kernels via log-sum-exp, normalize n-step transitions, and maintain numeric stability in log-probability form. (logprob-chains.ts)
51. **Boolean-semirring NFA reachability** – Model ε-free NFAs as boolean-valued kernels, compute reachable states, and decide acceptance over words. (nfa-reachability.ts)
52. **Hidden Markov model inference algorithms** – Run Viterbi decoding in tropical max-plus form and forward inference in log/probability space with normalization safeguards. (hmm-viterbi.ts)
53. **Probability monads and Kleisli scaffolding** – Dist/SubProb/Weighted monad specs, Kleisli composition/tensor helpers, deterministic embeddings, and matrix views over finite categories. (probability-monads.ts)
54. **Semiring distributive-law diagnostics** – Compare Fubini coherence via monoidal product versus bind/map routes and verify pullback squares across Prob, LogProb, MaxPlus, and Bool distribution monads to ensure semiring-specific compatibility. (semiring-law-tests.ts)
55. **Textbook categorical toolkit** – Building textbook-style categories, computing pullbacks, slice constructions, and dual categories for pedagogical tooling. (run-examples-simple.ts)
56. **Slice and coslice project walkthrough** – Model a project-focused category with tasks, users, and workflow arrows, then build (\(\mathcal{C}/\mathrm{Project}\)) and (\(\mathrm{Project}\\\mathcal{C}\)) to inspect how objects and mediating morphisms reorganize around the anchor. (examples/slice-coslice-demo.ts)
57. **Concrete category backends and dynamic systems** – Examples over Set, Rel, Mat, and Dyn categories with concrete morphism checks and compositions. (run-examples-simple.ts)
58. **Category operations rewriter suggestions** – Execute the iso-cancellation, monic/right-inverse upgrades, balanced promotions, mutual mono merges, and epi–mono factorisation rules to surface structured `Rewrite` suggestions for finite categories. (operations/rewriter.ts)
59. **Markov foundational law harness** – Evaluate entirety, faithfulness, pullback-square uniqueness, and registry metadata via the consolidated Markov oracle surface to certify baseline categorical structure. (markov-oracles.ts, entirety-check.ts, pullback-check.ts)
60. **Markov determinism and thunkability diagnostics** – Extract Dirac bases, certify thunkability across generated probes, and exercise the determinism lemma witnesses that reconcile sampling with deterministic pushforwards. (markov-laws.ts, markov-thunkable.ts, markov-determinism-lemma.ts)
61. **Markov comonoid and SetMult deterministic bridge** – Build comonoid witnesses, verify copy/discard homomorphisms, and translate deterministic Markov kernels into SetMult witnesses with detailed counterexamples when laws fail. (markov-comonoid-structure.ts, markov-deterministic-structure.ts, setmult-oracles.ts)
62. **Markov conditional independence and permutation invariants** – Package conditional kernels with projection data, reconstruct factorisations, and probe permutation-invariant decompositions for independence diagnostics. (markov-conditional-independence.ts, markov-permutation.ts)
63. **Markov monoidal strength and tensor coherence** – Confirm Dirac monoidality, strength naturality, and sampling compatibility for independent products across numeric or boolean semirings. (markov-monoidal.ts)
64. **Graded Markov kernels and cost accounting** – Track monoidal grades alongside stochastic kernels to accumulate costs or evidence during composition, with nat-add and tropical grade monoids. (markov-graded.ts)
65. **Almost-sure equality and sampling cancellation** – Construct witnesses for p-almost-sure equality, compare sample-based equality, and bridge cancellation oracles across deterministic and stochastic morphisms. (markov-almost-sure.ts, as-equality.ts)
66. **Dominance, garbling, and BSS equivalence checks** – Verify single-output sufficiency via dilation witnesses, compare informativeness between experiments, and align Blackwell–Sherman–Stein diagnostics across decision problems. (sosd.ts, garbling.ts, bss.ts, standard-experiment.ts)
67. **Infinite product and tail-law scaffolding** – Assemble Kolmogorov-consistent cylinders, tail-invariance reports, and extension universal properties for infinite tensor products in finite Markov categories. (markov-infinite-oracles.ts)
68. **Borel–Stochastic zero-one adapters** – Convert measure-theoretic samplers and indicator predicates into Kolmogorov and Hewitt–Savage witnesses by canonicalizing product supports and finite symmetry actions over explicit \(\mathrm{Fin}\) carriers. (borelstoch-examples.ts)
69. **Markov category zero-one theorems** – Determinism lemma witnesses, Kolmogorov/Hewitt–Savage zero-one oracles, and symmetry-aware oracle synthesis over finite Markov categories. (run-examples-simple.ts)
70. **Synthesized zero-one oracle factory** – Automated assembly of zero-one law oracles from reusable components, verifying the synthesized report. (run-examples-simple.ts)
71. **Top/Vietoris zero-one scaffolding** – Kolmogorov witness adapters for the Vietoris Kleisli category, explicit Hewitt–Savage failure markers, and TODO factories for product priors and statistics in non-causal settings. (top-vietoris-examples.ts)
72. **Pushout calculators and universal mediators** – Compare the finite pushout search with the toy calculator on the canonical pushout fixture and replay the universal mediating arrow. (pushout.ts, pushout-toy.ts, test/pushout-fixture.ts)
73. **Monoid categories and homomorphisms** – Explore MonCat homomorphisms between Z₄, parity, and Boolean-and monoids and inspect the induced one-object category from Z₄. (mon-cat.ts, monoid-cat.ts)
74. **Free category on a directed graph** – Build the free category on a depot→hub→campus transit graph, enumerate bounded paths, and compare composed and direct routes. (freecat.ts, graph.ts)

This outline preserves the intent of each runnable example so the implementations can be reconstructed methodically from foundational effects up to advanced categorical oracles.
