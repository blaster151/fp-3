# Runnable Example Concepts Outline

A ranked catalogue of the runnable examples implemented in the numerically prefixed modules under `examples/runnable/`. Each entry names the logical goal of the example suite so the code can be rebuilt later in a principled order. The suites can be executed via `run-runnable-examples.ts`.

1. **Option, Result, and Validation primitives** – Parsing numbers, guarded division, and basic validation accumulation illustrate the fundamental success/failure container semantics. (examples/runnable/001-option-result-basics.ts)
2. **Do-notation for synchronous and asynchronous Results** – Sequencing Result and TaskResult computations with builder combinators to emphasize structured monadic control flow. (examples/runnable/002-result-do-notation.ts)
3. **State, Reader, and Task composition patterns** – Pure state ticks, dependency-injected Readers, Task-based concurrency, and combined StateReaderTask programs demonstrate effect combination. (examples/runnable/003-effect-composition.ts)
4. **ReaderTaskOption and Reader-Writer-State-Task generators** – Generator-based composition for optional, logging, and stateful async workflows over shared environments. (examples/runnable/004-reader-task-option.ts)
5. **Partitioning and sequencing containers** – Partitioning sets by predicate or Result, and sequencing Validation/Result collections into accumulated success or error summaries. (examples/runnable/005-partition-and-sequence.ts)
6. **Partial functions with filterMap/collect across data structures** – Using predicates as partial functions to filter or transform arrays, maps, and sets consistently. (examples/runnable/006-partial-functions-with-filtermap-collect-across-data-structures.ts)
7. **JSON streaming folds and fused hylo pipelines** – Event-driven JSON folds and deforested range/tree pipelines compute aggregates, pretty prints, and combined statistics without intermediate structures. (examples/runnable/007-json-streaming-folds-and-fused-hylo-pipelines.ts)
8. **Reader applicative evaluators for expression ASTs** – Evaluating arithmetic expressions under environments, Reader<Result> error handling, and comparing Reader semantics. (examples/runnable/008-reader-applicative-evaluators-for-expression-asts.ts)
9. **Stack machine compilation of expressions** – Compiling high-level expressions to a stack-based program and running them through a Result-producing virtual machine. (examples/runnable/009-stack-machine-compilation-of-expressions.ts)
10. **Expression algebras for size, depth, and products** – Catamorphisms compute structural metrics and product algebras gather multiple invariants in a single traversal. (examples/runnable/010-expression-algebras-for-size-depth-and-products.ts)
11. **Safe AST evolution with negation and N-ary operators** – Demonstrates how recursion schemes enforce handling of new constructors, normalize binary chains, and support variable binding and typed division. (examples/runnable/011-safe-ast-evolution-with-negation-and-n-ary-operators.ts)
12. **Symbolic algebra, substitution, and differentiation** – Expression simplifiers, capture-avoiding substitution, and symbolic derivatives verify rewrite correctness. (examples/runnable/012-symbolic-algebra-substitution-and-differentiation.ts)
13. **Canonicalization and extended EJSON policies** – Canonical form generation with configurable policies, canonical EJSON encoding/decoding, and product algebras for combined JSON analytics. (examples/runnable/013-canonicalization-and-extended-ejson-policies.ts)
14. **Canonical equality, hashing, and structural utilities** – Hash-consing, canonical key construction, equality checks, and consistency validations for JSON-like structures. (examples/runnable/014-canonical-equality-hashing-and-structural-utilities.ts)
15. **Canonical containers, multimaps, and grouping analytics** – Canonical map/set/multimap operations, top-k extraction, distinctness tracking, and canonical sorting pipelines. (examples/runnable/015-canonical-containers-multimaps-and-grouping-analytics.ts)
16. **Streaming analytics over canonical groups** – Online reducers compute canonical minima/maxima, counts, sums, and filtered streams without full materialization. (examples/runnable/016-streaming-analytics-over-canonical-groups.ts)
17. **JSON zipper navigation and path editing** – Bidirectional traversals, focus replacement, and path-based modification over JSON trees. (examples/runnable/017-json-zipper-navigation-and-path-editing.ts)
18. **Kleisli arrow pipelines for Reader, Task, and ReaderTaskResult** – Building, composing, and testing Kleisli arrows with error handling and asynchronous effects. (examples/runnable/018-kleisli-arrow-pipelines-for-reader-task-and-readertaskresult.ts)
19. **Arrow IR core and ArrowApply extensions** – Function-arrow IR with composition, products, fanout, ArrowApply operations, and derived helpers across Reader, Task, ReaderTask, and ReaderTaskResult contexts. (examples/runnable/019-arrow-ir-core-and-arrowapply-extensions.ts)
20. **Arrow IR normalization and semantics preservation** – Normalizing arrow plans while proving denotational equivalence and functorial preservation. (examples/runnable/020-arrow-ir-normalization-and-semantics-preservation.ts)
21. **HKT-based expression builders and refactoring safety** – Higher-kinded typed expression constructors, pretty printers, evaluators, and automated refactor demonstrations that ensure exhaustive handling. (examples/runnable/021-hkt-based-expression-builders-and-refactoring-safety.ts)
22. **JSONF enhancements and extended variants** – Additional JSON constructors (dates, decimals, binaries, regexes, sets) plus combined size/depth/string aggregations. (examples/runnable/022-jsonf-enhancements-and-extended-variants.ts)
23. **Policy threading with improved product algebras** – Comparing canonicalization policies, threading configuration through transformations, and pairing custom algebras in a single fold. (examples/runnable/023-policy-threading-with-improved-product-algebras.ts)
24. **Sum/Product endofunctor drills** – Mapping, case analysis, and strength calculations for Option ⊕ Result and Option ⊗ Result endofunctors to solidify binary constructor intuition before natural transformations. (examples/runnable/024-sum-product-endofunctor-drills.ts)
25. **Natural transformations and Kleisli/Writer/Array structures** – Option↔Result natural transformations, Task→ReaderTask lifting, Kleisli composition, Writer/WriterT logging, and Array monad traversals. (examples/runnable/025-natural-transformations-and-kleisli-writer-array-structures.ts)
26. **Advanced functor, traversable, and free-algebra suites** – Execute Sum/Product natural transformations (identity, branch-specific), distribute Promise/Task traversals, evaluate composite free endofunctor terms, hoist Option→Result transformations, and assemble Promise post-composition lax 2-functors with explicit η witnesses. (examples/runnable/026-advanced-functor-traversable-and-free-algebra-suites.ts, examples/runnable/026b-free-endofunctor-algebra-strengths.ts)
27. **Monoidal functors and applicative-inspired zipping** – Monoidal functor instances for Option, Result, Reader, ReaderTask, ReaderTaskEither, and Validation enabling zipped combination of effects. (examples/runnable/027-monoidal-functors-and-applicative-inspired-zipping.ts)
28. **Monoidal functor law harness** – Property-based verification of functor identity/composition and lax monoidal unit, associativity, and naturality across Option, Result<string>, Reader<number>, ReaderTask<number>, and ReaderTaskEither<number, string>. (examples/runnable/028-monoidal-functor-law-harness.ts)
29. **Comonads, cofree constructions, and Store lenses** – Store, Env, Traced, Cofree, and StoreLens demonstrations including zipper navigation and DoCoBind programs. (examples/runnable/029-comonads-cofree-constructions-and-store-lenses.ts)
30. **Store–lens time-series smoothing walkthrough** – Build Stores over nested telemetry records, focus them with lenses to apply moving averages, compare lens-powered smoothing against manual reconstruction, and preserve metadata structure. (examples/runnable/030-store-lens-time-series-smoothing-walkthrough.ts, examples/runnable/030b-store-lens-focused-smoothing.ts)
31. **Mixed distributive laws for monad×comonad pairs** – Result×Store validation, Task×Store async contexts, and lifting monads to coalgebras or comonads to algebras through mixed distributive scaffolds. (examples/runnable/031-mixed-distributive-laws-for-monad-comonad-pairs.ts)
32. **2-functor and oplax strength demonstrations** – Composition of endofunctors, post-composition lax 2-functors, and environment-strengthened oplax 2-functors with explicit η and μ checks. (examples/runnable/032-2-functor-and-oplax-strength-demonstrations.ts)
33. **Relative monad diagnostics** – Registry reporting for relative monads, algebras, and opalgebras to ensure coverage of oracle registrations. (examples/runnable/033-relative-monad-diagnostics.ts)
34. **Record gluing and descent workflows** – Basic gluing, configuration reconciliation, microservice aggregation, and parallel computation consistency checks illustrating sheaf-like descent intuition. (examples/runnable/034-record-gluing-and-descent-workflows.ts)
35. **Semicartesian initial-unit oracles** – Derive global-element structure from initial tensor units, validate canonical arrows, and report counterexamples for semicartesian compatibility checks. (examples/runnable/035-semicartesian-initial-unit-oracles.ts)
36. **CRing⊕ semicartesian witnesses** – Instantiate additive/unit-preserving morphisms between commutative rings, construct canonical ℤ→A maps, and certify semicartesian structure within the CRing⊕ category. (examples/runnable/036-cring-semicartesian-witnesses.ts)
37. **Semicartesian infinite tensor products** – Package projection compatibility and universal property oracles for infinite semicartesian tensor products indexed by finite subsets. (examples/runnable/037-semicartesian-infinite-tensor-products.ts)
38. **C*-algebra witness and spectral diagnostics** – Provide complex-number C*-algebra operations with tolerance-aware equality and execute axiom, *-homomorphism, and spectral checks. (examples/runnable/038-c-algebra-witness-and-spectral-diagnostics.ts)
39. **Algebra oracle registry and relative monad reporting** – Aggregate semicartesian, causality, C*-algebra, and relative monad law oracles into a unified diagnostics surface. (examples/runnable/039-algebra-oracle-registry-and-relative-monad-reporting.ts)
40. **Comodule, entwining, and entwined module machinery** – Constructing corings, comodules, balanced tensors, entwinings, entwined modules, morphisms, and verifying compatibility laws. (examples/runnable/040-comodule-entwining-and-entwined-module-machinery.ts)
41. **Category of entwined modules and algebraic utilities** – Building categories of modules, checking morphism composition, and exercising weighted automata, HMMs, regex compilation, and graph algorithms. (examples/runnable/041-category-of-entwined-modules-and-algebraic-utilities.ts)
42. **Triangulated categories and homological algebra** – Constructing cones, verifying distinguished triangles, Smith normal form computations, and exactness checks in chain complexes. (examples/runnable/042-triangulated-categories-and-homological-algebra.ts)
43. **Rational arithmetic and linear algebra over ℚ** – Field operations, solving linear systems, nullspaces, and random complex generation with exact rational arithmetic. (examples/runnable/043-rational-arithmetic-and-linear-algebra-over.ts)
44. **Vector space and diagrammatic category utilities** – Finite posets, diagram reindexing, Kan extensions, universal properties, indexed families, category limits, arrow categories, and morphism families. (examples/runnable/044-vector-space-and-diagrammatic-category-utilities.ts)
45. **Diagram commutativity verification drills** – Triangle associativity, identity neutrality, pasted commuting rectangles, and tweaked commutativity helpers that permit parallel forks while detecting mismatches. (examples/runnable/045-diagram-commutativity-verification-drills.ts)
46. **Contravariant functor witnesses over Thin₂ and Poset₃** – Realize Set-valued contravariant functors from thin and poset categories, inspect reversed arrow action, and confirm composition reversal and evaluation behaviour. (examples/runnable/046-contravariant-functor-witnesses-over-thin-and-poset.ts)
47. **Virtual equipment companions, conjoints, and adjunctions** – Companion/conjoint availability, oracle summaries, complete adjunction chains (Σ ⊣ u* ⊣ Π), and Kan extensions in Vect. (examples/runnable/047-virtual-equipment-companions-conjoints-and-adjunctions.ts)
48. **Semiring rig registry and entire-check harness** – Centralize probability, boolean, tropical, ghost, and direct-sum rigs with equality, enumeration, and zero-divisor diagnostics for semiring-aware algorithms. (examples/runnable/048-semiring-rig-registry-and-entire-check-harness.ts)
49. **Semiring distribution monad constructors** – Build generalized distribution monads over arbitrary numeric semirings with map/bind/product operations and normalization helpers. (examples/runnable/049-semiring-distribution-monad-constructors.ts)
50. **Log-space Markov kernel composition chains** – Compose kernels via log-sum-exp, normalize n-step transitions, and maintain numeric stability in log-probability form. (examples/runnable/050-log-space-markov-kernel-composition-chains.ts)
51. **Boolean-semirring NFA reachability** – Model ε-free NFAs as boolean-valued kernels, compute reachable states, and decide acceptance over words. (examples/runnable/051-boolean-semirring-nfa-reachability.ts)
52. **Hidden Markov model inference algorithms** – Run Viterbi decoding in tropical max-plus form and forward inference in log/probability space with normalization safeguards. (examples/runnable/052-hidden-markov-model-inference-algorithms.ts)
53. **Probability monads and Kleisli scaffolding** – Dist/SubProb/Weighted monad specs, Kleisli composition/tensor helpers, deterministic embeddings, and matrix views over finite categories. (examples/runnable/053-probability-monads-and-kleisli-scaffolding.ts)
54. **Semiring distributive-law diagnostics** – Compare Fubini coherence via monoidal product versus bind/map routes and verify pullback squares across Prob, LogProb, MaxPlus, and Bool distribution monads to ensure semiring-specific compatibility. (examples/runnable/054-semiring-distributive-law-diagnostics.ts)
55. **Textbook categorical toolkit** – Building textbook-style categories, computing pullbacks, slice constructions, and dual categories for pedagogical tooling. (examples/runnable/055-textbook-categorical-toolkit.ts)
56. **Slice and coslice project walkthrough** – Model a project-focused category with tasks, users, and workflow arrows, then build (\(\mathcal{C}/\mathrm{Project}\)) and (\(\mathrm{Project}\\\mathcal{C}\)) to inspect how objects and mediating morphisms reorganize around the anchor. (examples/runnable/056-slice-and-coslice-project-walkthrough.ts)
57. **Concrete category backends and dynamic systems** – Examples over Set, Rel, Mat, and Dyn categories with concrete morphism checks and compositions. (examples/runnable/057-concrete-category-backends-and-dynamic-systems.ts)
58. **Category operations rewriter suggestions** – Execute the iso-cancellation, monic/right-inverse upgrades, balanced promotions, mutual mono merges, and epi–mono factorisation rules to surface structured `Rewrite` suggestions for finite categories. (examples/runnable/058-category-operations-rewriter-suggestions.ts)
59. **Markov foundational law harness** – Evaluate entirety, faithfulness, pullback-square uniqueness, and registry metadata via the consolidated Markov oracle surface to certify baseline categorical structure. (examples/runnable/059-markov-foundational-law-harness.ts, entirety-check.ts, pullback-check.ts)
60. **Markov determinism and thunkability diagnostics** – Extract Dirac bases, certify thunkability across generated probes, and exercise the determinism lemma witnesses that reconcile sampling with deterministic pushforwards. (examples/runnable/060-markov-determinism-and-thunkability-diagnostics.ts, markov-laws.ts, markov-thunkable.ts, markov-determinism-lemma.ts)
61. **Markov comonoid and SetMult deterministic bridge** – Build comonoid witnesses, verify copy/discard homomorphisms, and translate deterministic Markov kernels into SetMult witnesses with detailed counterexamples when laws fail. (examples/runnable/061-markov-comonoid-and-setmult-deterministic-bridge.ts, setmult-oracles.ts)
62. **Markov conditional independence and permutation invariants** – Package conditional kernels with projection data, reconstruct factorisations, and probe permutation-invariant decompositions for independence diagnostics. (examples/runnable/062-markov-conditional-independence-and-permutation-invariants.ts, markov-permutation.ts)
63. **Markov monoidal strength and tensor coherence** – Confirm Dirac monoidality, strength naturality, and sampling compatibility for independent products across numeric or boolean semirings. (examples/runnable/063-markov-monoidal-strength-and-tensor-coherence.ts)
64. **Graded Markov kernels and cost accounting** – Track monoidal grades alongside stochastic kernels to accumulate costs or evidence during composition, with nat-add and tropical grade monoids. (examples/runnable/064-graded-markov-kernels-and-cost-accounting.ts)
65. **Almost-sure equality and sampling cancellation** – Construct witnesses for p-almost-sure equality, compare sample-based equality, and bridge cancellation oracles across deterministic and stochastic morphisms. (examples/runnable/065-almost-sure-equality-and-sampling-cancellation.ts, as-equality.ts)
66. **Dominance, garbling, and BSS equivalence checks** – Verify single-output sufficiency via dilation witnesses, compare informativeness between experiments, and align Blackwell–Sherman–Stein diagnostics across decision problems. (examples/runnable/066-dominance-garbling-and-bss-equivalence-checks.ts, sosd.ts, garbling.ts, bss.ts, standard-experiment.ts)
67. **Infinite product and tail-law scaffolding** – Assemble Kolmogorov-consistent cylinders, tail-invariance reports, and extension universal properties for infinite tensor products in finite Markov categories. (examples/runnable/067-infinite-product-and-tail-law-scaffolding.ts, markov-infinite-oracles.ts)
68. **Borel–Stochastic zero-one adapters** – Convert measure-theoretic samplers and indicator predicates into Kolmogorov and Hewitt–Savage witnesses by canonicalizing product supports and finite symmetry actions over explicit \(\mathrm{Fin}\) carriers. (examples/runnable/068-borel-stochastic-zero-one-adapters.ts, borelstoch-examples.ts)
69. **Markov category zero-one theorems** – Determinism lemma witnesses, Kolmogorov/Hewitt–Savage zero-one oracles, and symmetry-aware oracle synthesis over finite Markov categories. (examples/runnable/069-markov-category-zero-one-theorems.ts)
70. **Synthesized zero-one oracle factory** – Automated assembly of zero-one law oracles from reusable components, verifying the synthesized report. (examples/runnable/070-synthesized-zero-one-oracle-factory.ts)
71. **Top/Vietoris zero-one scaffolding** – Kolmogorov witness adapters for the Vietoris Kleisli category, explicit Hewitt–Savage failure markers, and TODO factories for product priors and statistics in non-causal settings. (examples/runnable/071-top-vietoris-zero-one-scaffolding.ts, top-vietoris-examples.ts)
72. **Pushout calculators and universal mediators** – Compare the finite pushout search with the toy calculator on the canonical pushout fixture and replay the universal mediating arrow. (examples/runnable/072-pushout-calculators-and-universal-mediators.ts, pushout.ts, pushout-toy.ts, test/pushout-fixture.ts)
73. **Monoid categories and homomorphisms** – Explore MonCat homomorphisms between Z₄, parity, and Boolean-and monoids and inspect the induced one-object category from Z₄. (examples/runnable/073-monoid-categories-and-homs.ts, mon-cat.ts, monoid-cat.ts)
74. **Free category on a directed graph** – Build the free category on a depot→hub→campus transit graph, enumerate bounded paths, and compare composed and direct routes. (examples/runnable/074-free-category-on-a-directed-graph.ts, freecat.ts, graph.ts)

75. **Finite topology basics** – Sample discrete/indiscrete finite spaces, compute closures/interiors/boundaries, and inspect specialization orders alongside connectivity and Hausdorff checks. (examples/runnable/075-finite-topology-basics.ts)

76. **Product universal property for finite topological spaces** – Verify that discrete projections and pairings satisfy the product universal property and examine a subspace topology witness. (examples/runnable/076-top-product-universal-property.ts)

77. **Customer record pullback reconciliation** – Model sales/support spreadsheets as a FinSet cospan, compute their pullback, and expose the reconciled golden records together with marketing projections that factor uniquely. (examples/runnable/077-customer-record-pullback.ts)

78. **Pushout fixture shared across workflows** – Reuse the canonical finite pushout fixture to recover coslice reindexing mediators and certify that pushout legs preserve epimorphisms. (examples/runnable/078-pushout-shared-machinery.ts, pushout.ts, kinds/mono-epi.ts, test/pushout-fixture.ts)

79. **Topology constructors and initial/final structures** – Build finite topologies from bases and subbases, then push them through initial and final constructions for sensor/indicator maps. (examples/runnable/079-top-initial-final.ts)

80. **Quotient topologies and coequalizers** – Collapse walkway segments via an equivalence relation, inspect the induced quotient topology, and recover the same identification as a Top coequalizer. (examples/runnable/080-top-quotient.ts)

81. **Topological coproduct universal property** – Verify that disjoint unions of finite spaces satisfy the coproduct universal property and examine the induced copairing maps. (examples/runnable/081-top-coproduct-universal-property.ts)

82. **Continuity diagnostics and registry summaries** – Package enriched continuity witnesses, detect non-continuous maps, and surface aggregate registry diagnostics that reuse shared descriptors. (examples/runnable/082-top-continuity-diagnostics.ts)

83. **Universal-property reporting for Top** – Assemble product legs and mediators into reusable universal-property reports while contrasting a successful witness with a continuity failure. (examples/runnable/083-top-universal-property-reports.ts)

84. **MNNE powerset relative monad diagnostics** – Replay Example 8’s powerset relative monad on cofinite subsets, enumerate sampled images, and summarise the Street-style comparison reports. (examples/runnable/084-mnne-powerset-relative-monad.ts)

This outline preserves the intent of each runnable example so the implementations can be reconstructed methodically from foundational effects up to advanced categorical oracles.
