import { normalizeMod, createModuloRing, RingInteger } from "./instances"
import type { RingIdeal } from "./ideals"
import type { Module } from "./modules"
import type { Ring } from "./structures"
import type { AscendingChain, FinitelyGeneratedModule } from "./finitely-generated-modules"
import type { PrimeSpectrumPoint } from "../../schemes/prime-spectrum"
import type { MultiplicativeSet } from "./multiplicative-sets"
import type { LocalizationRingCheckOptions, LocalizationRingData } from "./localizations"

export interface RingSample<A> {
  readonly ring: Ring<A>
  readonly label: string
  readonly description: string
  readonly ringSamples: ReadonlyArray<A>
  readonly multiplicativeSets?: ReadonlyArray<MultiplicativeSetSample<A>>
  readonly primePoints: ReadonlyArray<PrimePointSample<A>>
  readonly primeSpectrum: ReadonlyArray<PrimeSpectrumPoint<A>>
}

export interface LocalizationHint<A> {
  readonly data: LocalizationRingData<A>
  readonly options: LocalizationRingCheckOptions<A>
}

export interface MultiplicativeSetSample<A> {
  readonly label: string
  readonly description: string
  readonly set: MultiplicativeSet<A>
  readonly generators?: ReadonlyArray<A>
  readonly ringSamples: ReadonlyArray<A>
  readonly localization?: LocalizationHint<A>
}

export interface PrimePointSample<A> {
  readonly point: PrimeSpectrumPoint<A>
  readonly generators: ReadonlyArray<A>
  readonly complement: MultiplicativeSet<A>
  readonly localization?: LocalizationHint<A>
}

export interface ModuleSample<R, M> {
  readonly module: Module<R, M>
  readonly label: string
  readonly description: string
  readonly vectorSamples: ReadonlyArray<M>
  readonly generatorSets: ReadonlyArray<ReadonlyArray<M>>
  readonly finitelyGenerated?: ReadonlyArray<FinitelyGeneratedModule<R, M>>
  readonly ascendingChains?: ReadonlyArray<AscendingChain<R, M>>
}

export type ModuleSampleAny = ModuleSample<any, any>

export interface RingLibraryEntry<A, Modules extends ModuleSampleAny = ModuleSampleAny> {
  readonly ring: RingSample<A>
  readonly modules: ReadonlyArray<Modules>
}

export type RingSampleLibrary = Readonly<Record<string, RingLibraryEntry<any>>>

const isDivisible = (value: bigint, modulus: bigint): boolean =>
  modulus === 0n ? value === 0n : normalizeMod(value, modulus) === 0n

export const principalIdealInZ = (generator: bigint, label: string): RingIdeal<bigint> => ({
  ring: RingInteger,
  contains:
    generator === 0n
      ? (value) => value === 0n
      : (value) => isDivisible(value, generator),
  name: label,
})

const integerModule: Module<bigint, bigint> = {
  ring: RingInteger,
  zero: 0n,
  add: (left, right) => left + right,
  neg: (value) => -value,
  scalar: (scalar, value) => scalar * value,
  eq: (left, right) => left === right,
  name: "ℤ as ℤ-module",
}

const integerFinitelyGenerated: FinitelyGeneratedModule<bigint, bigint> = {
  module: integerModule,
  generators: [1n],
  label: "⟨1⟩ = ℤ",
}

const integerAscendingChain: AscendingChain<bigint, bigint> = {
  module: integerModule,
  generatorSamples: [[0n], [2n], [1n], [1n]],
  label: "stabilizing principal ideals",
}

const powersOf5Set: MultiplicativeSet<bigint> = {
  ring: RingInteger,
  contains: (value) => value === 1n || (value % 5n === 0n && value !== 0n),
  label: "S = {1, 5, 10, …}",
}

const unitMissingSet: MultiplicativeSet<bigint> = {
  ring: RingInteger,
  contains: (value) => value === 1n || value === 2n,
  label: "{1, 2}",
}

const integerMultiplicativeSets: ReadonlyArray<MultiplicativeSetSample<bigint>> = [
  {
    label: "powersOf5",
    description: "Multiplicative set generated by 5 with nonzero multiples and 1.",
    set: powersOf5Set,
    generators: [5n],
    ringSamples: [1n, 5n, 10n, 25n],
    localization: {
      data: {
        base: RingInteger,
        multiplicativeSet: powersOf5Set,
      },
      options: {
        numeratorSamples: [-2n, -1n, 0n, 1n, 2n],
        denominatorSamples: [1n, 5n, 25n],
        multiplierSamples: [5n, 25n],
        fractionSamples: [
          { numerator: 1n, denominator: 5n },
          { numerator: 2n, denominator: 25n },
        ],
      },
    },
  },
  {
    label: "pairNotClosed",
    description: "Non-closed sample set {1, 2} for multiplicative set diagnostics.",
    set: unitMissingSet,
    ringSamples: [1n, 2n],
  },
]

const integerPrimePoints: ReadonlyArray<PrimePointSample<bigint>> = [
  {
    point: {
      ideal: principalIdealInZ(0n, "(0)"),
      label: "(0)",
      samples: [0n, 1n, -1n, 2n],
    },
    generators: [0n],
    complement: {
      ring: RingInteger,
      contains: (value) => value !== 0n,
      label: "ℤ \\ {0}",
    },
    localization: {
      data: {
        base: RingInteger,
        multiplicativeSet: {
          ring: RingInteger,
          contains: (value) => value !== 0n,
          label: "ℤ \\ {0}",
        },
      },
      options: {
        numeratorSamples: [-2n, -1n, 0n, 1n, 2n],
        denominatorSamples: [1n, 2n, 3n, 4n],
        multiplierSamples: [1n, 2n, 3n],
        fractionSamples: [
          { numerator: 1n, denominator: 2n },
          { numerator: -3n, denominator: 4n },
        ],
      },
    },
  },
  {
    point: {
      ideal: principalIdealInZ(2n, "(2)"),
      label: "(2)",
      samples: [0n, 2n, 4n, -2n, 1n, 3n],
    },
    generators: [2n],
    complement: {
      ring: RingInteger,
      contains: (value) => value % 2n !== 0n,
      label: "ℤ \\ (2)",
    },
    localization: {
      data: {
        base: RingInteger,
        multiplicativeSet: {
          ring: RingInteger,
          contains: (value) => value % 2n !== 0n,
          label: "ℤ \\ (2)",
        },
      },
      options: {
        numeratorSamples: [-3n, -1n, 0n, 1n, 3n],
        denominatorSamples: [1n, 3n, 5n, 7n],
        multiplierSamples: [1n, 3n, 5n],
        fractionSamples: [
          { numerator: 1n, denominator: 3n },
          { numerator: -1n, denominator: 5n },
        ],
      },
    },
  },
  {
    point: {
      ideal: principalIdealInZ(3n, "(3)"),
      label: "(3)",
      samples: [0n, 3n, 6n, -3n, 1n, 4n],
    },
    generators: [3n],
    complement: {
      ring: RingInteger,
      contains: (value) => value % 3n !== 0n,
      label: "ℤ \\ (3)",
    },
    localization: {
      data: {
        base: RingInteger,
        multiplicativeSet: {
          ring: RingInteger,
          contains: (value) => value % 3n !== 0n,
          label: "ℤ \\ (3)",
        },
      },
      options: {
        numeratorSamples: [-4n, -1n, 0n, 1n, 4n],
        denominatorSamples: [1n, 2n, 4n, 5n],
        multiplierSamples: [1n, 2n, 4n],
        fractionSamples: [
          { numerator: 2n, denominator: 5n },
          { numerator: -1n, denominator: 4n },
        ],
      },
    },
  },
  {
    point: {
      ideal: principalIdealInZ(5n, "(5)"),
      label: "(5)",
      samples: [-10n, -5n, -1n, 0n, 1n, 2n, 3n, 4n, 5n, 6n],
    },
    generators: [5n],
    complement: {
      ring: RingInteger,
      contains: (value) => value % 5n !== 0n,
      label: "ℤ \\ (5)",
    },
    localization: {
      data: {
        base: RingInteger,
        multiplicativeSet: {
          ring: RingInteger,
          contains: (value) => value % 5n !== 0n,
          label: "ℤ \\ (5)",
        },
      },
      options: {
        numeratorSamples: [-2n, -1n, 0n, 1n, 2n],
        denominatorSamples: [1n, 2n, 3n, 4n],
        multiplierSamples: [1n, 2n, 3n, 4n],
        fractionSamples: [
          { numerator: 1n, denominator: 2n },
          { numerator: -3n, denominator: 4n },
        ],
      },
    },
  },
]

const integerPrimeSpectrum: ReadonlyArray<PrimeSpectrumPoint<bigint>> =
  integerPrimePoints.map(({ point }) => point)

export const IntegerRingSample: RingSample<bigint> = {
  ring: RingInteger,
  label: "ℤ",
  description: "The integers with their standard ring structure.",
  ringSamples: [-3n, -2n, -1n, 0n, 1n, 2n, 3n, 4n, 5n],
  multiplicativeSets: integerMultiplicativeSets,
  primePoints: integerPrimePoints,
  primeSpectrum: integerPrimeSpectrum,
}

export const IntegerModuleSamples: ReadonlyArray<ModuleSample<bigint, bigint>> = [
  {
    module: integerModule,
    label: "ℤ",
    description: "ℤ viewed as a module over itself with principal generator 1.",
    vectorSamples: [-4n, -2n, -1n, 0n, 1n, 2n, 4n],
    generatorSets: [[1n]],
    finitelyGenerated: [integerFinitelyGenerated],
    ascendingChains: [integerAscendingChain],
  },
  {
    module: integerModule,
    label: "2ℤ",
    description: "Even integers form a ℤ-submodule generated by 2.",
    vectorSamples: [-6n, -4n, -2n, 0n, 2n, 4n, 6n],
    generatorSets: [[2n]],
    finitelyGenerated: [
      {
        module: integerModule,
        generators: [2n],
        label: "⟨2⟩",
      },
    ],
  },
]

export type DualNumber = { readonly real: bigint; readonly epsilon: bigint }

export const dualNumber = (real: bigint, epsilon: bigint): DualNumber => ({ real, epsilon })

export const RingDualNumbersOverZ: Ring<DualNumber> = {
  zero: dualNumber(0n, 0n),
  one: dualNumber(1n, 0n),
  add: (left, right) => dualNumber(left.real + right.real, left.epsilon + right.epsilon),
  mul: (left, right) =>
    dualNumber(left.real * right.real, left.real * right.epsilon + left.epsilon * right.real),
  neg: (value) => dualNumber(-value.real, -value.epsilon),
  sub: (left, right) => dualNumber(left.real - right.real, left.epsilon - right.epsilon),
  eq: (left, right) => left.real === right.real && left.epsilon === right.epsilon,
}

const dualZModule: Module<bigint, DualNumber> = {
  ring: RingInteger,
  zero: RingDualNumbersOverZ.zero,
  add: RingDualNumbersOverZ.add,
  neg: RingDualNumbersOverZ.neg,
  scalar: (scalar, value) => dualNumber(scalar * value.real, scalar * value.epsilon),
  eq: (left, right) => RingDualNumbersOverZ.eq?.(left, right) ?? (left.real === right.real && left.epsilon === right.epsilon),
  name: "ℤ[ε]/(ε²) as ℤ-module",
}

const dualSelfModule: Module<DualNumber, DualNumber> = {
  ring: RingDualNumbersOverZ,
  zero: RingDualNumbersOverZ.zero,
  add: RingDualNumbersOverZ.add,
  neg: RingDualNumbersOverZ.neg,
  scalar: RingDualNumbersOverZ.mul,
  eq: (left, right) => RingDualNumbersOverZ.eq?.(left, right) ?? (left.real === right.real && left.epsilon === right.epsilon),
  name: "ℤ[ε]/(ε²) as module over itself",
}

const epsilonIdeal: RingIdeal<DualNumber> = {
  ring: RingDualNumbersOverZ,
  contains: (value) => value.real === 0n,
  name: "(ε)",
}

const dualPrimeIdeal = (p: bigint): RingIdeal<DualNumber> => ({
  ring: RingDualNumbersOverZ,
  contains: (value) => isDivisible(value.real, p),
  name: `(${p}, ε)`,
})

const dualPrimePoints: ReadonlyArray<PrimePointSample<DualNumber>> = [
  {
    point: {
      ideal: epsilonIdeal,
      label: "(ε)",
      samples: [dualNumber(0n, 0n), dualNumber(0n, 1n), dualNumber(0n, -1n), dualNumber(2n, 0n)],
    },
    generators: [dualNumber(0n, 1n)],
    complement: {
      ring: RingDualNumbersOverZ,
      contains: (value) => value.real !== 0n,
      label: "units with nonzero real part",
    },
    localization: {
      data: {
        base: RingDualNumbersOverZ,
        multiplicativeSet: {
          ring: RingDualNumbersOverZ,
          contains: (value) => value.real !== 0n,
          label: "units with nonzero real part",
        },
      },
      options: {
        numeratorSamples: [
          dualNumber(-1n, 0n),
          dualNumber(0n, 1n),
          dualNumber(2n, -1n),
        ],
        denominatorSamples: [
          dualNumber(1n, 0n),
          dualNumber(-1n, 1n),
          dualNumber(2n, 0n),
        ],
        multiplierSamples: [
          dualNumber(1n, 0n),
          dualNumber(2n, 0n),
        ],
        fractionSamples: [
          { numerator: dualNumber(1n, 0n), denominator: dualNumber(1n, 0n) },
          { numerator: dualNumber(0n, 1n), denominator: dualNumber(1n, 0n) },
        ],
      },
    },
  },
  {
    point: {
      ideal: dualPrimeIdeal(2n),
      label: "(2, ε)",
      samples: [dualNumber(0n, 0n), dualNumber(2n, 1n), dualNumber(4n, 3n), dualNumber(6n, -2n)],
    },
    generators: [dualNumber(2n, 0n), dualNumber(0n, 1n)],
    complement: {
      ring: RingDualNumbersOverZ,
      contains: (value) => value.real % 2n !== 0n,
      label: "dual numbers with odd real part",
    },
    localization: {
      data: {
        base: RingDualNumbersOverZ,
        multiplicativeSet: {
          ring: RingDualNumbersOverZ,
          contains: (value) => value.real % 2n !== 0n,
          label: "dual numbers with odd real part",
        },
      },
      options: {
        numeratorSamples: [
          dualNumber(-1n, 0n),
          dualNumber(1n, 0n),
          dualNumber(3n, 2n),
        ],
        denominatorSamples: [
          dualNumber(1n, 0n),
          dualNumber(3n, 1n),
          dualNumber(5n, -2n),
        ],
        multiplierSamples: [
          dualNumber(1n, 0n),
          dualNumber(3n, 0n),
        ],
        fractionSamples: [
          { numerator: dualNumber(1n, 0n), denominator: dualNumber(3n, 1n) },
          { numerator: dualNumber(3n, 2n), denominator: dualNumber(5n, -2n) },
        ],
      },
    },
  },
  {
    point: {
      ideal: dualPrimeIdeal(3n),
      label: "(3, ε)",
      samples: [dualNumber(0n, 0n), dualNumber(3n, 1n), dualNumber(6n, 4n), dualNumber(9n, -2n)],
    },
    generators: [dualNumber(3n, 0n), dualNumber(0n, 1n)],
    complement: {
      ring: RingDualNumbersOverZ,
      contains: (value) => value.real % 3n !== 0n,
      label: "dual numbers with real part not divisible by 3",
    },
    localization: {
      data: {
        base: RingDualNumbersOverZ,
        multiplicativeSet: {
          ring: RingDualNumbersOverZ,
          contains: (value) => value.real % 3n !== 0n,
          label: "dual numbers with real part not divisible by 3",
        },
      },
      options: {
        numeratorSamples: [
          dualNumber(-2n, 1n),
          dualNumber(1n, 0n),
          dualNumber(4n, -1n),
        ],
        denominatorSamples: [
          dualNumber(1n, 0n),
          dualNumber(2n, 1n),
          dualNumber(4n, -1n),
        ],
        multiplierSamples: [
          dualNumber(1n, 0n),
          dualNumber(2n, 0n),
        ],
        fractionSamples: [
          { numerator: dualNumber(1n, 0n), denominator: dualNumber(2n, 1n) },
          { numerator: dualNumber(4n, -1n), denominator: dualNumber(4n, -1n) },
        ],
      },
    },
  },
]

const dualPrimeSpectrum: ReadonlyArray<PrimeSpectrumPoint<DualNumber>> =
  dualPrimePoints.map(({ point }) => point)

export const DualNumberRingSample: RingSample<DualNumber> = {
  ring: RingDualNumbersOverZ,
  label: "ℤ[ε]/(ε²)",
  description: "Dual numbers over ℤ with ε² = 0.",
  ringSamples: [
    dualNumber(-2n, 0n),
    dualNumber(-1n, 1n),
    dualNumber(0n, 0n),
    dualNumber(1n, 0n),
    dualNumber(2n, 3n),
    dualNumber(3n, -1n),
  ],
  primePoints: dualPrimePoints,
  primeSpectrum: dualPrimeSpectrum,
}

export const DualNumberModuleSamples: ReadonlyArray<
  ModuleSample<bigint, DualNumber> | ModuleSample<DualNumber, DualNumber>
> = [
  {
    module: dualZModule,
    label: "ℤ[ε]/(ε²) (ℤ)",
    description: "Dual numbers considered as a ℤ-module with basis {1, ε}.",
    vectorSamples: [
      dualNumber(0n, 0n),
      dualNumber(1n, 0n),
      dualNumber(0n, 1n),
      dualNumber(2n, 3n),
      dualNumber(-1n, 4n),
    ],
    generatorSets: [[dualNumber(1n, 0n), dualNumber(0n, 1n)]],
    finitelyGenerated: [
      {
        module: dualZModule,
        generators: [dualNumber(1n, 0n), dualNumber(0n, 1n)],
        label: "⟨1, ε⟩",
      },
    ],
  },
  {
    module: dualSelfModule,
    label: "ℤ[ε]/(ε²) (self)",
    description: "Dual numbers as a module over themselves via ring multiplication.",
    vectorSamples: [
      dualNumber(0n, 0n),
      dualNumber(1n, 0n),
      dualNumber(2n, 1n),
      dualNumber(-1n, 4n),
    ],
    generatorSets: [[dualNumber(1n, 0n)]],
  },
]

const modulus = 5n
export const RingFiniteField5: Ring<bigint> = createModuloRing(modulus)

const finiteFieldPrimePoints: ReadonlyArray<PrimePointSample<bigint>> = [
  {
    point: {
      ideal: {
        ring: RingFiniteField5,
        contains: (value) => normalizeMod(value, modulus) === 0n,
        name: "(0)",
      },
      label: "(0)",
      samples: [0n, 1n, 2n, 3n, 4n],
    },
    generators: [0n],
    complement: {
      ring: RingFiniteField5,
      contains: (value) => normalizeMod(value, modulus) !== 0n,
      label: "𝔽₅^×",
    },
    localization: {
      data: {
        base: RingFiniteField5,
        multiplicativeSet: {
          ring: RingFiniteField5,
          contains: (value) => normalizeMod(value, modulus) !== 0n,
          label: "𝔽₅^×",
        },
      },
      options: {
        numeratorSamples: [0n, 1n, 2n, 3n, 4n],
        denominatorSamples: [1n, 2n, 3n, 4n],
        multiplierSamples: [1n, 2n, 3n, 4n],
        fractionSamples: [
          { numerator: 1n, denominator: 2n },
          { numerator: 3n, denominator: 4n },
        ],
      },
    },
  },
]

const finiteFieldPrimeSpectrum: ReadonlyArray<PrimeSpectrumPoint<bigint>> =
  finiteFieldPrimePoints.map(({ point }) => point)

const finiteFieldModule: Module<bigint, bigint> = {
  ring: RingFiniteField5,
  zero: RingFiniteField5.zero,
  add: RingFiniteField5.add,
  neg: RingFiniteField5.neg,
  scalar: RingFiniteField5.mul,
  eq: (left, right) => RingFiniteField5.eq?.(left, right) ?? left === right,
  name: "𝔽₅ as module over itself",
}

export const FiniteFieldRingSample: RingSample<bigint> = {
  ring: RingFiniteField5,
  label: "𝔽₅",
  description: "Finite field with five elements realized as ℤ/5ℤ.",
  ringSamples: [0n, 1n, 2n, 3n, 4n],
  primePoints: finiteFieldPrimePoints,
  primeSpectrum: finiteFieldPrimeSpectrum,
}

export const FiniteFieldModuleSamples: ReadonlyArray<ModuleSample<bigint, bigint>> = [
  {
    module: finiteFieldModule,
    label: "𝔽₅",
    description: "𝔽₅ as a one-dimensional vector space over itself.",
    vectorSamples: [0n, 1n, 2n, 3n, 4n],
    generatorSets: [[1n]],
    finitelyGenerated: [
      {
        module: finiteFieldModule,
        generators: [1n],
        label: "⟨1⟩",
      },
    ],
    ascendingChains: [
      {
        module: finiteFieldModule,
        generatorSamples: [[0n], [1n], [1n]],
        label: "trivial stabilization",
      },
    ],
  },
]

export const CommutativeRingSamples = {
  integers: {
    ring: IntegerRingSample,
    modules: IntegerModuleSamples,
  },
  dualNumbersOverZ: {
    ring: DualNumberRingSample,
    modules: DualNumberModuleSamples,
  },
  finiteField5: {
    ring: FiniteFieldRingSample,
    modules: FiniteFieldModuleSamples,
  },
} as const satisfies RingSampleLibrary
